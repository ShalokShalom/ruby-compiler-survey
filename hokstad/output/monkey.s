	.equ   __voff__new, 24	
	.equ   __voff____send__, 28	
	.equ   __voff____get_symbol, 32	
	.equ   __voff____initialize, 36	
	.equ   __voff__allocate, 40	
	.equ   __voff____new, 44	
	.equ   __voff__name, 48	
	.equ   __voff__to_s, 52	
	.equ   __voff__inspect, 56	
	.equ   __voff____X__3d, 60	
	.equ   __voff__superclass, 64	
	.equ   __voff__define_method, 68	
	.equ   __voff__attr_accessor, 72	
	.equ   __voff__attr_reader, 76	
	.equ   __voff__attr_writer, 80	
	.equ   __voff__puts, 84	
	.equ   __voff__initialize, 88	
	.equ   __voff__class, 92	
	.equ   __voff__object_id, 96	
	.equ   __voff__hash, 100	
	.equ   __voff__eql__Q, 104	
	.equ   __voff____eq__3d, 108	
	.equ   __voff____eq, 112	
	.equ   __voff____X, 116	
	.equ   __voff__nil__Q, 120	
	.equ   __voff__method_missing, 124	
	.equ   __voff__respond_to__Q, 128	
	.equ   __voff__is_a__Q, 132	
	.equ   __voff__kind_of__Q, 136	
	.equ   __voff__send, 140	
	.equ   __voff__p, 144	
	.equ   __voff__exit, 148	
	.equ   __voff__print, 152	
	.equ   __voff__Array, 156	
	.equ   __voff__dup, 160	
	.equ   __voff____set_raw, 164	
	.equ   __voff__arity, 168	
	.equ   __voff__call, 172	
	.equ   __voff____len, 176	
	.equ   __voff____ptr, 180	
	.equ   __voff____grow, 184	
	.equ   __voff____set, 188	
	.equ   __voff__to_a, 192	
	.equ   __voff____true__Q, 196	
	.equ   __voff__first, 200	
	.equ   __voff__last, 204	
	.equ   __voff__member__Q, 208	
	.equ   __voff__include__Q, 212	
	.equ   __voff__each, 216	
	.equ   __voff__to_enum, 220	
	.equ   __voff__capacity, 224	
	.equ   __voff____get, 228	
	.equ   __voff__find, 232	
	.equ   __voff__reject, 236	
	.equ   __voff__collect, 240	
	.equ   __voff__detect, 244	
	.equ   __voff__each_with_index, 248	
	.equ   __voff____plus, 252	
	.equ   __voff____lt__lt, 256	
	.equ   __voff____NDX, 260	
	.equ   __voff____offset_to_pos, 264	
	.equ   __voff____range_get, 268	
	.equ   __voff____NDX__3d, 272	
	.equ   __voff__abbrev, 276	
	.equ   __voff__slice, 280	
	.equ   __voff__assoc, 284	
	.equ   __voff__at, 288	
	.equ   __voff__clear, 292	
	.equ   __voff__collect__X, 296	
	.equ   __voff__compact, 300	
	.equ   __voff__compact__X, 304	
	.equ   __voff__concat, 308	
	.equ   __voff__dclone, 312	
	.equ   __voff__delete, 316	
	.equ   __voff__delete_at, 320	
	.equ   __voff__delete_if, 324	
	.equ   __voff__each_index, 328	
	.equ   __voff__empty__Q, 332	
	.equ   __voff__fetch, 336	
	.equ   __voff__fill, 340	
	.equ   __voff__flatten, 344	
	.equ   __voff__flatten__X, 348	
	.equ   __voff__frozen__Q, 352	
	.equ   __voff__index, 356	
	.equ   __voff__replace, 360	
	.equ   __voff__insert, 364	
	.equ   __voff__join, 368	
	.equ   __voff__length, 372	
	.equ   __voff__map__X, 376	
	.equ   __voff__nitems, 380	
	.equ   __voff__pack, 384	
	.equ   __voff__pop, 388	
	.equ   __voff__pretty_print, 392	
	.equ   __voff__push, 396	
	.equ   __voff__quote, 400	
	.equ   __voff__rassoc, 404	
	.equ   __voff__reject__X, 408	
	.equ   __voff__reverse, 412	
	.equ   __voff__reverse__X, 416	
	.equ   __voff__reverse_each, 420	
	.equ   __voff__rindex, 424	
	.equ   __voff__shift, 428	
	.equ   __voff__size, 432	
	.equ   __voff__partition, 436	
	.equ   __voff__sort_by, 440	
	.equ   __voff__sort, 444	
	.equ   __voff__sort__X, 448	
	.equ   __voff__to_ary, 452	
	.equ   __voff__to_yaml, 456	
	.equ   __voff__transpose, 460	
	.equ   __voff__uniq, 464	
	.equ   __voff__uniq__X, 468	
	.equ   __voff__unshift, 472	
	.equ   __voff__values_at, 476	
	.equ   __voff__yaml_initialize, 480	
	.equ   __voff__zip, 484	
	.equ   __voff____copy_raw, 488	
	.equ   __voff____get_raw, 492	
	.equ   __voff__chr, 496	
	.equ   __voff__ord, 500	
	.equ   __voff__each_byte, 504	
	.equ   __voff____le__gt, 508	
	.equ   __voff__to_sym, 512	
	.equ   __voff__to_i, 516	
	.equ   __voff__slice__X, 520	
	.equ   __voff__count, 524	
	.equ   __voff____mul, 528	
	.equ   __voff__gsub, 532	
	.equ   __voff__split, 536	
	.equ   __voff___alloc_data, 540	
	.equ   __voff___bulkinsert, 544	
	.equ   __voff___grow, 548	
	.equ   __voff___find_slot, 552	
	.equ   __voff__capacity_too_low, 556	
	.equ   __voff____delete_first, 560	
	.equ   __voff__getc, 564	
	.equ   __voff__file__Q, 568	
	.equ   __voff__path, 572	
	.equ   __voff__open, 576	
	.equ   __voff__exists__Q, 580	
	.equ   __voff__basename, 584	
	.equ   __voff__dirname, 588	
	.equ   __voff__expand_path, 592	
	.equ   __voff__pwd, 596	
	.equ   __voff____25, 600	
	.equ   __voff____minus, 604	
	.equ   __voff____le, 608	
	.equ   __voff____lt, 612	
	.equ   __voff____gt, 616	
	.equ   __voff____ge, 620	
	.equ   __voff__div, 624	
	.equ   __voff__mul, 628	
	.equ   __voff____div, 632	
	.equ   __voff__times, 636	
	.equ   __voff__method_to_voff, 640	
	.equ   __voff____send_for_obj__, 644	
	.equ   __voff__keys, 648	
	.equ   __voff__next, 652	
	.equ   __voff__rewind, 656	
	.equ   __voff__raise, 660	
	.equ   __voff__multiply, 664	
	.file "/var/examples/monkey.rb"	
	.stabs  "/var/examples/",100,0,2,.Ltext0	
	.stabs  "monkey.rb",100,0,2,.Ltext0	
	.text	
.Ltext0:
.globl main
	.type	main, @function
main:
.LFBB0:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ecx
	# Stack frame
	pushl	%ebp
	popl	%eax
	movl	%eax, __stack_top
	.stabn  68,0,1,.LM0	
.LM0:
	.stabs  "/home/vagrant/hokstad/lib/core/core.rb",130,0,0,0	
	.stabn  68,0,1,.LM1 -.LFBB0	
.LM1:
	.stabn  68,0,53,.LM2 -.LFBB0	
.LM2:
	.stabs  "/home/vagrant/hokstad/lib/core/base.rb",130,0,0,0	
	.stabn  68,0,1,.LM3 -.LFBB0	
.LM3:
	.stabn  68,0,11,.LM4 -.LFBB0	
.LM4:
	movl	$__method_missing, %eax
	.stabn  68,0,22,.LM5 -.LFBB0	
.LM5:
	subl	$28, %esp
	# Stack frame
	movl	%ebp, (%esp)
	movl	$__roots_start, %eax
	movl	%eax, 4(%esp)
	movl	$__roots_end, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	tgc_start
	addl	$28, %esp
	.stabn  68,0,24,.LM6 -.LFBB0	
.LM6:
	movl	$__alloc, %eax
	.stabn  68,0,32,.LM7 -.LFBB0	
.LM7:
	movl	$__alloc_mem, %eax
	.stabn  68,0,33,.LM8 -.LFBB0	
.LM8:
	movl	$__alloc_leaf, %eax
	.stabn  68,0,34,.LM9 -.LFBB0	
.LM9:
	movl	$__realloc, %eax
	.stabn  68,0,37,.LM10 -.LFBB0	
.LM10:
	movl	$__array, %eax
	.stabn  68,0,38,.LM11 -.LFBB0	
.LM11:
	movl	$__array_leaf, %eax
	.stabn  68,0,41,.LM12 -.LFBB0	
.LM12:
	movl	$0, __cnt
	.stabn  68,0,42,.LM13 -.LFBB0	
.LM13:
	movl	$__docnt, %eax
	.stabn  68,0,47,.LM14 -.LFBB0	
.LM14:
	subl	$20, %esp
	movl	$tgc_stop, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	atexit
	addl	$20, %esp
	.stabn  162,0,0,0	
	# End include "/home/vagrant/hokstad/lib/core/base.rb"
	.stabn  68,0,60,.LM15 -.LFBB0	
.LM15:
	.stabs  "/home/vagrant/hokstad/lib/core/class.rb",130,0,0,0	
	.stabn  68,0,1,.LM16 -.LFBB0	
.LM16:
	.stabn  68,0,2,.LM17 -.LFBB0	
.LM17:
	movl	$__new_class_object, %eax
	.stabn  68,0,54,.LM18 -.LFBB0	
.LM18:
	movl	$__set_vtable, %eax
	.stabn  68,0,71,.LM19 -.LFBB0	
.LM19:
	# === class Class ===
	# if: [:sexp, [:eq, :Class, 0]]
	movl	Class, %eax
	movl	%eax, %edx
	movl	$0, %eax
	cmpl	%eax, %edx
	sete	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L118_else
	# then: [:assign, :Class, [:sexp, [:call, :__new_class_object, [668, :Object, 0, :Class]]]]
	subl	$32, %esp
	movl	$668, (%esp)
	movl	Object, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	Class, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	__new_class_object
	addl	$32, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, Class
	# else: nil
.L118_else:
	movl	Class, %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	movl	$4, (%ecx)
	movl	$.L120, %eax
	pushl	%eax
	movl	Class, %eax
	movl	%eax, %edi
	addl	$8, %edi
	popl	%eax
	movl	%eax, (%edi)
	.stabn  68,0,83,.LM20 -.LFBB0	
.LM20:
	subl	$28, %esp
	movl	Class, %eax
	movl	%eax, (%esp)
	movl	$9, 4(%esp)
	movl	$__method_Class___initialize, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,89,.LM21 -.LFBB0	
.LM21:
	subl	$28, %esp
	movl	Class, %eax
	movl	%eax, (%esp)
	movl	$10, 4(%esp)
	movl	$__method_Class_allocate, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,103,.LM22 -.LFBB0	
.LM22:
	subl	$28, %esp
	movl	Class, %eax
	movl	%eax, (%esp)
	movl	$11, 4(%esp)
	movl	$__method_Class___new, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,109,.LM23 -.LFBB0	
.LM23:
	subl	$28, %esp
	movl	Class, %eax
	movl	%eax, (%esp)
	movl	$6, 4(%esp)
	movl	$__method_Class_new, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,115,.LM24 -.LFBB0	
.LM24:
	subl	$28, %esp
	movl	Class, %eax
	movl	%eax, (%esp)
	movl	$12, 4(%esp)
	movl	$__method_Class_name, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,119,.LM25 -.LFBB0	
.LM25:
	subl	$28, %esp
	movl	Class, %eax
	movl	%eax, (%esp)
	movl	$13, 4(%esp)
	movl	$__method_Class_to_s, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,123,.LM26 -.LFBB0	
.LM26:
	subl	$28, %esp
	movl	Class, %eax
	movl	%eax, (%esp)
	movl	$14, 4(%esp)
	movl	$__method_Class_inspect, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,127,.LM27 -.LFBB0	
.LM27:
	subl	$28, %esp
	movl	Class, %eax
	movl	%eax, (%esp)
	movl	$15, 4(%esp)
	movl	$__method_Class___X__3d, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,135,.LM28 -.LFBB0	
.LM28:
	subl	$28, %esp
	movl	Class, %eax
	movl	%eax, (%esp)
	movl	$16, 4(%esp)
	movl	$__method_Class_superclass, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,150,.LM29 -.LFBB0	
.LM29:
	subl	$28, %esp
	movl	Class, %eax
	movl	%eax, (%esp)
	movl	$17, 4(%esp)
	movl	$__method_Class_define_method, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,155,.LM30 -.LFBB0	
.LM30:
	subl	$28, %esp
	movl	Class, %eax
	movl	%eax, (%esp)
	movl	$18, 4(%esp)
	movl	$__method_Class_attr_accessor, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,160,.LM31 -.LFBB0	
.LM31:
	subl	$28, %esp
	movl	Class, %eax
	movl	%eax, (%esp)
	movl	$19, 4(%esp)
	movl	$__method_Class_attr_reader, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,168,.LM32 -.LFBB0	
.LM32:
	subl	$28, %esp
	movl	Class, %eax
	movl	%eax, (%esp)
	movl	$20, 4(%esp)
	movl	$__method_Class_attr_writer, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	# === end class Class ===
	movl	Class, %eax
	.stabn  68,0,179,.LM33 -.LFBB0	
.LM33:
	movl	Class, %eax
	pushl	%eax
	movl	Class, %eax
	movl	%eax, %edx
	popl	%eax
	movl	%eax, (%edx)
	.stabn  68,0,180,.LM34 -.LFBB0	
.LM34:
	movl	$.L120, %eax
	pushl	%eax
	movl	Class, %eax
	movl	%eax, %ecx
	addl	$8, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	.stabn  162,0,0,0	
	# End include "/home/vagrant/hokstad/lib/core/class.rb"
	.stabn  68,0,61,.LM35 -.LFBB0	
.LM35:
	.stabs  "/home/vagrant/hokstad/lib/core/kernel.rb",130,0,0,0	
	.stabn  68,0,1,.LM36 -.LFBB0	
.LM36:
	.stabn  68,0,2,.LM37 -.LFBB0	
.LM37:
	# === class Kernel ===
	# if: [:sexp, [:eq, :Kernel, 0]]
	movl	Kernel, %eax
	movl	%eax, %edi
	movl	$0, %eax
	cmpl	%eax, %edi
	sete	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L134_else
	# then: [:assign, :Kernel, [:sexp, [:call, :__new_class_object, [668, :Object, 0, :Class]]]]
	subl	$32, %esp
	movl	$668, (%esp)
	movl	Object, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	Class, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	__new_class_object
	addl	$32, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, Kernel
	# else: nil
.L134_else:
	movl	Kernel, %eax
	movl	%eax, %edx
	addl	$4, %edx
	movl	$1, (%edx)
	movl	$.L136, %eax
	pushl	%eax
	movl	Kernel, %eax
	movl	%eax, %ecx
	addl	$8, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	.stabn  68,0,3,.LM38 -.LFBB0	
.LM38:
	subl	$28, %esp
	movl	Kernel, %eax
	movl	%eax, (%esp)
	movl	$21, 4(%esp)
	movl	$__method_Kernel_puts, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	# === end class Kernel ===
	movl	Kernel, %eax
	.stabn  162,0,0,0	
	# End include "/home/vagrant/hokstad/lib/core/kernel.rb"
	.stabn  68,0,62,.LM39 -.LFBB0	
.LM39:
	.stabs  "/home/vagrant/hokstad/lib/core/object.rb",130,0,0,0	
	.stabn  68,0,1,.LM40 -.LFBB0	
.LM40:
	.stabn  68,0,2,.LM41 -.LFBB0	
.LM41:
	# === class Object ===
	# if: [:sexp, [:eq, :Object, 0]]
	movl	Object, %eax
	movl	%eax, %edi
	movl	$0, %eax
	cmpl	%eax, %edi
	sete	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L138_else
	# then: [:assign, :Object, [:sexp, [:call, :__new_class_object, [668, :Object, 0, :Class]]]]
	subl	$32, %esp
	movl	$668, (%esp)
	movl	Object, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	Class, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	__new_class_object
	addl	$32, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, Object
	# else: nil
.L138_else:
	movl	Object, %eax
	movl	%eax, %edx
	addl	$4, %edx
	movl	$1, (%edx)
	movl	$.L140, %eax
	pushl	%eax
	movl	Object, %eax
	movl	%eax, %ecx
	addl	$8, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	.stabn  68,0,10,.LM42 -.LFBB0	
.LM42:
	movl	Class, %eax
	pushl	%eax
	movl	Object, %eax
	movl	%eax, %edi
	addl	$16, %edi
	popl	%eax
	movl	%eax, (%edi)
	.stabn  68,0,12,.LM43 -.LFBB0	
.LM43:
	.stabn  68,0,14,.LM44 -.LFBB0	
.LM44:
	subl	$28, %esp
	movl	Object, %eax
	movl	%eax, (%esp)
	movl	$22, 4(%esp)
	movl	$__method_Object_initialize, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,18,.LM45 -.LFBB0	
.LM45:
	subl	$28, %esp
	movl	Object, %eax
	movl	%eax, (%esp)
	movl	$23, 4(%esp)
	movl	$__method_Object_class, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,22,.LM46 -.LFBB0	
.LM46:
	subl	$28, %esp
	movl	Object, %eax
	movl	%eax, (%esp)
	movl	$24, 4(%esp)
	movl	$__method_Object_object_id, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,26,.LM47 -.LFBB0	
.LM47:
	subl	$28, %esp
	movl	Object, %eax
	movl	%eax, (%esp)
	movl	$25, 4(%esp)
	movl	$__method_Object_hash, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,30,.LM48 -.LFBB0	
.LM48:
	subl	$28, %esp
	movl	Object, %eax
	movl	%eax, (%esp)
	movl	$26, 4(%esp)
	movl	$__method_Object_eql__Q, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,34,.LM49 -.LFBB0	
.LM49:
	subl	$28, %esp
	movl	Object, %eax
	movl	%eax, (%esp)
	movl	$27, 4(%esp)
	movl	$__method_Object___eq__3d, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,38,.LM50 -.LFBB0	
.LM50:
	subl	$28, %esp
	movl	Object, %eax
	movl	%eax, (%esp)
	movl	$14, 4(%esp)
	movl	$__method_Object_inspect, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,45,.LM51 -.LFBB0	
.LM51:
	subl	$28, %esp
	movl	Object, %eax
	movl	%eax, (%esp)
	movl	$13, 4(%esp)
	movl	$__method_Object_to_s, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,49,.LM52 -.LFBB0	
.LM52:
	subl	$28, %esp
	movl	Object, %eax
	movl	%eax, (%esp)
	movl	$28, 4(%esp)
	movl	$__method_Object___eq, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,53,.LM53 -.LFBB0	
.LM53:
	subl	$28, %esp
	movl	Object, %eax
	movl	%eax, (%esp)
	movl	$29, 4(%esp)
	movl	$__method_Object___X, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,57,.LM54 -.LFBB0	
.LM54:
	subl	$28, %esp
	movl	Object, %eax
	movl	%eax, (%esp)
	movl	$15, 4(%esp)
	movl	$__method_Object___X__3d, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,61,.LM55 -.LFBB0	
.LM55:
	subl	$28, %esp
	movl	Object, %eax
	movl	%eax, (%esp)
	movl	$30, 4(%esp)
	movl	$__method_Object_nil__Q, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,65,.LM56 -.LFBB0	
.LM56:
	subl	$28, %esp
	movl	Object, %eax
	movl	%eax, (%esp)
	movl	$31, 4(%esp)
	movl	$__method_Object_method_missing, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,71,.LM57 -.LFBB0	
.LM57:
	subl	$28, %esp
	movl	Object, %eax
	movl	%eax, (%esp)
	movl	$32, 4(%esp)
	movl	$__method_Object_respond_to__Q, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,92,.LM58 -.LFBB0	
.LM58:
	subl	$28, %esp
	movl	Object, %eax
	movl	%eax, (%esp)
	movl	$33, 4(%esp)
	movl	$__method_Object_is_a__Q, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,103,.LM59 -.LFBB0	
.LM59:
	subl	$28, %esp
	movl	Object, %eax
	movl	%eax, (%esp)
	movl	$34, 4(%esp)
	movl	$__method_Object_kind_of__Q, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,108,.LM60 -.LFBB0	
.LM60:
	subl	$28, %esp
	movl	Object, %eax
	movl	%eax, (%esp)
	movl	$35, 4(%esp)
	movl	$__method_Object_send, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,112,.LM61 -.LFBB0	
.LM61:
	subl	$28, %esp
	movl	Object, %eax
	movl	%eax, (%esp)
	movl	$7, 4(%esp)
	movl	$__method_Object___send__, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,123,.LM62 -.LFBB0	
.LM62:
	subl	$28, %esp
	movl	Object, %eax
	movl	%eax, (%esp)
	movl	$36, 4(%esp)
	movl	$__method_Object_p, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,129,.LM63 -.LFBB0	
.LM63:
	subl	$28, %esp
	movl	Object, %eax
	movl	%eax, (%esp)
	movl	$37, 4(%esp)
	movl	$__method_Object_exit, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,134,.LM64 -.LFBB0	
.LM64:
	subl	$28, %esp
	movl	Object, %eax
	movl	%eax, (%esp)
	movl	$21, 4(%esp)
	movl	$__method_Object_puts, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,160,.LM65 -.LFBB0	
.LM65:
	subl	$28, %esp
	movl	Object, %eax
	movl	%eax, (%esp)
	movl	$38, 4(%esp)
	movl	$__method_Object_print, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,179,.LM66 -.LFBB0	
.LM66:
	subl	$28, %esp
	movl	Object, %eax
	movl	%eax, (%esp)
	movl	$39, 4(%esp)
	movl	$__method_Object_Array, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,189,.LM67 -.LFBB0	
.LM67:
	subl	$28, %esp
	movl	Object, %eax
	movl	%eax, (%esp)
	movl	$40, 4(%esp)
	movl	$__method_Object_dup, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	# === end class Object ===
	movl	Object, %eax
	.stabn  162,0,0,0	
	# End include "/home/vagrant/hokstad/lib/core/object.rb"
	.stabn  68,0,63,.LM68 -.LFBB0	
.LM68:
	.stabs  "/home/vagrant/hokstad/lib/core/proc.rb",130,0,0,0	
	.stabn  68,0,1,.LM69 -.LFBB0	
.LM69:
	.stabn  68,0,2,.LM70 -.LFBB0	
.LM70:
	# === class Proc ===
	# if: [:sexp, [:eq, :Proc, 0]]
	movl	Proc, %eax
	movl	%eax, %edx
	movl	$0, %eax
	cmpl	%eax, %edx
	sete	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L165_else
	# then: [:assign, :Proc, [:sexp, [:call, :__new_class_object, [668, :Object, 668, :Class]]]]
	subl	$32, %esp
	movl	$668, (%esp)
	movl	Object, %eax
	movl	%eax, 4(%esp)
	movl	$668, 8(%esp)
	movl	Class, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	__new_class_object
	addl	$32, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, Proc
	# else: nil
.L165_else:
	movl	Proc, %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	movl	$5, (%ecx)
	movl	$.L167, %eax
	pushl	%eax
	movl	Proc, %eax
	movl	%eax, %edi
	addl	$8, %edi
	popl	%eax
	movl	%eax, (%edi)
	.stabn  68,0,3,.LM71 -.LFBB0	
.LM71:
	subl	$28, %esp
	movl	Proc, %eax
	movl	%eax, (%esp)
	movl	$22, 4(%esp)
	movl	$__method_Proc_initialize, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,15,.LM72 -.LFBB0	
.LM72:
	subl	$28, %esp
	movl	Proc, %eax
	movl	%eax, (%esp)
	movl	$41, 4(%esp)
	movl	$__method_Proc___set_raw, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,22,.LM73 -.LFBB0	
.LM73:
	subl	$28, %esp
	movl	Proc, %eax
	movl	%eax, (%esp)
	movl	$42, 4(%esp)
	movl	$__method_Proc_arity, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,26,.LM74 -.LFBB0	
.LM74:
	subl	$28, %esp
	movl	Proc, %eax
	movl	%eax, (%esp)
	movl	$43, 4(%esp)
	movl	$__method_Proc_call, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	# === end class Proc ===
	movl	Proc, %eax
	.stabn  68,0,34,.LM75 -.LFBB0	
.LM75:
	movl	$__new_proc, %eax
	.stabn  162,0,0,0	
	# End include "/home/vagrant/hokstad/lib/core/proc.rb"
	.stabn  68,0,64,.LM76 -.LFBB0	
.LM76:
	.stabs  "/home/vagrant/hokstad/lib/core/array_base.rb",130,0,0,0	
	.stabn  68,0,1,.LM77 -.LFBB0	
.LM77:
	.stabn  68,0,5,.LM78 -.LFBB0	
.LM78:
	# === class Array ===
	# if: [:sexp, [:eq, :Array, 0]]
	movl	Array, %eax
	movl	%eax, %edx
	movl	$0, %eax
	cmpl	%eax, %edx
	sete	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L173_else
	# then: [:assign, :Array, [:sexp, [:call, :__new_class_object, [668, :Object, 668, :Class]]]]
	subl	$32, %esp
	movl	$668, (%esp)
	movl	Object, %eax
	movl	%eax, 4(%esp)
	movl	$668, 8(%esp)
	movl	Class, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	__new_class_object
	addl	$32, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, Array
	# else: nil
.L173_else:
	movl	Array, %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	movl	$4, (%ecx)
	movl	$.L175, %eax
	pushl	%eax
	movl	Array, %eax
	movl	%eax, %edi
	addl	$8, %edi
	popl	%eax
	movl	%eax, (%edi)
	.stabn  68,0,8,.LM79 -.LFBB0	
.LM79:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$9, 4(%esp)
	movl	$__method_Array___initialize, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,15,.LM80 -.LFBB0	
.LM80:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$44, 4(%esp)
	movl	$__method_Array___len, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,19,.LM81 -.LFBB0	
.LM81:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$45, 4(%esp)
	movl	$__method_Array___ptr, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,23,.LM82 -.LFBB0	
.LM82:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$46, 4(%esp)
	movl	$__method_Array___grow, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,41,.LM83 -.LFBB0	
.LM83:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$47, 4(%esp)
	movl	$__method_Array___set, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,46,.LM84 -.LFBB0	
.LM84:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$48, 4(%esp)
	movl	$__method_Array_to_a, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	# === end class Array ===
	movl	Array, %eax
	.stabn  68,0,67,.LM85 -.LFBB0	
.LM85:
	movl	$__splat_to_Array, %eax
	.stabn  162,0,0,0	
	# End include "/home/vagrant/hokstad/lib/core/array_base.rb"
	.stabn  68,0,65,.LM86 -.LFBB0	
.LM86:
	.stabs  "/home/vagrant/hokstad/lib/core/true.rb",130,0,0,0	
	.stabn  68,0,1,.LM87 -.LFBB0	
.LM87:
	.stabn  68,0,2,.LM88 -.LFBB0	
.LM88:
	# === class TrueClass ===
	# if: [:sexp, [:eq, :TrueClass, 0]]
	movl	TrueClass, %eax
	movl	%eax, %edx
	movl	$0, %eax
	cmpl	%eax, %edx
	sete	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L183_else
	# then: [:assign, :TrueClass, [:sexp, [:call, :__new_class_object, [668, :Object, 668, :Class]]]]
	subl	$32, %esp
	movl	$668, (%esp)
	movl	Object, %eax
	movl	%eax, 4(%esp)
	movl	$668, 8(%esp)
	movl	Class, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	__new_class_object
	addl	$32, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, TrueClass
	# else: nil
.L183_else:
	movl	TrueClass, %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	movl	$1, (%ecx)
	movl	$.L185, %eax
	pushl	%eax
	movl	TrueClass, %eax
	movl	%eax, %edi
	addl	$8, %edi
	popl	%eax
	movl	%eax, (%edi)
	.stabn  68,0,4,.LM89 -.LFBB0	
.LM89:
	subl	$28, %esp
	movl	TrueClass, %eax
	movl	%eax, (%esp)
	movl	$29, 4(%esp)
	movl	$__method_TrueClass___X, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,8,.LM90 -.LFBB0	
.LM90:
	subl	$28, %esp
	movl	TrueClass, %eax
	movl	%eax, (%esp)
	movl	$13, 4(%esp)
	movl	$__method_TrueClass_to_s, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,12,.LM91 -.LFBB0	
.LM91:
	subl	$28, %esp
	movl	TrueClass, %eax
	movl	%eax, (%esp)
	movl	$14, 4(%esp)
	movl	$__method_TrueClass_inspect, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,16,.LM92 -.LFBB0	
.LM92:
	subl	$28, %esp
	movl	TrueClass, %eax
	movl	%eax, (%esp)
	movl	$28, 4(%esp)
	movl	$__method_TrueClass___eq, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	# === end class TrueClass ===
	movl	TrueClass, %eax
	.stabn  68,0,22,.LM93 -.LFBB0	
.LM93:
	# callm :TrueClass.:new
	subl	$24, %esp
	movl	TrueClass, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__new(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm TrueClass.new END
	pushl	%eax
	popl	%eax
	movl	%eax, true
	.stabn  162,0,0,0	
	# End include "/home/vagrant/hokstad/lib/core/true.rb"
	.stabn  68,0,66,.LM94 -.LFBB0	
.LM94:
	.stabs  "/home/vagrant/hokstad/lib/core/false.rb",130,0,0,0	
	.stabn  68,0,1,.LM95 -.LFBB0	
.LM95:
	.stabn  68,0,2,.LM96 -.LFBB0	
.LM96:
	# === class FalseClass ===
	# if: [:sexp, [:eq, :FalseClass, 0]]
	movl	FalseClass, %eax
	movl	%eax, %edx
	movl	$0, %eax
	cmpl	%eax, %edx
	sete	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L190_else
	# then: [:assign, :FalseClass, [:sexp, [:call, :__new_class_object, [668, :Object, 668, :Class]]]]
	subl	$32, %esp
	movl	$668, (%esp)
	movl	Object, %eax
	movl	%eax, 4(%esp)
	movl	$668, 8(%esp)
	movl	Class, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	__new_class_object
	addl	$32, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, FalseClass
	# else: nil
.L190_else:
	movl	FalseClass, %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	movl	$1, (%ecx)
	movl	$.L192, %eax
	pushl	%eax
	movl	FalseClass, %eax
	movl	%eax, %edi
	addl	$8, %edi
	popl	%eax
	movl	%eax, (%edi)
	.stabn  68,0,4,.LM97 -.LFBB0	
.LM97:
	subl	$28, %esp
	movl	FalseClass, %eax
	movl	%eax, (%esp)
	movl	$49, 4(%esp)
	movl	$__method_FalseClass___true__Q, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,8,.LM98 -.LFBB0	
.LM98:
	subl	$28, %esp
	movl	FalseClass, %eax
	movl	%eax, (%esp)
	movl	$13, 4(%esp)
	movl	$__method_FalseClass_to_s, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,12,.LM99 -.LFBB0	
.LM99:
	subl	$28, %esp
	movl	FalseClass, %eax
	movl	%eax, (%esp)
	movl	$14, 4(%esp)
	movl	$__method_FalseClass_inspect, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,16,.LM100 -.LFBB0	
.LM100:
	subl	$28, %esp
	movl	FalseClass, %eax
	movl	%eax, (%esp)
	movl	$29, 4(%esp)
	movl	$__method_FalseClass___X, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	# === end class FalseClass ===
	movl	FalseClass, %eax
	.stabn  68,0,23,.LM101 -.LFBB0	
.LM101:
	# callm :FalseClass.:new
	subl	$24, %esp
	movl	FalseClass, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__new(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm FalseClass.new END
	pushl	%eax
	popl	%eax
	movl	%eax, false
	.stabn  162,0,0,0	
	# End include "/home/vagrant/hokstad/lib/core/false.rb"
	.stabn  68,0,67,.LM102 -.LFBB0	
.LM102:
	.stabs  "/home/vagrant/hokstad/lib/core/nil.rb",130,0,0,0	
	.stabn  68,0,1,.LM103 -.LFBB0	
.LM103:
	.stabn  68,0,2,.LM104 -.LFBB0	
.LM104:
	# === class NilClass ===
	# if: [:sexp, [:eq, :NilClass, 0]]
	movl	NilClass, %eax
	movl	%eax, %edx
	movl	$0, %eax
	cmpl	%eax, %edx
	sete	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L197_else
	# then: [:assign, :NilClass, [:sexp, [:call, :__new_class_object, [668, :Object, 668, :Class]]]]
	subl	$32, %esp
	movl	$668, (%esp)
	movl	Object, %eax
	movl	%eax, 4(%esp)
	movl	$668, 8(%esp)
	movl	Class, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	__new_class_object
	addl	$32, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, NilClass
	# else: nil
.L197_else:
	movl	NilClass, %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	movl	$1, (%ecx)
	movl	$.L199, %eax
	pushl	%eax
	movl	NilClass, %eax
	movl	%eax, %edi
	addl	$8, %edi
	popl	%eax
	movl	%eax, (%edi)
	.stabn  68,0,4,.LM105 -.LFBB0	
.LM105:
	subl	$28, %esp
	movl	NilClass, %eax
	movl	%eax, (%esp)
	movl	$49, 4(%esp)
	movl	$__method_NilClass___true__Q, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,8,.LM106 -.LFBB0	
.LM106:
	subl	$28, %esp
	movl	NilClass, %eax
	movl	%eax, (%esp)
	movl	$28, 4(%esp)
	movl	$__method_NilClass___eq, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,12,.LM107 -.LFBB0	
.LM107:
	subl	$28, %esp
	movl	NilClass, %eax
	movl	%eax, (%esp)
	movl	$30, 4(%esp)
	movl	$__method_NilClass_nil__Q, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,16,.LM108 -.LFBB0	
.LM108:
	subl	$28, %esp
	movl	NilClass, %eax
	movl	%eax, (%esp)
	movl	$29, 4(%esp)
	movl	$__method_NilClass___X, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,20,.LM109 -.LFBB0	
.LM109:
	subl	$28, %esp
	movl	NilClass, %eax
	movl	%eax, (%esp)
	movl	$13, 4(%esp)
	movl	$__method_NilClass_to_s, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,24,.LM110 -.LFBB0	
.LM110:
	subl	$28, %esp
	movl	NilClass, %eax
	movl	%eax, (%esp)
	movl	$14, 4(%esp)
	movl	$__method_NilClass_inspect, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	# === end class NilClass ===
	movl	NilClass, %eax
	.stabn  68,0,30,.LM111 -.LFBB0	
.LM111:
	# callm :NilClass.:new
	subl	$24, %esp
	movl	NilClass, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__new(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm NilClass.new END
	pushl	%eax
	popl	%eax
	movl	%eax, nil
	.stabn  162,0,0,0	
	# End include "/home/vagrant/hokstad/lib/core/nil.rb"
	.stabn  68,0,69,.LM112 -.LFBB0	
.LM112:
	.stabs  "/home/vagrant/hokstad/lib/core/class_ivarinit.rb",130,0,0,0	
	.stabn  68,0,1,.LM113 -.LFBB0	
.LM113:
	.stabn  68,0,6,.LM114 -.LFBB0	
.LM114:
	# === class Class ===
	# if: [:sexp, [:eq, :Class, 0]]
	movl	Class, %eax
	movl	%eax, %edx
	movl	$0, %eax
	cmpl	%eax, %edx
	sete	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L206_else
	# then: [:assign, :Class, [:sexp, [:call, :__new_class_object, [668, :Object, 0, :Class]]]]
	subl	$32, %esp
	movl	$668, (%esp)
	movl	Object, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	Class, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	__new_class_object
	addl	$32, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, Class
	# else: nil
.L206_else:
	movl	Class, %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	movl	$4, (%ecx)
	movl	$.L120, %eax
	pushl	%eax
	movl	Class, %eax
	movl	%eax, %edi
	addl	$8, %edi
	popl	%eax
	movl	%eax, (%edi)
	.stabn  68,0,8,.LM115 -.LFBB0	
.LM115:
	subl	$28, %esp
	movl	Class, %eax
	movl	%eax, (%esp)
	movl	$10, 4(%esp)
	movl	$__method_Class_allocate__1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	# === end class Class ===
	movl	Class, %eax
	.stabn  162,0,0,0	
	# End include "/home/vagrant/hokstad/lib/core/class_ivarinit.rb"
	.stabn  68,0,72,.LM116 -.LFBB0	
.LM116:
	.stabs  "/home/vagrant/hokstad/lib/core/range.rb",130,0,0,0	
	.stabn  68,0,1,.LM117 -.LFBB0	
.LM117:
	.stabn  68,0,5,.LM118 -.LFBB0	
.LM118:
	# === class Range ===
	# if: [:sexp, [:eq, :Range, 0]]
	movl	Range, %eax
	movl	%eax, %edx
	movl	$0, %eax
	cmpl	%eax, %edx
	sete	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L209_else
	# then: [:assign, :Range, [:sexp, [:call, :__new_class_object, [668, :Object, 668, :Class]]]]
	subl	$32, %esp
	movl	$668, (%esp)
	movl	Object, %eax
	movl	%eax, 4(%esp)
	movl	$668, 8(%esp)
	movl	Class, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	__new_class_object
	addl	$32, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, Range
	# else: nil
.L209_else:
	movl	Range, %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	movl	$3, (%ecx)
	movl	$.L211, %eax
	pushl	%eax
	movl	Range, %eax
	movl	%eax, %edi
	addl	$8, %edi
	popl	%eax
	movl	%eax, (%edi)
	.stabn  68,0,6,.LM119 -.LFBB0	
.LM119:
	subl	$28, %esp
	movl	Range, %eax
	movl	%eax, (%esp)
	movl	$22, 4(%esp)
	movl	$__method_Range_initialize, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,11,.LM120 -.LFBB0	
.LM120:
	subl	$28, %esp
	movl	Range, %eax
	movl	%eax, (%esp)
	movl	$13, 4(%esp)
	movl	$__method_Range_to_s, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,15,.LM121 -.LFBB0	
.LM121:
	subl	$28, %esp
	movl	Range, %eax
	movl	%eax, (%esp)
	movl	$14, 4(%esp)
	movl	$__method_Range_inspect, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,19,.LM122 -.LFBB0	
.LM122:
	subl	$28, %esp
	movl	Range, %eax
	movl	%eax, (%esp)
	movl	$50, 4(%esp)
	movl	$__method_Range_first, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,23,.LM123 -.LFBB0	
.LM123:
	subl	$28, %esp
	movl	Range, %eax
	movl	%eax, (%esp)
	movl	$51, 4(%esp)
	movl	$__method_Range_last, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,30,.LM124 -.LFBB0	
.LM124:
	subl	$28, %esp
	movl	Range, %eax
	movl	%eax, (%esp)
	movl	$52, 4(%esp)
	movl	$__method_Range_member__Q, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,37,.LM125 -.LFBB0	
.LM125:
	subl	$28, %esp
	movl	Range, %eax
	movl	%eax, (%esp)
	movl	$53, 4(%esp)
	movl	$__method_Range_include__Q, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,41,.LM126 -.LFBB0	
.LM126:
	subl	$28, %esp
	movl	Range, %eax
	movl	%eax, (%esp)
	movl	$27, 4(%esp)
	movl	$__method_Range___eq__3d, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,45,.LM127 -.LFBB0	
.LM127:
	subl	$28, %esp
	movl	Range, %eax
	movl	%eax, (%esp)
	movl	$54, 4(%esp)
	movl	$__method_Range_each, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,53,.LM128 -.LFBB0	
.LM128:
	subl	$28, %esp
	movl	Range, %eax
	movl	%eax, (%esp)
	movl	$48, 4(%esp)
	movl	$__method_Range_to_a, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,61,.LM129 -.LFBB0	
.LM129:
	subl	$28, %esp
	movl	Range, %eax
	movl	%eax, (%esp)
	movl	$55, 4(%esp)
	movl	$__method_Range_to_enum, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	# === end class Range ===
	movl	Range, %eax
	.stabn  162,0,0,0	
	# End include "/home/vagrant/hokstad/lib/core/range.rb"
	.stabn  68,0,73,.LM130 -.LFBB0	
.LM130:
	.stabs  "/home/vagrant/hokstad/lib/core/array.rb",130,0,0,0	
	.stabn  68,0,1,.LM131 -.LFBB0	
.LM131:
	.stabn  68,0,3,.LM132 -.LFBB0	
.LM132:
	# === class Array ===
	# if: [:sexp, [:eq, :Array, 0]]
	movl	Array, %eax
	movl	%eax, %edx
	movl	$0, %eax
	cmpl	%eax, %edx
	sete	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L223_else
	# then: [:assign, :Array, [:sexp, [:call, :__new_class_object, [668, :Object, 668, :Class]]]]
	subl	$32, %esp
	movl	$668, (%esp)
	movl	Object, %eax
	movl	%eax, 4(%esp)
	movl	$668, 8(%esp)
	movl	Class, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	__new_class_object
	addl	$32, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, Array
	# else: nil
.L223_else:
	movl	Array, %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	movl	$4, (%ecx)
	movl	$.L175, %eax
	pushl	%eax
	movl	Array, %eax
	movl	%eax, %edi
	addl	$8, %edi
	popl	%eax
	movl	%eax, (%edi)
	.stabn  68,0,12,.LM133 -.LFBB0	
.LM133:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$22, 4(%esp)
	movl	$__method_Array_initialize, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,29,.LM134 -.LFBB0	
.LM134:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$56, 4(%esp)
	movl	$__method_Array_capacity, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,34,.LM135 -.LFBB0	
.LM135:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$57, 4(%esp)
	movl	$__method_Array___get, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,41,.LM136 -.LFBB0	
.LM136:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$58, 4(%esp)
	movl	$__method_Array_find, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,50,.LM137 -.LFBB0	
.LM137:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$53, 4(%esp)
	movl	$__method_Array_include__Q, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,58,.LM138 -.LFBB0	
.LM138:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$59, 4(%esp)
	movl	$__method_Array_reject, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,69,.LM139 -.LFBB0	
.LM139:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$60, 4(%esp)
	movl	$__method_Array_collect, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,83,.LM140 -.LFBB0	
.LM140:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$61, 4(%esp)
	movl	$__method_Array_detect, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,96,.LM141 -.LFBB0	
.LM141:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$62, 4(%esp)
	movl	$__method_Array_each_with_index, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,128,.LM142 -.LFBB0	
.LM142:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$63, 4(%esp)
	movl	$__method_Array___plus, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,147,.LM143 -.LFBB0	
.LM143:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$64, 4(%esp)
	movl	$__method_Array___lt__lt, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,182,.LM144 -.LFBB0	
.LM144:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$28, 4(%esp)
	movl	$__method_Array___eq, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,200,.LM145 -.LFBB0	
.LM145:
	# === Eigenclass start
	subl	$32, %esp
	movl	$668, (%esp)
	movl	Array, %eax
	movl	%eax, %edx
	movl	(%edx), %eax
	movl	%eax, 4(%esp)
	movl	$668, 8(%esp)
	movl	Array, %eax
	movl	%eax, %ecx
	movl	(%ecx), %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	__new_class_object
	addl	$32, %esp
	pushl	%eax
	movl	Array, %eax
	movl	%eax, %edi
	popl	%eax
	movl	%eax, (%edi)
	subl	$12, %esp
	addl	$3, %ebx
	movl	%eax, -12(%ebp)
	movl	$.L237, %eax
	pushl	%eax
	# [:lvar, 1, :esi]
	movl	-12(%ebp), %esi
	movl	%esi, %edx
	addl	$8, %edx
	popl	%eax
	movl	%eax, (%edx)
	subl	$28, %esp
	movl	%esi, (%esp)
	movl	$65, 4(%esp)
	movl	$__method____NDX, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	# [:lvar, 1, :esi]
	movl	-12(%ebp), %esi
	movl	-12(%ebp), %eax
	addl	$12, %esp
	# === Eigenclass end
	.stabn  68,0,212,.LM146 -.LFBB0	
.LM146:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$66, 4(%esp)
	movl	$__method_Array___offset_to_pos, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,229,.LM147 -.LFBB0	
.LM147:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$67, 4(%esp)
	movl	$__method_Array___range_get, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,263,.LM148 -.LFBB0	
.LM148:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$65, 4(%esp)
	movl	$__method_Array___NDX, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,291,.LM149 -.LFBB0	
.LM149:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$68, 4(%esp)
	movl	$__method_Array___NDX__3d, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,314,.LM150 -.LFBB0	
.LM150:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$69, 4(%esp)
	movl	$__method_Array_abbrev, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,318,.LM151 -.LFBB0	
.LM151:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$70, 4(%esp)
	movl	$__method_Array_slice, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,326,.LM152 -.LFBB0	
.LM152:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$71, 4(%esp)
	movl	$__method_Array_assoc, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,342,.LM153 -.LFBB0	
.LM153:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$72, 4(%esp)
	movl	$__method_Array_at, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,349,.LM154 -.LFBB0	
.LM154:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$73, 4(%esp)
	movl	$__method_Array_clear, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,359,.LM155 -.LFBB0	
.LM155:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$74, 4(%esp)
	movl	$__method_Array_collect__X, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,365,.LM156 -.LFBB0	
.LM156:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$75, 4(%esp)
	movl	$__method_Array_compact, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,371,.LM157 -.LFBB0	
.LM157:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$76, 4(%esp)
	movl	$__method_Array_compact__X, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,376,.LM158 -.LFBB0	
.LM158:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$77, 4(%esp)
	movl	$__method_Array_concat, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,385,.LM159 -.LFBB0	
.LM159:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$78, 4(%esp)
	movl	$__method_Array_dclone, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,393,.LM160 -.LFBB0	
.LM160:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$79, 4(%esp)
	movl	$__method_Array_delete, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,415,.LM161 -.LFBB0	
.LM161:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$80, 4(%esp)
	movl	$__method_Array_delete_at, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,439,.LM162 -.LFBB0	
.LM162:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$81, 4(%esp)
	movl	$__method_Array_delete_if, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,444,.LM163 -.LFBB0	
.LM163:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$40, 4(%esp)
	movl	$__method_Array_dup, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,454,.LM164 -.LFBB0	
.LM164:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$54, 4(%esp)
	movl	$__method_Array_each, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,481,.LM165 -.LFBB0	
.LM165:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$52, 4(%esp)
	movl	$__method_Array_member__Q, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,491,.LM166 -.LFBB0	
.LM166:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$82, 4(%esp)
	movl	$__method_Array_each_index, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,500,.LM167 -.LFBB0	
.LM167:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$83, 4(%esp)
	movl	$__method_Array_empty__Q, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,507,.LM168 -.LFBB0	
.LM168:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$26, 4(%esp)
	movl	$__method_Array_eql__Q, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,529,.LM169 -.LFBB0	
.LM169:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$84, 4(%esp)
	movl	$__method_Array_fetch, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,534,.LM170 -.LFBB0	
.LM170:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$85, 4(%esp)
	movl	$__method_Array_fill, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,541,.LM171 -.LFBB0	
.LM171:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$50, 4(%esp)
	movl	$__method_Array_first, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,568,.LM172 -.LFBB0	
.LM172:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$86, 4(%esp)
	movl	$__method_Array_flatten, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,593,.LM173 -.LFBB0	
.LM173:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$87, 4(%esp)
	movl	$__method_Array_flatten__X, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,599,.LM174 -.LFBB0	
.LM174:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$88, 4(%esp)
	movl	$__method_Array_frozen__Q, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,608,.LM175 -.LFBB0	
.LM175:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$25, 4(%esp)
	movl	$__method_Array_hash, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,620,.LM176 -.LFBB0	
.LM176:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$89, 4(%esp)
	movl	$__method_Array_index, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,642,.LM177 -.LFBB0	
.LM177:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$90, 4(%esp)
	movl	$__method_Array_replace, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,655,.LM178 -.LFBB0	
.LM178:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$91, 4(%esp)
	movl	$__method_Array_insert, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,683,.LM179 -.LFBB0	
.LM179:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$14, 4(%esp)
	movl	$__method_Array_inspect, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,701,.LM180 -.LFBB0	
.LM180:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$92, 4(%esp)
	movl	$__method_Array_join, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,717,.LM181 -.LFBB0	
.LM181:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$51, 4(%esp)
	movl	$__method_Array_last, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,740,.LM182 -.LFBB0	
.LM182:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$93, 4(%esp)
	movl	$__method_Array_length, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,748,.LM183 -.LFBB0	
.LM183:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$74, 4(%esp)
	movl	$__method_Array_collect__X__1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,756,.LM184 -.LFBB0	
.LM184:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$94, 4(%esp)
	movl	$__method_Array_map__X, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,762,.LM185 -.LFBB0	
.LM185:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$95, 4(%esp)
	movl	$__method_Array_nitems, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,767,.LM186 -.LFBB0	
.LM186:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$96, 4(%esp)
	movl	$__method_Array_pack, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,774,.LM187 -.LFBB0	
.LM187:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$97, 4(%esp)
	movl	$__method_Array_pop, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,785,.LM188 -.LFBB0	
.LM188:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$98, 4(%esp)
	movl	$__method_Array_pretty_print, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,793,.LM189 -.LFBB0	
.LM189:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$99, 4(%esp)
	movl	$__method_Array_push, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,798,.LM190 -.LFBB0	
.LM190:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$100, 4(%esp)
	movl	$__method_Array_quote, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,806,.LM191 -.LFBB0	
.LM191:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$101, 4(%esp)
	movl	$__method_Array_rassoc, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,822,.LM192 -.LFBB0	
.LM192:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$102, 4(%esp)
	movl	$__method_Array_reject__X, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,828,.LM193 -.LFBB0	
.LM193:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$103, 4(%esp)
	movl	$__method_Array_reverse, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,834,.LM194 -.LFBB0	
.LM194:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$104, 4(%esp)
	movl	$__method_Array_reverse__X, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,850,.LM195 -.LFBB0	
.LM195:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$105, 4(%esp)
	movl	$__method_Array_reverse_each, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,856,.LM196 -.LFBB0	
.LM196:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$106, 4(%esp)
	movl	$__method_Array_rindex, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,870,.LM197 -.LFBB0	
.LM197:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$107, 4(%esp)
	movl	$__method_Array_shift, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,882,.LM198 -.LFBB0	
.LM198:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$108, 4(%esp)
	movl	$__method_Array_size, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,887,.LM199 -.LFBB0	
.LM199:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$109, 4(%esp)
	movl	$__method_Array_partition, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,912,.LM200 -.LFBB0	
.LM200:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$110, 4(%esp)
	movl	$__method_Array_sort_by, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,931,.LM201 -.LFBB0	
.LM201:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$111, 4(%esp)
	movl	$__method_Array_sort, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,953,.LM202 -.LFBB0	
.LM202:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$112, 4(%esp)
	movl	$__method_Array_sort__X, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,961,.LM203 -.LFBB0	
.LM203:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$48, 4(%esp)
	movl	$__method_Array_to_a__1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,967,.LM204 -.LFBB0	
.LM204:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$113, 4(%esp)
	movl	$__method_Array_to_ary, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,971,.LM205 -.LFBB0	
.LM205:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$114, 4(%esp)
	movl	$__method_Array_to_yaml, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,977,.LM206 -.LFBB0	
.LM206:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$115, 4(%esp)
	movl	$__method_Array_transpose, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,982,.LM207 -.LFBB0	
.LM207:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$116, 4(%esp)
	movl	$__method_Array_uniq, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,995,.LM208 -.LFBB0	
.LM208:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$117, 4(%esp)
	movl	$__method_Array_uniq__X, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,1009,.LM209 -.LFBB0	
.LM209:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$118, 4(%esp)
	movl	$__method_Array_unshift, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,1017,.LM210 -.LFBB0	
.LM210:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$119, 4(%esp)
	movl	$__method_Array_values_at, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,1022,.LM211 -.LFBB0	
.LM211:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$120, 4(%esp)
	movl	$__method_Array_yaml_initialize, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,1032,.LM212 -.LFBB0	
.LM212:
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$121, 4(%esp)
	movl	$__method_Array_zip, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	# === end class Array ===
	movl	Array, %eax
	.stabn  162,0,0,0	
	# End include "/home/vagrant/hokstad/lib/core/array.rb"
	.stabn  68,0,74,.LM213 -.LFBB0	
.LM213:
	.stabs  "/home/vagrant/hokstad/lib/core/string.rb",130,0,0,0	
	.stabn  68,0,1,.LM214 -.LFBB0	
.LM214:
	.stabn  68,0,7,.LM215 -.LFBB0	
.LM215:
	# === class String ===
	# if: [:sexp, [:eq, :String, 0]]
	movl	String, %eax
	movl	%eax, %ecx
	movl	$0, %eax
	cmpl	%eax, %ecx
	sete	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L306_else
	# then: [:assign, :String, [:sexp, [:call, :__new_class_object, [668, :Object, 668, :Class]]]]
	subl	$32, %esp
	movl	$668, (%esp)
	movl	Object, %eax
	movl	%eax, 4(%esp)
	movl	$668, 8(%esp)
	movl	Class, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	__new_class_object
	addl	$32, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, String
	# else: nil
.L306_else:
	movl	String, %eax
	movl	%eax, %edi
	addl	$4, %edi
	movl	$2, (%edi)
	movl	$.L308, %eax
	pushl	%eax
	movl	String, %eax
	movl	%eax, %edx
	addl	$8, %edx
	popl	%eax
	movl	%eax, (%edx)
	.stabn  68,0,18,.LM216 -.LFBB0	
.LM216:
	subl	$28, %esp
	movl	String, %eax
	movl	%eax, (%esp)
	movl	$22, 4(%esp)
	movl	$__method_String_initialize, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,37,.LM217 -.LFBB0	
.LM217:
	subl	$28, %esp
	movl	String, %eax
	movl	%eax, (%esp)
	movl	$14, 4(%esp)
	movl	$__method_String_inspect, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,58,.LM218 -.LFBB0	
.LM218:
	subl	$28, %esp
	movl	String, %eax
	movl	%eax, (%esp)
	movl	$25, 4(%esp)
	movl	$__method_String_hash, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,66,.LM219 -.LFBB0	
.LM219:
	subl	$28, %esp
	movl	String, %eax
	movl	%eax, (%esp)
	movl	$29, 4(%esp)
	movl	$__method_String___X, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,70,.LM220 -.LFBB0	
.LM220:
	subl	$28, %esp
	movl	String, %eax
	movl	%eax, (%esp)
	movl	$30, 4(%esp)
	movl	$__method_String_nil__Q, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,75,.LM221 -.LFBB0	
.LM221:
	subl	$28, %esp
	movl	String, %eax
	movl	%eax, (%esp)
	movl	$65, 4(%esp)
	movl	$__method_String___NDX, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,122,.LM222 -.LFBB0	
.LM222:
	subl	$28, %esp
	movl	String, %eax
	movl	%eax, (%esp)
	movl	$68, 4(%esp)
	movl	$__method_String___NDX__3d, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,127,.LM223 -.LFBB0	
.LM223:
	subl	$28, %esp
	movl	String, %eax
	movl	%eax, (%esp)
	movl	$28, 4(%esp)
	movl	$__method_String___eq, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,134,.LM224 -.LFBB0	
.LM224:
	subl	$28, %esp
	movl	String, %eax
	movl	%eax, (%esp)
	movl	$26, 4(%esp)
	movl	$__method_String_eql__Q, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,138,.LM225 -.LFBB0	
.LM225:
	subl	$28, %esp
	movl	String, %eax
	movl	%eax, (%esp)
	movl	$122, 4(%esp)
	movl	$__method_String___copy_raw, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,146,.LM226 -.LFBB0	
.LM226:
	subl	$28, %esp
	movl	String, %eax
	movl	%eax, (%esp)
	movl	$41, 4(%esp)
	movl	$__method_String___set_raw, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,150,.LM227 -.LFBB0	
.LM227:
	subl	$28, %esp
	movl	String, %eax
	movl	%eax, (%esp)
	movl	$123, 4(%esp)
	movl	$__method_String___get_raw, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,154,.LM228 -.LFBB0	
.LM228:
	subl	$28, %esp
	movl	String, %eax
	movl	%eax, (%esp)
	movl	$83, 4(%esp)
	movl	$__method_String_empty__Q, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,160,.LM229 -.LFBB0	
.LM229:
	subl	$28, %esp
	movl	String, %eax
	movl	%eax, (%esp)
	movl	$124, 4(%esp)
	movl	$__method_String_chr, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,164,.LM230 -.LFBB0	
.LM230:
	subl	$28, %esp
	movl	String, %eax
	movl	%eax, (%esp)
	movl	$125, 4(%esp)
	movl	$__method_String_ord, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,172,.LM231 -.LFBB0	
.LM231:
	subl	$28, %esp
	movl	String, %eax
	movl	%eax, (%esp)
	movl	$126, 4(%esp)
	movl	$__method_String_each_byte, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,191,.LM232 -.LFBB0	
.LM232:
	subl	$28, %esp
	movl	String, %eax
	movl	%eax, (%esp)
	movl	$127, 4(%esp)
	movl	$__method_String___le__gt, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,210,.LM233 -.LFBB0	
.LM233:
	subl	$28, %esp
	movl	String, %eax
	movl	%eax, (%esp)
	movl	$116, 4(%esp)
	movl	$__method_String_uniq, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,213,.LM234 -.LFBB0	
.LM234:
	subl	$28, %esp
	movl	String, %eax
	movl	%eax, (%esp)
	movl	$13, 4(%esp)
	movl	$__method_String_to_s, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,217,.LM235 -.LFBB0	
.LM235:
	subl	$28, %esp
	movl	String, %eax
	movl	%eax, (%esp)
	movl	$128, 4(%esp)
	movl	$__method_String_to_sym, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,222,.LM236 -.LFBB0	
.LM236:
	subl	$28, %esp
	movl	String, %eax
	movl	%eax, (%esp)
	movl	$129, 4(%esp)
	movl	$__method_String_to_i, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,243,.LM237 -.LFBB0	
.LM237:
	subl	$28, %esp
	movl	String, %eax
	movl	%eax, (%esp)
	movl	$130, 4(%esp)
	movl	$__method_String_slice__X, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,273,.LM238 -.LFBB0	
.LM238:
	subl	$28, %esp
	movl	String, %eax
	movl	%eax, (%esp)
	movl	$103, 4(%esp)
	movl	$__method_String_reverse, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,286,.LM239 -.LFBB0	
.LM239:
	subl	$28, %esp
	movl	String, %eax
	movl	%eax, (%esp)
	movl	$93, 4(%esp)
	movl	$__method_String_length, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,293,.LM240 -.LFBB0	
.LM240:
	subl	$28, %esp
	movl	String, %eax
	movl	%eax, (%esp)
	movl	$108, 4(%esp)
	movl	$__method_String_size, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,297,.LM241 -.LFBB0	
.LM241:
	subl	$28, %esp
	movl	String, %eax
	movl	%eax, (%esp)
	movl	$131, 4(%esp)
	movl	$__method_String_count, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,311,.LM242 -.LFBB0	
.LM242:
	subl	$28, %esp
	movl	String, %eax
	movl	%eax, (%esp)
	movl	$77, 4(%esp)
	movl	$__method_String_concat, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,331,.LM243 -.LFBB0	
.LM243:
	subl	$28, %esp
	movl	String, %eax
	movl	%eax, (%esp)
	movl	$64, 4(%esp)
	movl	$__method_String___lt__lt, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,335,.LM244 -.LFBB0	
.LM244:
	subl	$28, %esp
	movl	String, %eax
	movl	%eax, (%esp)
	movl	$40, 4(%esp)
	movl	$__method_String_dup, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,340,.LM245 -.LFBB0	
.LM245:
	subl	$28, %esp
	movl	String, %eax
	movl	%eax, (%esp)
	movl	$63, 4(%esp)
	movl	$__method_String___plus, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,345,.LM246 -.LFBB0	
.LM246:
	subl	$28, %esp
	movl	String, %eax
	movl	%eax, (%esp)
	movl	$132, 4(%esp)
	movl	$__method_String___mul, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,354,.LM247 -.LFBB0	
.LM247:
	subl	$28, %esp
	movl	String, %eax
	movl	%eax, (%esp)
	movl	$106, 4(%esp)
	movl	$__method_String_rindex, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,369,.LM248 -.LFBB0	
.LM248:
	subl	$28, %esp
	movl	String, %eax
	movl	%eax, (%esp)
	movl	$133, 4(%esp)
	movl	$__method_String_gsub, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,390,.LM249 -.LFBB0	
.LM249:
	subl	$28, %esp
	movl	String, %eax
	movl	%eax, (%esp)
	movl	$134, 4(%esp)
	movl	$__method_String_split, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	# === end class String ===
	movl	String, %eax
	.stabn  68,0,425,.LM250 -.LFBB0	
.LM250:
	movl	$__get_string, %eax
	.stabn  162,0,0,0	
	# End include "/home/vagrant/hokstad/lib/core/string.rb"
	.stabn  68,0,75,.LM251 -.LFBB0	
.LM251:
	.stabs  "/home/vagrant/hokstad/lib/core/hash.rb",130,0,0,0	
	.stabn  68,0,1,.LM252 -.LFBB0	
.LM252:
	.stabn  68,0,2,.LM253 -.LFBB0	
.LM253:
	# === class Hash ===
	# if: [:sexp, [:eq, :Hash, 0]]
	movl	Hash, %eax
	movl	%eax, %ecx
	movl	$0, %eax
	cmpl	%eax, %ecx
	sete	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L344_else
	# then: [:assign, :Hash, [:sexp, [:call, :__new_class_object, [668, :Object, 668, :Class]]]]
	subl	$32, %esp
	movl	$668, (%esp)
	movl	Object, %eax
	movl	%eax, 4(%esp)
	movl	$668, 8(%esp)
	movl	Class, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	__new_class_object
	addl	$32, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, Hash
	# else: nil
.L344_else:
	movl	Hash, %eax
	movl	%eax, %edi
	addl	$4, %edi
	movl	$7, (%edi)
	movl	$.L346, %eax
	pushl	%eax
	movl	Hash, %eax
	movl	%eax, %edx
	addl	$8, %edx
	popl	%eax
	movl	%eax, (%edx)
	.stabn  68,0,4,.LM254 -.LFBB0	
.LM254:
	# === class Hash__Deleted ===
	# if: [:sexp, [:eq, :Hash__Deleted, 0]]
	movl	Hash__Deleted, %eax
	movl	%eax, %ecx
	movl	$0, %eax
	cmpl	%eax, %ecx
	sete	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L347_else
	# then: [:assign, :Hash__Deleted, [:sexp, [:call, :__new_class_object, [668, :Object, 668, :Class]]]]
	subl	$32, %esp
	movl	$668, (%esp)
	movl	Object, %eax
	movl	%eax, 4(%esp)
	movl	$668, 8(%esp)
	movl	Class, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	__new_class_object
	addl	$32, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, Hash__Deleted
	# else: nil
.L347_else:
	movl	Hash__Deleted, %eax
	movl	%eax, %edi
	addl	$4, %edi
	movl	$1, (%edi)
	movl	$.L349, %eax
	pushl	%eax
	movl	Hash__Deleted, %eax
	movl	%eax, %edx
	addl	$8, %edx
	popl	%eax
	movl	%eax, (%edx)
	.stabn  68,0,5,.LM255 -.LFBB0	
.LM255:
	# === Eigenclass start
	subl	$32, %esp
	movl	$668, (%esp)
	movl	Hash__Deleted, %eax
	movl	%eax, %ecx
	movl	(%ecx), %eax
	movl	%eax, 4(%esp)
	movl	$668, 8(%esp)
	movl	Hash__Deleted, %eax
	movl	%eax, %edi
	movl	(%edi), %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	__new_class_object
	addl	$32, %esp
	pushl	%eax
	movl	Hash__Deleted, %eax
	movl	%eax, %edx
	popl	%eax
	movl	%eax, (%edx)
	subl	$12, %esp
	addl	$3, %ebx
	movl	%eax, -12(%ebp)
	movl	$.L350, %eax
	pushl	%eax
	# [:lvar, 1, :esi]
	movl	-12(%ebp), %esi
	movl	%esi, %ecx
	addl	$8, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	subl	$28, %esp
	movl	%esi, (%esp)
	movl	$26, 4(%esp)
	movl	$__method__eql__Q, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	# [:lvar, 1, :esi]
	movl	-12(%ebp), %esi
	movl	-12(%ebp), %eax
	addl	$12, %esp
	# === Eigenclass end
	# === end class Hash__Deleted ===
	movl	Hash__Deleted, %eax
	.stabn  68,0,10,.LM256 -.LFBB0	
.LM256:
	subl	$28, %esp
	movl	Hash, %eax
	movl	%eax, (%esp)
	movl	$22, 4(%esp)
	movl	$__method_Hash_initialize, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,22,.LM257 -.LFBB0	
.LM257:
	# === Eigenclass start
	subl	$32, %esp
	movl	$668, (%esp)
	movl	Hash, %eax
	movl	%eax, %edi
	movl	(%edi), %eax
	movl	%eax, 4(%esp)
	movl	$668, 8(%esp)
	movl	Hash, %eax
	movl	%eax, %edx
	movl	(%edx), %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	__new_class_object
	addl	$32, %esp
	pushl	%eax
	movl	Hash, %eax
	movl	%eax, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	subl	$12, %esp
	addl	$3, %ebx
	movl	%eax, -12(%ebp)
	movl	$.L353, %eax
	pushl	%eax
	# [:lvar, 1, :esi]
	movl	-12(%ebp), %esi
	movl	%esi, %edi
	addl	$8, %edi
	popl	%eax
	movl	%eax, (%edi)
	subl	$28, %esp
	movl	%esi, (%esp)
	movl	$65, 4(%esp)
	movl	$__method____NDX__1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	# [:lvar, 1, :esi]
	movl	-12(%ebp), %esi
	movl	-12(%ebp), %eax
	addl	$12, %esp
	# === Eigenclass end
	.stabn  68,0,26,.LM258 -.LFBB0	
.LM258:
	subl	$28, %esp
	movl	Hash, %eax
	movl	%eax, (%esp)
	movl	$135, 4(%esp)
	movl	$__method_Hash__alloc_data, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,32,.LM259 -.LFBB0	
.LM259:
	subl	$28, %esp
	movl	Hash, %eax
	movl	%eax, (%esp)
	movl	$136, 4(%esp)
	movl	$__method_Hash__bulkinsert, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,47,.LM260 -.LFBB0	
.LM260:
	subl	$28, %esp
	movl	Hash, %eax
	movl	%eax, (%esp)
	movl	$137, 4(%esp)
	movl	$__method_Hash__grow, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,68,.LM261 -.LFBB0	
.LM261:
	subl	$28, %esp
	movl	Hash, %eax
	movl	%eax, (%esp)
	movl	$138, 4(%esp)
	movl	$__method_Hash__find_slot, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,83,.LM262 -.LFBB0	
.LM262:
	subl	$28, %esp
	movl	Hash, %eax
	movl	%eax, (%esp)
	movl	$52, 4(%esp)
	movl	$__method_Hash_member__Q, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,88,.LM263 -.LFBB0	
.LM263:
	subl	$28, %esp
	movl	Hash, %eax
	movl	%eax, (%esp)
	movl	$53, 4(%esp)
	movl	$__method_Hash_include__Q, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,92,.LM264 -.LFBB0	
.LM264:
	subl	$28, %esp
	movl	Hash, %eax
	movl	%eax, (%esp)
	movl	$83, 4(%esp)
	movl	$__method_Hash_empty__Q, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,96,.LM265 -.LFBB0	
.LM265:
	subl	$28, %esp
	movl	Hash, %eax
	movl	%eax, (%esp)
	movl	$65, 4(%esp)
	movl	$__method_Hash___NDX, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,101,.LM266 -.LFBB0	
.LM266:
	subl	$28, %esp
	movl	Hash, %eax
	movl	%eax, (%esp)
	movl	$139, 4(%esp)
	movl	$__method_Hash_capacity_too_low, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,108,.LM267 -.LFBB0	
.LM267:
	subl	$28, %esp
	movl	Hash, %eax
	movl	%eax, (%esp)
	movl	$68, 4(%esp)
	movl	$__method_Hash___NDX__3d, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,139,.LM268 -.LFBB0	
.LM268:
	subl	$28, %esp
	movl	Hash, %eax
	movl	%eax, (%esp)
	movl	$140, 4(%esp)
	movl	$__method_Hash___delete_first, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,153,.LM269 -.LFBB0	
.LM269:
	subl	$28, %esp
	movl	Hash, %eax
	movl	%eax, (%esp)
	movl	$107, 4(%esp)
	movl	$__method_Hash_shift, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,164,.LM270 -.LFBB0	
.LM270:
	subl	$28, %esp
	movl	Hash, %eax
	movl	%eax, (%esp)
	movl	$93, 4(%esp)
	movl	$__method_Hash_length, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,168,.LM271 -.LFBB0	
.LM271:
	subl	$28, %esp
	movl	Hash, %eax
	movl	%eax, (%esp)
	movl	$108, 4(%esp)
	movl	$__method_Hash_size, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,172,.LM272 -.LFBB0	
.LM272:
	subl	$28, %esp
	movl	Hash, %eax
	movl	%eax, (%esp)
	movl	$48, 4(%esp)
	movl	$__method_Hash_to_a, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,180,.LM273 -.LFBB0	
.LM273:
	subl	$28, %esp
	movl	Hash, %eax
	movl	%eax, (%esp)
	movl	$54, 4(%esp)
	movl	$__method_Hash_each, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,209,.LM274 -.LFBB0	
.LM274:
	subl	$28, %esp
	movl	Hash, %eax
	movl	%eax, (%esp)
	movl	$79, 4(%esp)
	movl	$__method_Hash_delete, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	# === end class Hash ===
	movl	Hash, %eax
	.stabn  162,0,0,0	
	# End include "/home/vagrant/hokstad/lib/core/hash.rb"
	.stabn  68,0,76,.LM275 -.LFBB0	
.LM275:
	.stabs  "/home/vagrant/hokstad/lib/core/io.rb",130,0,0,0	
	.stabn  68,0,1,.LM276 -.LFBB0	
.LM276:
	.stabn  68,0,8,.LM277 -.LFBB0	
.LM277:
	# === class IO ===
	# if: [:sexp, [:eq, :IO, 0]]
	movl	IO, %eax
	movl	%eax, %edx
	movl	$0, %eax
	cmpl	%eax, %edx
	sete	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L372_else
	# then: [:assign, :IO, [:sexp, [:call, :__new_class_object, [668, :Object, 668, :Class]]]]
	subl	$32, %esp
	movl	$668, (%esp)
	movl	Object, %eax
	movl	%eax, 4(%esp)
	movl	$668, 8(%esp)
	movl	Class, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	__new_class_object
	addl	$32, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, IO
	# else: nil
.L372_else:
	movl	IO, %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	movl	$3, (%ecx)
	movl	$.L374, %eax
	pushl	%eax
	movl	IO, %eax
	movl	%eax, %edi
	addl	$8, %edi
	popl	%eax
	movl	%eax, (%edi)
	.stabn  68,0,9,.LM278 -.LFBB0	
.LM278:
	subl	$28, %esp
	movl	IO, %eax
	movl	%eax, (%esp)
	movl	$22, 4(%esp)
	movl	$__method_IO_initialize, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,16,.LM279 -.LFBB0	
.LM279:
	subl	$28, %esp
	movl	IO, %eax
	movl	%eax, (%esp)
	movl	$129, 4(%esp)
	movl	$__method_IO_to_i, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,20,.LM280 -.LFBB0	
.LM280:
	subl	$28, %esp
	movl	IO, %eax
	movl	%eax, (%esp)
	movl	$141, 4(%esp)
	movl	$__method_IO_getc, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,32,.LM281 -.LFBB0	
.LM281:
	subl	$28, %esp
	movl	IO, %eax
	movl	%eax, (%esp)
	movl	$142, 4(%esp)
	movl	$__method_IO_file__Q, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	# === end class IO ===
	movl	IO, %eax
	.stabn  162,0,0,0	
	# End include "/home/vagrant/hokstad/lib/core/io.rb"
	.stabn  68,0,77,.LM282 -.LFBB0	
.LM282:
	.stabs  "/home/vagrant/hokstad/lib/core/file.rb",130,0,0,0	
	.stabn  68,0,1,.LM283 -.LFBB0	
.LM283:
	.stabn  68,0,2,.LM284 -.LFBB0	
.LM284:
	# === class File ===
	# if: [:sexp, [:eq, :File, 0]]
	movl	File, %eax
	movl	%eax, %edx
	movl	$0, %eax
	cmpl	%eax, %edx
	sete	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L379_else
	# then: [:assign, :File, [:sexp, [:call, :__new_class_object, [668, :IO, 668, [:index, :IO, 0]]]]]
	subl	$32, %esp
	movl	$668, (%esp)
	movl	IO, %eax
	movl	%eax, 4(%esp)
	movl	$668, 8(%esp)
	movl	IO, %eax
	movl	%eax, %ecx
	movl	(%ecx), %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	__new_class_object
	addl	$32, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, File
	# else: nil
.L379_else:
	movl	File, %eax
	movl	%eax, %edi
	addl	$4, %edi
	movl	$4, (%edi)
	movl	$.L381, %eax
	pushl	%eax
	movl	File, %eax
	movl	%eax, %edx
	addl	$8, %edx
	popl	%eax
	movl	%eax, (%edx)
	.stabn  68,0,4,.LM285 -.LFBB0	
.LM285:
	subl	$20, %esp
	movl	$.L24, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, File__SEPARATOR
	.stabn  68,0,5,.LM286 -.LFBB0	
.LM286:
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, File__ALT_SEPARATOR
	.stabn  68,0,7,.LM287 -.LFBB0	
.LM287:
	# === Eigenclass start
	subl	$32, %esp
	movl	$668, (%esp)
	movl	File, %eax
	movl	%eax, %ecx
	movl	(%ecx), %eax
	movl	%eax, 4(%esp)
	movl	$668, 8(%esp)
	movl	File, %eax
	movl	%eax, %edi
	movl	(%edi), %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	__new_class_object
	addl	$32, %esp
	pushl	%eax
	movl	File, %eax
	movl	%eax, %edx
	popl	%eax
	movl	%eax, (%edx)
	subl	$12, %esp
	addl	$3, %ebx
	movl	%eax, -12(%ebp)
	movl	$.L382, %eax
	pushl	%eax
	# [:lvar, 1, :esi]
	movl	-12(%ebp), %esi
	movl	%esi, %ecx
	addl	$8, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	subl	$28, %esp
	movl	%esi, (%esp)
	movl	$142, 4(%esp)
	movl	$__method__file__Q, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	# [:lvar, 1, :esi]
	movl	-12(%ebp), %esi
	movl	-12(%ebp), %eax
	addl	$12, %esp
	# === Eigenclass end
	.stabn  68,0,13,.LM288 -.LFBB0	
.LM288:
	subl	$28, %esp
	movl	File, %eax
	movl	%eax, (%esp)
	movl	$143, 4(%esp)
	movl	$__method_File_path, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,17,.LM289 -.LFBB0	
.LM289:
	subl	$28, %esp
	movl	File, %eax
	movl	%eax, (%esp)
	movl	$22, 4(%esp)
	movl	$__method_File_initialize, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,32,.LM290 -.LFBB0	
.LM290:
	# === Eigenclass start
	subl	$32, %esp
	movl	$668, (%esp)
	movl	File, %eax
	movl	%eax, %edi
	movl	(%edi), %eax
	movl	%eax, 4(%esp)
	movl	$668, 8(%esp)
	movl	File, %eax
	movl	%eax, %edx
	movl	(%edx), %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	__new_class_object
	addl	$32, %esp
	pushl	%eax
	movl	File, %eax
	movl	%eax, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	subl	$12, %esp
	addl	$3, %ebx
	movl	%eax, -12(%ebp)
	movl	$.L382, %eax
	pushl	%eax
	# [:lvar, 1, :esi]
	movl	-12(%ebp), %esi
	movl	%esi, %edi
	addl	$8, %edi
	popl	%eax
	movl	%eax, (%edi)
	subl	$28, %esp
	movl	%esi, (%esp)
	movl	$144, 4(%esp)
	movl	$__method__open, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	# [:lvar, 1, :esi]
	movl	-12(%ebp), %esi
	movl	-12(%ebp), %eax
	addl	$12, %esp
	# === Eigenclass end
	.stabn  68,0,36,.LM291 -.LFBB0	
.LM291:
	# === Eigenclass start
	subl	$32, %esp
	movl	$668, (%esp)
	movl	File, %eax
	movl	%eax, %edx
	movl	(%edx), %eax
	movl	%eax, 4(%esp)
	movl	$668, 8(%esp)
	movl	File, %eax
	movl	%eax, %ecx
	movl	(%ecx), %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	__new_class_object
	addl	$32, %esp
	pushl	%eax
	movl	File, %eax
	movl	%eax, %edi
	popl	%eax
	movl	%eax, (%edi)
	subl	$12, %esp
	addl	$3, %ebx
	movl	%eax, -12(%ebp)
	movl	$.L382, %eax
	pushl	%eax
	# [:lvar, 1, :esi]
	movl	-12(%ebp), %esi
	movl	%esi, %edx
	addl	$8, %edx
	popl	%eax
	movl	%eax, (%edx)
	subl	$28, %esp
	movl	%esi, (%esp)
	movl	$145, 4(%esp)
	movl	$__method__exists__Q, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	# [:lvar, 1, :esi]
	movl	-12(%ebp), %esi
	movl	-12(%ebp), %eax
	addl	$12, %esp
	# === Eigenclass end
	.stabn  68,0,44,.LM292 -.LFBB0	
.LM292:
	# === Eigenclass start
	subl	$32, %esp
	movl	$668, (%esp)
	movl	File, %eax
	movl	%eax, %ecx
	movl	(%ecx), %eax
	movl	%eax, 4(%esp)
	movl	$668, 8(%esp)
	movl	File, %eax
	movl	%eax, %edi
	movl	(%edi), %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	__new_class_object
	addl	$32, %esp
	pushl	%eax
	movl	File, %eax
	movl	%eax, %edx
	popl	%eax
	movl	%eax, (%edx)
	subl	$12, %esp
	addl	$3, %ebx
	movl	%eax, -12(%ebp)
	movl	$.L382, %eax
	pushl	%eax
	# [:lvar, 1, :esi]
	movl	-12(%ebp), %esi
	movl	%esi, %ecx
	addl	$8, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	subl	$28, %esp
	movl	%esi, (%esp)
	movl	$146, 4(%esp)
	movl	$__method__basename, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	# [:lvar, 1, :esi]
	movl	-12(%ebp), %esi
	movl	-12(%ebp), %eax
	addl	$12, %esp
	# === Eigenclass end
	.stabn  68,0,57,.LM293 -.LFBB0	
.LM293:
	# === Eigenclass start
	subl	$32, %esp
	movl	$668, (%esp)
	movl	File, %eax
	movl	%eax, %edi
	movl	(%edi), %eax
	movl	%eax, 4(%esp)
	movl	$668, 8(%esp)
	movl	File, %eax
	movl	%eax, %edx
	movl	(%edx), %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	__new_class_object
	addl	$32, %esp
	pushl	%eax
	movl	File, %eax
	movl	%eax, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	subl	$12, %esp
	addl	$3, %ebx
	movl	%eax, -12(%ebp)
	movl	$.L382, %eax
	pushl	%eax
	# [:lvar, 1, :esi]
	movl	-12(%ebp), %esi
	movl	%esi, %edi
	addl	$8, %edi
	popl	%eax
	movl	%eax, (%edi)
	subl	$28, %esp
	movl	%esi, (%esp)
	movl	$147, 4(%esp)
	movl	$__method__dirname, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	# [:lvar, 1, :esi]
	movl	-12(%ebp), %esi
	movl	-12(%ebp), %eax
	addl	$12, %esp
	# === Eigenclass end
	.stabn  68,0,72,.LM294 -.LFBB0	
.LM294:
	# === Eigenclass start
	subl	$32, %esp
	movl	$668, (%esp)
	movl	File, %eax
	movl	%eax, %edx
	movl	(%edx), %eax
	movl	%eax, 4(%esp)
	movl	$668, 8(%esp)
	movl	File, %eax
	movl	%eax, %ecx
	movl	(%ecx), %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	__new_class_object
	addl	$32, %esp
	pushl	%eax
	movl	File, %eax
	movl	%eax, %edi
	popl	%eax
	movl	%eax, (%edi)
	subl	$12, %esp
	addl	$3, %ebx
	movl	%eax, -12(%ebp)
	movl	$.L382, %eax
	pushl	%eax
	# [:lvar, 1, :esi]
	movl	-12(%ebp), %esi
	movl	%esi, %edx
	addl	$8, %edx
	popl	%eax
	movl	%eax, (%edx)
	subl	$28, %esp
	movl	%esi, (%esp)
	movl	$148, 4(%esp)
	movl	$__method__expand_path, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	# [:lvar, 1, :esi]
	movl	-12(%ebp), %esi
	movl	-12(%ebp), %eax
	addl	$12, %esp
	# === Eigenclass end
	# === end class File ===
	movl	File, %eax
	.stabn  162,0,0,0	
	# End include "/home/vagrant/hokstad/lib/core/file.rb"
	.stabn  68,0,78,.LM295 -.LFBB0	
.LM295:
	.stabs  "/home/vagrant/hokstad/lib/core/dir.rb",130,0,0,0	
	.stabn  68,0,1,.LM296 -.LFBB0	
.LM296:
	.stabn  68,0,2,.LM297 -.LFBB0	
.LM297:
	# === class Dir ===
	# if: [:sexp, [:eq, :Dir, 0]]
	movl	Dir, %eax
	movl	%eax, %ecx
	movl	$0, %eax
	cmpl	%eax, %ecx
	sete	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L391_else
	# then: [:assign, :Dir, [:sexp, [:call, :__new_class_object, [668, :Object, 668, :Class]]]]
	subl	$32, %esp
	movl	$668, (%esp)
	movl	Object, %eax
	movl	%eax, 4(%esp)
	movl	$668, 8(%esp)
	movl	Class, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	__new_class_object
	addl	$32, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, Dir
	# else: nil
.L391_else:
	movl	Dir, %eax
	movl	%eax, %edi
	addl	$4, %edi
	movl	$1, (%edi)
	movl	$.L393, %eax
	pushl	%eax
	movl	Dir, %eax
	movl	%eax, %edx
	addl	$8, %edx
	popl	%eax
	movl	%eax, (%edx)
	.stabn  68,0,3,.LM298 -.LFBB0	
.LM298:
	# === Eigenclass start
	subl	$32, %esp
	movl	$668, (%esp)
	movl	Dir, %eax
	movl	%eax, %ecx
	movl	(%ecx), %eax
	movl	%eax, 4(%esp)
	movl	$668, 8(%esp)
	movl	Dir, %eax
	movl	%eax, %edi
	movl	(%edi), %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	__new_class_object
	addl	$32, %esp
	pushl	%eax
	movl	Dir, %eax
	movl	%eax, %edx
	popl	%eax
	movl	%eax, (%edx)
	subl	$12, %esp
	addl	$3, %ebx
	movl	%eax, -12(%ebp)
	movl	$.L394, %eax
	pushl	%eax
	# [:lvar, 1, :esi]
	movl	-12(%ebp), %esi
	movl	%esi, %ecx
	addl	$8, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	subl	$28, %esp
	movl	%esi, (%esp)
	movl	$149, 4(%esp)
	movl	$__method__pwd, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	# [:lvar, 1, :esi]
	movl	-12(%ebp), %esi
	movl	-12(%ebp), %eax
	addl	$12, %esp
	# === Eigenclass end
	# === end class Dir ===
	movl	Dir, %eax
	.stabn  162,0,0,0	
	# End include "/home/vagrant/hokstad/lib/core/dir.rb"
	.stabn  68,0,79,.LM299 -.LFBB0	
.LM299:
	.stabs  "/home/vagrant/hokstad/lib/core/numeric.rb",130,0,0,0	
	.stabn  68,0,1,.LM300 -.LFBB0	
.LM300:
	.stabn  68,0,2,.LM301 -.LFBB0	
.LM301:
	# === class Numeric ===
	# if: [:sexp, [:eq, :Numeric, 0]]
	movl	Numeric, %eax
	movl	%eax, %edi
	movl	$0, %eax
	cmpl	%eax, %edi
	sete	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L396_else
	# then: [:assign, :Numeric, [:sexp, [:call, :__new_class_object, [668, :Object, 668, :Class]]]]
	subl	$32, %esp
	movl	$668, (%esp)
	movl	Object, %eax
	movl	%eax, 4(%esp)
	movl	$668, 8(%esp)
	movl	Class, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	__new_class_object
	addl	$32, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, Numeric
	# else: nil
.L396_else:
	movl	Numeric, %eax
	movl	%eax, %edx
	addl	$4, %edx
	movl	$1, (%edx)
	movl	$.L398, %eax
	pushl	%eax
	movl	Numeric, %eax
	movl	%eax, %ecx
	addl	$8, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	movl	nil, %eax
	# === end class Numeric ===
	movl	Numeric, %eax
	.stabn  162,0,0,0	
	# End include "/home/vagrant/hokstad/lib/core/numeric.rb"
	.stabn  68,0,80,.LM302 -.LFBB0	
.LM302:
	.stabs  "/home/vagrant/hokstad/lib/core/integer.rb",130,0,0,0	
	.stabn  68,0,1,.LM303 -.LFBB0	
.LM303:
	.stabn  68,0,2,.LM304 -.LFBB0	
.LM304:
	# === class Integer ===
	# if: [:sexp, [:eq, :Integer, 0]]
	movl	Integer, %eax
	movl	%eax, %edi
	movl	$0, %eax
	cmpl	%eax, %edi
	sete	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L399_else
	# then: [:assign, :Integer, [:sexp, [:call, :__new_class_object, [668, :Numeric, 668, [:index, :Numeric, 0]]]]]
	subl	$32, %esp
	movl	$668, (%esp)
	movl	Numeric, %eax
	movl	%eax, 4(%esp)
	movl	$668, 8(%esp)
	movl	Numeric, %eax
	movl	%eax, %edx
	movl	(%edx), %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	__new_class_object
	addl	$32, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, Integer
	# else: nil
.L399_else:
	movl	Integer, %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	movl	$1, (%ecx)
	movl	$.L401, %eax
	pushl	%eax
	movl	Integer, %eax
	movl	%eax, %edi
	addl	$8, %edi
	popl	%eax
	movl	%eax, (%edi)
	movl	nil, %eax
	# === end class Integer ===
	movl	Integer, %eax
	.stabn  162,0,0,0	
	# End include "/home/vagrant/hokstad/lib/core/integer.rb"
	.stabn  68,0,81,.LM305 -.LFBB0	
.LM305:
	.stabs  "/home/vagrant/hokstad/lib/core/fixnum.rb",130,0,0,0	
	.stabn  68,0,1,.LM306 -.LFBB0	
.LM306:
	# === class Fixnum ===
	# if: [:sexp, [:eq, :Fixnum, 0]]
	movl	Fixnum, %eax
	movl	%eax, %edx
	movl	$0, %eax
	cmpl	%eax, %edx
	sete	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L402_else
	# then: [:assign, :Fixnum, [:sexp, [:call, :__new_class_object, [668, :Integer, 668, [:index, :Integer, 0]]]]]
	subl	$32, %esp
	movl	$668, (%esp)
	movl	Integer, %eax
	movl	%eax, 4(%esp)
	movl	$668, 8(%esp)
	movl	Integer, %eax
	movl	%eax, %ecx
	movl	(%ecx), %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	__new_class_object
	addl	$32, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, Fixnum
	# else: nil
.L402_else:
	movl	Fixnum, %eax
	movl	%eax, %edi
	addl	$4, %edi
	movl	$2, (%edi)
	movl	$.L404, %eax
	pushl	%eax
	movl	Fixnum, %eax
	movl	%eax, %edx
	addl	$8, %edx
	popl	%eax
	movl	%eax, (%edx)
	.stabn  68,0,3,.LM307 -.LFBB0	
.LM307:
	subl	$28, %esp
	movl	Fixnum, %eax
	movl	%eax, (%esp)
	movl	$22, 4(%esp)
	movl	$__method_Fixnum_initialize, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,10,.LM308 -.LFBB0	
.LM308:
	# === Eigenclass start
	subl	$32, %esp
	movl	$668, (%esp)
	movl	Fixnum, %eax
	movl	%eax, %ecx
	movl	(%ecx), %eax
	movl	%eax, 4(%esp)
	movl	$668, 8(%esp)
	movl	Fixnum, %eax
	movl	%eax, %edi
	movl	(%edi), %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	__new_class_object
	addl	$32, %esp
	pushl	%eax
	movl	Fixnum, %eax
	movl	%eax, %edx
	popl	%eax
	movl	%eax, (%edx)
	subl	$12, %esp
	addl	$3, %ebx
	movl	%eax, -12(%ebp)
	movl	$.L406, %eax
	pushl	%eax
	# [:lvar, 1, :esi]
	movl	-12(%ebp), %esi
	movl	%esi, %ecx
	addl	$8, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	subl	$28, %esp
	movl	%esi, (%esp)
	movl	$10, 4(%esp)
	movl	$__method__allocate, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	# [:lvar, 1, :esi]
	movl	-12(%ebp), %esi
	movl	-12(%ebp), %eax
	addl	$12, %esp
	# === Eigenclass end
	.stabn  68,0,16,.LM309 -.LFBB0	
.LM309:
	subl	$28, %esp
	movl	Fixnum, %eax
	movl	%eax, (%esp)
	movl	$150, 4(%esp)
	movl	$__method_Fixnum___25, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,24,.LM310 -.LFBB0	
.LM310:
	subl	$28, %esp
	movl	Fixnum, %eax
	movl	%eax, (%esp)
	movl	$41, 4(%esp)
	movl	$__method_Fixnum___set_raw, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,28,.LM311 -.LFBB0	
.LM311:
	subl	$28, %esp
	movl	Fixnum, %eax
	movl	%eax, (%esp)
	movl	$123, 4(%esp)
	movl	$__method_Fixnum___get_raw, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,32,.LM312 -.LFBB0	
.LM312:
	subl	$28, %esp
	movl	Fixnum, %eax
	movl	%eax, (%esp)
	movl	$129, 4(%esp)
	movl	$__method_Fixnum_to_i, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,38,.LM313 -.LFBB0	
.LM313:
	subl	$28, %esp
	movl	Fixnum, %eax
	movl	%eax, (%esp)
	movl	$65, 4(%esp)
	movl	$__method_Fixnum___NDX, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,42,.LM314 -.LFBB0	
.LM314:
	subl	$28, %esp
	movl	Fixnum, %eax
	movl	%eax, (%esp)
	movl	$13, 4(%esp)
	movl	$__method_Fixnum_to_s, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,69,.LM315 -.LFBB0	
.LM315:
	subl	$28, %esp
	movl	Fixnum, %eax
	movl	%eax, (%esp)
	movl	$25, 4(%esp)
	movl	$__method_Fixnum_hash, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,73,.LM316 -.LFBB0	
.LM316:
	subl	$28, %esp
	movl	Fixnum, %eax
	movl	%eax, (%esp)
	movl	$14, 4(%esp)
	movl	$__method_Fixnum_inspect, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,77,.LM317 -.LFBB0	
.LM317:
	subl	$28, %esp
	movl	Fixnum, %eax
	movl	%eax, (%esp)
	movl	$124, 4(%esp)
	movl	$__method_Fixnum_chr, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,85,.LM318 -.LFBB0	
.LM318:
	subl	$28, %esp
	movl	Fixnum, %eax
	movl	%eax, (%esp)
	movl	$63, 4(%esp)
	movl	$__method_Fixnum___plus, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,89,.LM319 -.LFBB0	
.LM319:
	subl	$28, %esp
	movl	Fixnum, %eax
	movl	%eax, (%esp)
	movl	$151, 4(%esp)
	movl	$__method_Fixnum___minus, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,93,.LM320 -.LFBB0	
.LM320:
	subl	$28, %esp
	movl	Fixnum, %eax
	movl	%eax, (%esp)
	movl	$152, 4(%esp)
	movl	$__method_Fixnum___le, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,97,.LM321 -.LFBB0	
.LM321:
	subl	$28, %esp
	movl	Fixnum, %eax
	movl	%eax, (%esp)
	movl	$28, 4(%esp)
	movl	$__method_Fixnum___eq, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,106,.LM322 -.LFBB0	
.LM322:
	subl	$28, %esp
	movl	Fixnum, %eax
	movl	%eax, (%esp)
	movl	$29, 4(%esp)
	movl	$__method_Fixnum___X, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,110,.LM323 -.LFBB0	
.LM323:
	subl	$28, %esp
	movl	Fixnum, %eax
	movl	%eax, (%esp)
	movl	$15, 4(%esp)
	movl	$__method_Fixnum___X__3d, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,116,.LM324 -.LFBB0	
.LM324:
	subl	$28, %esp
	movl	Fixnum, %eax
	movl	%eax, (%esp)
	movl	$153, 4(%esp)
	movl	$__method_Fixnum___lt, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,120,.LM325 -.LFBB0	
.LM325:
	subl	$28, %esp
	movl	Fixnum, %eax
	movl	%eax, (%esp)
	movl	$154, 4(%esp)
	movl	$__method_Fixnum___gt, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,124,.LM326 -.LFBB0	
.LM326:
	subl	$28, %esp
	movl	Fixnum, %eax
	movl	%eax, (%esp)
	movl	$155, 4(%esp)
	movl	$__method_Fixnum___ge, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,128,.LM327 -.LFBB0	
.LM327:
	subl	$28, %esp
	movl	Fixnum, %eax
	movl	%eax, (%esp)
	movl	$127, 4(%esp)
	movl	$__method_Fixnum___le__gt, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,139,.LM328 -.LFBB0	
.LM328:
	subl	$28, %esp
	movl	Fixnum, %eax
	movl	%eax, (%esp)
	movl	$156, 4(%esp)
	movl	$__method_Fixnum_div, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,143,.LM329 -.LFBB0	
.LM329:
	subl	$28, %esp
	movl	Fixnum, %eax
	movl	%eax, (%esp)
	movl	$157, 4(%esp)
	movl	$__method_Fixnum_mul, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,150,.LM330 -.LFBB0	
.LM330:
	subl	$28, %esp
	movl	Fixnum, %eax
	movl	%eax, (%esp)
	movl	$132, 4(%esp)
	movl	$__method_Fixnum___mul, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,154,.LM331 -.LFBB0	
.LM331:
	subl	$28, %esp
	movl	Fixnum, %eax
	movl	%eax, (%esp)
	movl	$158, 4(%esp)
	movl	$__method_Fixnum___div, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,158,.LM332 -.LFBB0	
.LM332:
	subl	$28, %esp
	movl	Fixnum, %eax
	movl	%eax, (%esp)
	movl	$125, 4(%esp)
	movl	$__method_Fixnum_ord, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,162,.LM333 -.LFBB0	
.LM333:
	subl	$28, %esp
	movl	Fixnum, %eax
	movl	%eax, (%esp)
	movl	$159, 4(%esp)
	movl	$__method_Fixnum_times, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	# === end class Fixnum ===
	movl	Fixnum, %eax
	.stabn  68,0,171,.LM334 -.LFBB0	
.LM334:
	movl	$1000, FixNum_cache_size
	.stabn  68,0,172,.LM335 -.LFBB0	
.LM335:
	subl	$20, %esp
	movl	FixNum_cache_size, %eax
	movl	%eax, %edi
	movl	$2, %eax
	imull	%edi, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__array_leaf
	addl	$20, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, FixNum_cache
	.stabn  68,0,174,.LM336 -.LFBB0	
.LM336:
	movl	$__int, %eax
	.stabn  68,0,194,.LM337 -.LFBB0	
.LM337:
	subl	$20, %esp
	movl	$0, (%esp)
	movl	$1, %ebx
	call	__int
	addl	$20, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, __I0
	subl	$20, %esp
	movl	$-1, (%esp)
	movl	$1, %ebx
	call	__int
	addl	$20, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, __Ineg1
	subl	$20, %esp
	movl	$10, (%esp)
	movl	$1, %ebx
	call	__int
	addl	$20, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, __I10
	subl	$20, %esp
	movl	$1, (%esp)
	movl	$1, %ebx
	call	__int
	addl	$20, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, __I1
	subl	$20, %esp
	movl	$5381, (%esp)
	movl	$1, %ebx
	call	__int
	addl	$20, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, __I5381
	subl	$20, %esp
	movl	$33, (%esp)
	movl	$1, %ebx
	call	__int
	addl	$20, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, __I33
	subl	$20, %esp
	movl	$34, (%esp)
	movl	$1, %ebx
	call	__int
	addl	$20, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, __I34
	subl	$20, %esp
	movl	$92, (%esp)
	movl	$1, %ebx
	call	__int
	addl	$20, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, __I92
	subl	$20, %esp
	movl	$27, (%esp)
	movl	$1, %ebx
	call	__int
	addl	$20, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, __I27
	subl	$20, %esp
	movl	$45, (%esp)
	movl	$1, %ebx
	call	__int
	addl	$20, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, __I45
	subl	$20, %esp
	movl	$48, (%esp)
	movl	$1, %ebx
	call	__int
	addl	$20, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, __I48
	subl	$20, %esp
	movl	$57, (%esp)
	movl	$1, %ebx
	call	__int
	addl	$20, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, __I57
	subl	$20, %esp
	movl	$13, (%esp)
	movl	$1, %ebx
	call	__int
	addl	$20, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, __I13
	subl	$20, %esp
	movl	$9, (%esp)
	movl	$1, %ebx
	call	__int
	addl	$20, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, __I9
	subl	$20, %esp
	movl	$4, (%esp)
	movl	$1, %ebx
	call	__int
	addl	$20, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, __I4
	subl	$20, %esp
	movl	$2, (%esp)
	movl	$1, %ebx
	call	__int
	addl	$20, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, __I2
	subl	$20, %esp
	movl	$3, (%esp)
	movl	$1, %ebx
	call	__int
	addl	$20, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, __I3
	subl	$20, %esp
	movl	$47, (%esp)
	movl	$1, %ebx
	call	__int
	addl	$20, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, __I47
	subl	$20, %esp
	movl	$36, (%esp)
	movl	$1, %ebx
	call	__int
	addl	$20, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, __I36
	subl	$20, %esp
	movl	$97, (%esp)
	movl	$1, %ebx
	call	__int
	addl	$20, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, __I97
	subl	$20, %esp
	movl	$122, (%esp)
	movl	$1, %ebx
	call	__int
	addl	$20, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, __I122
	subl	$20, %esp
	movl	$64, (%esp)
	movl	$1, %ebx
	call	__int
	addl	$20, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, __I64
	subl	$20, %esp
	movl	$91, (%esp)
	movl	$1, %ebx
	call	__int
	addl	$20, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, __I91
	subl	$20, %esp
	movl	$42, (%esp)
	movl	$1, %ebx
	call	__int
	addl	$20, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, __I42
	subl	$20, %esp
	movl	$43, (%esp)
	movl	$1, %ebx
	call	__int
	addl	$20, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, __I43
	subl	$20, %esp
	movl	$95, (%esp)
	movl	$1, %ebx
	call	__int
	addl	$20, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, __I95
	subl	$20, %esp
	movl	$14, (%esp)
	movl	$1, %ebx
	call	__int
	addl	$20, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, __I14
	movl	nil, %eax
	.stabn  162,0,0,0	
	# End include "/home/vagrant/hokstad/lib/core/fixnum.rb"
	.stabn  68,0,82,.LM338 -.LFBB0	
.LM338:
	.stabs  "/home/vagrant/hokstad/lib/core/symbol.rb",130,0,0,0	
	.stabn  68,0,1,.LM339 -.LFBB0	
.LM339:
	.stabn  68,0,16,.LM340 -.LFBB0	
.LM340:
	# === class Symbol ===
	# if: [:sexp, [:eq, :Symbol, 0]]
	movl	Symbol, %eax
	movl	%eax, %edx
	movl	$0, %eax
	cmpl	%eax, %edx
	sete	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L434_else
	# then: [:assign, :Symbol, [:sexp, [:call, :__new_class_object, [668, :Object, 668, :Class]]]]
	subl	$32, %esp
	movl	$668, (%esp)
	movl	Object, %eax
	movl	%eax, 4(%esp)
	movl	$668, 8(%esp)
	movl	Class, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	__new_class_object
	addl	$32, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, Symbol
	# else: nil
.L434_else:
	movl	Symbol, %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	movl	$2, (%ecx)
	movl	$.L436, %eax
	pushl	%eax
	movl	Symbol, %eax
	movl	%eax, %edi
	addl	$8, %edi
	popl	%eax
	movl	%eax, (%edi)
	.stabn  68,0,21,.LM341 -.LFBB0	
.LM341:
	# callm :Hash.:[]
	subl	$24, %esp
	movl	Hash, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm Hash.[] END
	pushl	%eax
	popl	%eax
	movl	%eax, __classvar__Symbol__symbols
	.stabn  68,0,24,.LM342 -.LFBB0	
.LM342:
	subl	$28, %esp
	movl	Symbol, %eax
	movl	%eax, (%esp)
	movl	$22, 4(%esp)
	movl	$__method_Symbol_initialize, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,28,.LM343 -.LFBB0	
.LM343:
	subl	$28, %esp
	movl	Symbol, %eax
	movl	%eax, (%esp)
	movl	$26, 4(%esp)
	movl	$__method_Symbol_eql__Q, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,32,.LM344 -.LFBB0	
.LM344:
	subl	$28, %esp
	movl	Symbol, %eax
	movl	%eax, (%esp)
	movl	$127, 4(%esp)
	movl	$__method_Symbol___le__gt, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,39,.LM345 -.LFBB0	
.LM345:
	subl	$28, %esp
	movl	Symbol, %eax
	movl	%eax, (%esp)
	movl	$13, 4(%esp)
	movl	$__method_Symbol_to_s, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,43,.LM346 -.LFBB0	
.LM346:
	subl	$28, %esp
	movl	Symbol, %eax
	movl	%eax, (%esp)
	movl	$128, 4(%esp)
	movl	$__method_Symbol_to_sym, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,47,.LM347 -.LFBB0	
.LM347:
	subl	$28, %esp
	movl	Symbol, %eax
	movl	%eax, (%esp)
	movl	$14, 4(%esp)
	movl	$__method_Symbol_inspect, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,81,.LM348 -.LFBB0	
.LM348:
	subl	$28, %esp
	movl	Symbol, %eax
	movl	%eax, (%esp)
	movl	$25, 4(%esp)
	movl	$__method_Symbol_hash, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,85,.LM349 -.LFBB0	
.LM349:
	subl	$28, %esp
	movl	Symbol, %eax
	movl	%eax, (%esp)
	movl	$65, 4(%esp)
	movl	$__method_Symbol___NDX, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,93,.LM350 -.LFBB0	
.LM350:
	# === Eigenclass start
	subl	$32, %esp
	movl	$668, (%esp)
	movl	Symbol, %eax
	movl	%eax, %edx
	movl	(%edx), %eax
	movl	%eax, 4(%esp)
	movl	$668, 8(%esp)
	movl	Symbol, %eax
	movl	%eax, %ecx
	movl	(%ecx), %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	__new_class_object
	addl	$32, %esp
	pushl	%eax
	movl	Symbol, %eax
	movl	%eax, %edi
	popl	%eax
	movl	%eax, (%edi)
	subl	$12, %esp
	addl	$3, %ebx
	movl	%eax, -12(%ebp)
	movl	$.L445, %eax
	pushl	%eax
	# [:lvar, 1, :esi]
	movl	-12(%ebp), %esi
	movl	%esi, %edx
	addl	$8, %edx
	popl	%eax
	movl	%eax, (%edx)
	subl	$28, %esp
	movl	%esi, (%esp)
	movl	$8, 4(%esp)
	movl	$__method____get_symbol, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	# [:lvar, 1, :esi]
	movl	-12(%ebp), %esi
	movl	-12(%ebp), %eax
	addl	$12, %esp
	# === Eigenclass end
	# === end class Symbol ===
	movl	Symbol, %eax
	.stabn  68,0,103,.LM351 -.LFBB0	
.LM351:
	movl	$__get_symbol, %eax
	.stabn  162,0,0,0	
	# End include "/home/vagrant/hokstad/lib/core/symbol.rb"
	.stabn  68,0,83,.LM352 -.LFBB0	
.LM352:
	.stabs  "/home/vagrant/hokstad/lib/core/class_ext.rb",130,0,0,0	
	.stabn  68,0,1,.LM353 -.LFBB0	
.LM353:
	.stabn  68,0,7,.LM354 -.LFBB0	
.LM354:
	# === class Class ===
	# if: [:sexp, [:eq, :Class, 0]]
	movl	Class, %eax
	movl	%eax, %ecx
	movl	$0, %eax
	cmpl	%eax, %ecx
	sete	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L448_else
	# then: [:assign, :Class, [:sexp, [:call, :__new_class_object, [668, :Object, 0, :Class]]]]
	subl	$32, %esp
	movl	$668, (%esp)
	movl	Object, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	Class, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	__new_class_object
	addl	$32, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, Class
	# else: nil
.L448_else:
	movl	Class, %eax
	movl	%eax, %edi
	addl	$4, %edi
	movl	$4, (%edi)
	movl	$.L120, %eax
	pushl	%eax
	movl	Class, %eax
	movl	%eax, %edx
	addl	$8, %edx
	popl	%eax
	movl	%eax, (%edx)
	.stabn  68,0,8,.LM355 -.LFBB0	
.LM355:
	# callm :Hash.:[]
	subl	$24, %esp
	movl	Hash, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm Hash.[] END
	pushl	%eax
	popl	%eax
	pushl	%eax
	movl	Class, %eax
	popl	%ecx
	movl	%ecx, 12(%eax)
	.stabn  68,0,10,.LM356 -.LFBB0	
.LM356:
	# === Eigenclass start
	subl	$32, %esp
	movl	$668, (%esp)
	movl	Class, %eax
	movl	%eax, %edi
	movl	(%edi), %eax
	movl	%eax, 4(%esp)
	movl	$668, 8(%esp)
	movl	Class, %eax
	movl	%eax, %edx
	movl	(%edx), %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	__new_class_object
	addl	$32, %esp
	pushl	%eax
	movl	Class, %eax
	movl	%eax, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	subl	$12, %esp
	addl	$3, %ebx
	movl	%eax, -12(%ebp)
	movl	$.L450, %eax
	pushl	%eax
	# [:lvar, 1, :esi]
	movl	-12(%ebp), %esi
	movl	%esi, %edi
	addl	$8, %edi
	popl	%eax
	movl	%eax, (%edi)
	subl	$28, %esp
	movl	%esi, (%esp)
	movl	$160, 4(%esp)
	movl	$__method__method_to_voff, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	# [:lvar, 1, :esi]
	movl	-12(%ebp), %esi
	movl	-12(%ebp), %eax
	addl	$12, %esp
	# === Eigenclass end
	.stabn  68,0,14,.LM357 -.LFBB0	
.LM357:
	subl	$28, %esp
	movl	Class, %eax
	movl	%eax, (%esp)
	movl	$31, 4(%esp)
	movl	$__method_Class_method_missing, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,22,.LM358 -.LFBB0	
.LM358:
	subl	$28, %esp
	movl	Class, %eax
	movl	%eax, (%esp)
	movl	$161, 4(%esp)
	movl	$__method_Class___send_for_obj__, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	# === end class Class ===
	movl	Class, %eax
	.stabn  68,0,44,.LM359 -.LFBB0	
.LM359:
	subl	$20, %esp
	addl	$5, %ebx
	movl	$0, -12(%ebp)
	movl	$__vtable_size, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	# callm :Class.:method_to_voff
	subl	$24, %esp
	movl	Class, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__method_to_voff(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm Class.method_to_voff END
	pushl	%eax
	popl	%eax
	movl	%eax, h
.L455:
	movl	-12(%ebp), %eax
	movl	%eax, %edx
	movl	-16(%ebp), %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L454
	movl	$__vtable_names, %eax
	movl	%eax, %ecx
	pushl	%ecx
	movl	-12(%ebp), %eax
	sall	$2, %eax
	popl	%ecx
	addl	%eax, %ecx
	movl	(%ecx), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	# if: [:ne, :ptr, 0]
	movl	-20(%ebp), %eax
	movl	%eax, %edi
	movl	$0, %eax
	cmpl	%eax, %edi
	setne	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L456_else
	# then: [:callm, :h, :[]=, [[:__get_symbol, :ptr], [:__int, :i]]]
	# callm :h.:[]=
	subl	$32, %esp
	movl	h, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	subl	$20, %esp
	movl	-20(%ebp), %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	movl	%eax, 8(%esp)
	subl	$20, %esp
	movl	-12(%ebp), %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__int
	addl	$20, %esp
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX__3d(%eax)
	# Evicting self
	# Static adj: 32
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm h.[]= END
	# else: nil
.L456_else:
	movl	-12(%ebp), %eax
	movl	%eax, %edx
	movl	$1, %eax
	addl	%edx, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	jmp	.L455
.L454:
	movl	nil, %eax
	addl	$20, %esp
	.stabn  162,0,0,0	
	# End include "/home/vagrant/hokstad/lib/core/class_ext.rb"
	.stabn  68,0,84,.LM360 -.LFBB0	
.LM360:
	.stabs  "/home/vagrant/hokstad/lib/core/hash_ext.rb",130,0,0,0	
	.stabn  68,0,1,.LM361 -.LFBB0	
.LM361:
	.stabn  68,0,4,.LM362 -.LFBB0	
.LM362:
	# === class Hash ===
	# if: [:sexp, [:eq, :Hash, 0]]
	movl	Hash, %eax
	movl	%eax, %ecx
	movl	$0, %eax
	cmpl	%eax, %ecx
	sete	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L458_else
	# then: [:assign, :Hash, [:sexp, [:call, :__new_class_object, [668, :Object, 668, :Class]]]]
	subl	$32, %esp
	movl	$668, (%esp)
	movl	Object, %eax
	movl	%eax, 4(%esp)
	movl	$668, 8(%esp)
	movl	Class, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	__new_class_object
	addl	$32, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, Hash
	# else: nil
.L458_else:
	movl	Hash, %eax
	movl	%eax, %edi
	addl	$4, %edi
	movl	$7, (%edi)
	movl	$.L346, %eax
	pushl	%eax
	movl	Hash, %eax
	movl	%eax, %edx
	addl	$8, %edx
	popl	%eax
	movl	%eax, (%edx)
	.stabn  68,0,6,.LM363 -.LFBB0	
.LM363:
	# === Eigenclass start
	subl	$32, %esp
	movl	$668, (%esp)
	movl	Hash, %eax
	movl	%eax, %ecx
	movl	(%ecx), %eax
	movl	%eax, 4(%esp)
	movl	$668, 8(%esp)
	movl	Hash, %eax
	movl	%eax, %edi
	movl	(%edi), %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	__new_class_object
	addl	$32, %esp
	pushl	%eax
	movl	Hash, %eax
	movl	%eax, %edx
	popl	%eax
	movl	%eax, (%edx)
	subl	$12, %esp
	addl	$3, %ebx
	movl	%eax, -12(%ebp)
	movl	$.L353, %eax
	pushl	%eax
	# [:lvar, 1, :esi]
	movl	-12(%ebp), %esi
	movl	%esi, %ecx
	addl	$8, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	subl	$28, %esp
	movl	%esi, (%esp)
	movl	$65, 4(%esp)
	movl	$__method____NDX__2, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	# [:lvar, 1, :esi]
	movl	-12(%ebp), %esi
	movl	-12(%ebp), %eax
	addl	$12, %esp
	# === Eigenclass end
	.stabn  68,0,28,.LM364 -.LFBB0	
.LM364:
	subl	$28, %esp
	movl	Hash, %eax
	movl	%eax, (%esp)
	movl	$110, 4(%esp)
	movl	$__method_Hash_sort_by, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,32,.LM365 -.LFBB0	
.LM365:
	subl	$28, %esp
	movl	Hash, %eax
	movl	%eax, (%esp)
	movl	$60, 4(%esp)
	movl	$__method_Hash_collect, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,35,.LM366 -.LFBB0	
.LM366:
	subl	$28, %esp
	movl	Hash, %eax
	movl	%eax, (%esp)
	movl	$14, 4(%esp)
	movl	$__method_Hash_inspect, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,53,.LM367 -.LFBB0	
.LM367:
	subl	$28, %esp
	movl	Hash, %eax
	movl	%eax, (%esp)
	movl	$162, 4(%esp)
	movl	$__method_Hash_keys, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	# === end class Hash ===
	movl	Hash, %eax
	.stabn  162,0,0,0	
	# End include "/home/vagrant/hokstad/lib/core/hash_ext.rb"
	.stabn  68,0,85,.LM368 -.LFBB0	
.LM368:
	.stabs  "/home/vagrant/hokstad/lib/core/float.rb",130,0,0,0	
	.stabn  68,0,1,.LM369 -.LFBB0	
.LM369:
	.stabn  68,0,2,.LM370 -.LFBB0	
.LM370:
	# === class Float ===
	# if: [:sexp, [:eq, :Float, 0]]
	movl	Float, %eax
	movl	%eax, %edi
	movl	$0, %eax
	cmpl	%eax, %edi
	sete	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L465_else
	# then: [:assign, :Float, [:sexp, [:call, :__new_class_object, [668, :Object, 668, :Class]]]]
	subl	$32, %esp
	movl	$668, (%esp)
	movl	Object, %eax
	movl	%eax, 4(%esp)
	movl	$668, 8(%esp)
	movl	Class, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	__new_class_object
	addl	$32, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, Float
	# else: nil
.L465_else:
	movl	Float, %eax
	movl	%eax, %edx
	addl	$4, %edx
	movl	$1, (%edx)
	movl	$.L467, %eax
	pushl	%eax
	movl	Float, %eax
	movl	%eax, %ecx
	addl	$8, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	movl	nil, %eax
	# === end class Float ===
	movl	Float, %eax
	.stabn  162,0,0,0	
	# End include "/home/vagrant/hokstad/lib/core/float.rb"
	.stabn  68,0,86,.LM371 -.LFBB0	
.LM371:
	.stabs  "/home/vagrant/hokstad/lib/core/struct.rb",130,0,0,0	
	.stabn  68,0,1,.LM372 -.LFBB0	
.LM372:
	.stabn  68,0,2,.LM373 -.LFBB0	
.LM373:
	# === class Struct ===
	# if: [:sexp, [:eq, :Struct, 0]]
	movl	Struct, %eax
	movl	%eax, %edi
	movl	$0, %eax
	cmpl	%eax, %edi
	sete	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L468_else
	# then: [:assign, :Struct, [:sexp, [:call, :__new_class_object, [668, :Object, 668, :Class]]]]
	subl	$32, %esp
	movl	$668, (%esp)
	movl	Object, %eax
	movl	%eax, 4(%esp)
	movl	$668, 8(%esp)
	movl	Class, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	__new_class_object
	addl	$32, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, Struct
	# else: nil
.L468_else:
	movl	Struct, %eax
	movl	%eax, %edx
	addl	$4, %edx
	movl	$1, (%edx)
	movl	$.L470, %eax
	pushl	%eax
	movl	Struct, %eax
	movl	%eax, %ecx
	addl	$8, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	.stabn  68,0,4,.LM374 -.LFBB0	
.LM374:
	subl	$28, %esp
	movl	Struct, %eax
	movl	%eax, (%esp)
	movl	$22, 4(%esp)
	movl	$__method_Struct_initialize, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	# === end class Struct ===
	movl	Struct, %eax
	.stabn  162,0,0,0	
	# End include "/home/vagrant/hokstad/lib/core/struct.rb"
	.stabn  68,0,87,.LM375 -.LFBB0	
.LM375:
	.stabs  "/home/vagrant/hokstad/lib/core/exception.rb",130,0,0,0	
	.stabn  68,0,1,.LM376 -.LFBB0	
.LM376:
	.stabn  68,0,2,.LM377 -.LFBB0	
.LM377:
	# === class Exception ===
	# if: [:sexp, [:eq, :Exception, 0]]
	movl	Exception, %eax
	movl	%eax, %edi
	movl	$0, %eax
	cmpl	%eax, %edi
	sete	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L472_else
	# then: [:assign, :Exception, [:sexp, [:call, :__new_class_object, [668, :Object, 668, :Class]]]]
	subl	$32, %esp
	movl	$668, (%esp)
	movl	Object, %eax
	movl	%eax, 4(%esp)
	movl	$668, 8(%esp)
	movl	Class, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	__new_class_object
	addl	$32, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, Exception
	# else: nil
.L472_else:
	movl	Exception, %eax
	movl	%eax, %edx
	addl	$4, %edx
	movl	$1, (%edx)
	movl	$.L474, %eax
	pushl	%eax
	movl	Exception, %eax
	movl	%eax, %ecx
	addl	$8, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	movl	nil, %eax
	# === end class Exception ===
	movl	Exception, %eax
	.stabn  162,0,0,0	
	# End include "/home/vagrant/hokstad/lib/core/exception.rb"
	.stabn  68,0,88,.LM378 -.LFBB0	
.LM378:
	.stabs  "/home/vagrant/hokstad/lib/core/pp.rb",130,0,0,0	
	.stabn  68,0,1,.LM379 -.LFBB0	
.LM379:
	.stabn  68,0,7,.LM380 -.LFBB0	
.LM380:
	# === class PP ===
	# if: [:sexp, [:eq, :PP, 0]]
	movl	PP, %eax
	movl	%eax, %edi
	movl	$0, %eax
	cmpl	%eax, %edi
	sete	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L475_else
	# then: [:assign, :PP, [:sexp, [:call, :__new_class_object, [668, :Object, 668, :Class]]]]
	subl	$32, %esp
	movl	$668, (%esp)
	movl	Object, %eax
	movl	%eax, 4(%esp)
	movl	$668, 8(%esp)
	movl	Class, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	__new_class_object
	addl	$32, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, PP
	# else: nil
.L475_else:
	movl	PP, %eax
	movl	%eax, %edx
	addl	$4, %edx
	movl	$1, (%edx)
	movl	$.L477, %eax
	pushl	%eax
	movl	PP, %eax
	movl	%eax, %ecx
	addl	$8, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	movl	nil, %eax
	# === end class PP ===
	movl	PP, %eax
	.stabn  162,0,0,0	
	# End include "/home/vagrant/hokstad/lib/core/pp.rb"
	.stabn  68,0,89,.LM381 -.LFBB0	
.LM381:
	.stabs  "/home/vagrant/hokstad/lib/core/regexp.rb",130,0,0,0	
	.stabn  68,0,1,.LM382 -.LFBB0	
.LM382:
	.stabn  68,0,2,.LM383 -.LFBB0	
.LM383:
	# === class Regexp ===
	# if: [:sexp, [:eq, :Regexp, 0]]
	movl	Regexp, %eax
	movl	%eax, %edi
	movl	$0, %eax
	cmpl	%eax, %edi
	sete	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L478_else
	# then: [:assign, :Regexp, [:sexp, [:call, :__new_class_object, [668, :Object, 668, :Class]]]]
	subl	$32, %esp
	movl	$668, (%esp)
	movl	Object, %eax
	movl	%eax, 4(%esp)
	movl	$668, 8(%esp)
	movl	Class, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	__new_class_object
	addl	$32, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, Regexp
	# else: nil
.L478_else:
	movl	Regexp, %eax
	movl	%eax, %edx
	addl	$4, %edx
	movl	$1, (%edx)
	movl	$.L480, %eax
	pushl	%eax
	movl	Regexp, %eax
	movl	%eax, %ecx
	addl	$8, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	.stabn  68,0,5,.LM384 -.LFBB0	
.LM384:
	subl	$28, %esp
	movl	Regexp, %eax
	movl	%eax, (%esp)
	movl	$22, 4(%esp)
	movl	$__method_Regexp_initialize, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	# === end class Regexp ===
	movl	Regexp, %eax
	.stabn  162,0,0,0	
	# End include "/home/vagrant/hokstad/lib/core/regexp.rb"
	.stabn  68,0,90,.LM385 -.LFBB0	
.LM385:
	.stabs  "/home/vagrant/hokstad/lib/core/enumerator.rb",130,0,0,0	
	.stabn  68,0,1,.LM386 -.LFBB0	
.LM386:
	.stabn  68,0,8,.LM387 -.LFBB0	
.LM387:
	# === class Enumerator ===
	# if: [:sexp, [:eq, :Enumerator, 0]]
	movl	Enumerator, %eax
	movl	%eax, %edi
	movl	$0, %eax
	cmpl	%eax, %edi
	sete	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L482_else
	# then: [:assign, :Enumerator, [:sexp, [:call, :__new_class_object, [668, :Object, 668, :Class]]]]
	subl	$32, %esp
	movl	$668, (%esp)
	movl	Object, %eax
	movl	%eax, 4(%esp)
	movl	$668, 8(%esp)
	movl	Class, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	__new_class_object
	addl	$32, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, Enumerator
	# else: nil
.L482_else:
	movl	Enumerator, %eax
	movl	%eax, %edx
	addl	$4, %edx
	movl	$1, (%edx)
	movl	$.L484, %eax
	pushl	%eax
	movl	Enumerator, %eax
	movl	%eax, %ecx
	addl	$8, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	movl	nil, %eax
	# === end class Enumerator ===
	movl	Enumerator, %eax
	.stabn  68,0,12,.LM388 -.LFBB0	
.LM388:
	# === class ArrayEnumerator ===
	# if: [:sexp, [:eq, :ArrayEnumerator, 0]]
	movl	ArrayEnumerator, %eax
	movl	%eax, %edi
	movl	$0, %eax
	cmpl	%eax, %edi
	sete	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L485_else
	# then: [:assign, :ArrayEnumerator, [:sexp, [:call, :__new_class_object, [668, :Enumerator, 668, [:index, :Enumerator, 0]]]]]
	subl	$32, %esp
	movl	$668, (%esp)
	movl	Enumerator, %eax
	movl	%eax, 4(%esp)
	movl	$668, 8(%esp)
	movl	Enumerator, %eax
	movl	%eax, %edx
	movl	(%edx), %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	__new_class_object
	addl	$32, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, ArrayEnumerator
	# else: nil
.L485_else:
	movl	ArrayEnumerator, %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	movl	$3, (%ecx)
	movl	$.L487, %eax
	pushl	%eax
	movl	ArrayEnumerator, %eax
	movl	%eax, %edi
	addl	$8, %edi
	popl	%eax
	movl	%eax, (%edi)
	.stabn  68,0,13,.LM389 -.LFBB0	
.LM389:
	subl	$28, %esp
	movl	ArrayEnumerator, %eax
	movl	%eax, (%esp)
	movl	$22, 4(%esp)
	movl	$__method_ArrayEnumerator_initialize, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,18,.LM390 -.LFBB0	
.LM390:
	subl	$28, %esp
	movl	ArrayEnumerator, %eax
	movl	%eax, (%esp)
	movl	$163, 4(%esp)
	movl	$__method_ArrayEnumerator_next, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	# === end class ArrayEnumerator ===
	movl	ArrayEnumerator, %eax
	.stabn  68,0,31,.LM391 -.LFBB0	
.LM391:
	# === class RangeEnumerator ===
	# if: [:sexp, [:eq, :RangeEnumerator, 0]]
	movl	RangeEnumerator, %eax
	movl	%eax, %edx
	movl	$0, %eax
	cmpl	%eax, %edx
	sete	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L490_else
	# then: [:assign, :RangeEnumerator, [:sexp, [:call, :__new_class_object, [668, :Enumerator, 668, [:index, :Enumerator, 0]]]]]
	subl	$32, %esp
	movl	$668, (%esp)
	movl	Enumerator, %eax
	movl	%eax, 4(%esp)
	movl	$668, 8(%esp)
	movl	Enumerator, %eax
	movl	%eax, %ecx
	movl	(%ecx), %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	__new_class_object
	addl	$32, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, RangeEnumerator
	# else: nil
.L490_else:
	movl	RangeEnumerator, %eax
	movl	%eax, %edi
	addl	$4, %edi
	movl	$4, (%edi)
	movl	$.L492, %eax
	pushl	%eax
	movl	RangeEnumerator, %eax
	movl	%eax, %edx
	addl	$8, %edx
	popl	%eax
	movl	%eax, (%edx)
	.stabn  68,0,34,.LM392 -.LFBB0	
.LM392:
	subl	$28, %esp
	movl	RangeEnumerator, %eax
	movl	%eax, (%esp)
	movl	$22, 4(%esp)
	movl	$__method_RangeEnumerator_initialize, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,40,.LM393 -.LFBB0	
.LM393:
	subl	$28, %esp
	movl	RangeEnumerator, %eax
	movl	%eax, (%esp)
	movl	$164, 4(%esp)
	movl	$__method_RangeEnumerator_rewind, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,44,.LM394 -.LFBB0	
.LM394:
	subl	$28, %esp
	movl	RangeEnumerator, %eax
	movl	%eax, (%esp)
	movl	$163, 4(%esp)
	movl	$__method_RangeEnumerator_next, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	# === end class RangeEnumerator ===
	movl	RangeEnumerator, %eax
	.stabn  162,0,0,0	
	# End include "/home/vagrant/hokstad/lib/core/enumerator.rb"
	.stabn  68,0,96,.LM395 -.LFBB0	
.LM395:
	.stabs  "/home/vagrant/hokstad/lib/core/args.rb",130,0,0,0	
	.stabn  68,0,1,.LM396 -.LFBB0	
.LM396:
	.stabn  68,0,2,.LM397 -.LFBB0	
.LM397:
	subl	$20, %esp
	movl	12(%ebp), %eax
	movl	%eax, %ecx
	movl	(%ecx), %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, __D_0
	.stabn  68,0,4,.LM398 -.LFBB0	
.LM398:
	# callm :Array.:[]
	subl	$24, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm Array.[] END
	pushl	%eax
	popl	%eax
	movl	%eax, ARGV
	.stabn  68,0,5,.LM399 -.LFBB0	
.LM399:
	subl	$16, %esp
	addl	$4, %ebx
	movl	$1, -16(%ebp)
	# callm :ARGV.:__grow
	subl	$28, %esp
	movl	ARGV, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	8(%ebp), %eax
	movl	%eax, %edi
	movl	$1, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____grow(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm ARGV.__grow END
.L497:
	movl	-16(%ebp), %eax
	movl	%eax, %edx
	movl	8(%ebp), %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L496
	# callm :ARGV.:__set
	subl	$32, %esp
	movl	ARGV, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	-16(%ebp), %eax
	movl	%eax, %ecx
	movl	$1, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 8(%esp)
	subl	$20, %esp
	movl	12(%ebp), %eax
	movl	%eax, %edi
	pushl	%edi
	movl	-16(%ebp), %eax
	sall	$2, %eax
	popl	%edi
	addl	%eax, %edi
	movl	(%edi), %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____set(%eax)
	# Evicting self
	# Static adj: 32
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm ARGV.__set END
	movl	-16(%ebp), %eax
	movl	%eax, %edx
	movl	$1, %eax
	addl	%edx, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	jmp	.L497
.L496:
	movl	nil, %eax
	addl	$16, %esp
	.stabn  162,0,0,0	
	# End include "/home/vagrant/hokstad/lib/core/args.rb"
	.stabn  68,0,97,.LM400 -.LFBB0	
.LM400:
	.stabs  "/home/vagrant/hokstad/lib/core/stdio.rb",130,0,0,0	
	.stabn  68,0,1,.LM401 -.LFBB0	
.LM401:
	.stabn  68,0,2,.LM402 -.LFBB0	
.LM402:
	# callm :IO.:new
	subl	$28, %esp
	movl	IO, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I0, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__new(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm IO.new END
	pushl	%eax
	popl	%eax
	movl	%eax, STDIN
	.stabn  68,0,3,.LM403 -.LFBB0	
.LM403:
	# callm :IO.:new
	subl	$28, %esp
	movl	IO, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__new(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm IO.new END
	pushl	%eax
	popl	%eax
	movl	%eax, STDOUT
	.stabn  68,0,4,.LM404 -.LFBB0	
.LM404:
	# callm :IO.:new
	subl	$28, %esp
	movl	IO, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I2, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__new(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm IO.new END
	pushl	%eax
	popl	%eax
	movl	%eax, STDERR
	.stabn  162,0,0,0	
	# End include "/home/vagrant/hokstad/lib/core/stdio.rb"
	.stabn  68,0,98,.LM405 -.LFBB0	
.LM405:
	.stabs  "/home/vagrant/hokstad/lib/core/stubs.rb",130,0,0,0	
	.stabn  68,0,1,.LM406 -.LFBB0	
.LM406:
	.stabn  68,0,10,.LM407 -.LFBB0	
.LM407:
	subl	$20, %esp
	movl	$.L59, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	pushl	%eax
	popl	%eax
	movl	%eax, __FILE__
	.stabn  68,0,18,.LM408 -.LFBB0	
.LM408:
	# callm :Object.:new
	subl	$24, %esp
	movl	Object, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__new(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm Object.new END
	pushl	%eax
	popl	%eax
	movl	%eax, self
	.stabn  68,0,27,.LM409 -.LFBB0	
.LM409:
	movl	__I2, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, E
	.stabn  68,0,32,.LM410 -.LFBB0	
.LM410:
	subl	$28, %esp
	movl	Object, %eax
	movl	%eax, (%esp)
	movl	$165, 4(%esp)
	movl	$__method_Object_raise, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,41,.LM411 -.LFBB0	
.LM411:
	movl	$range, %eax
	.stabn  68,0,46,.LM412 -.LFBB0	
.LM412:
	# callm :Array.:[]
	subl	$24, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm Array.[] END
	pushl	%eax
	popl	%eax
	movl	%eax, LOAD_PATH
	.stabn  68,0,50,.LM413 -.LFBB0	
.LM413:
	subl	$20, %esp
	movl	$.L63, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	pushl	%eax
	popl	%eax
	movl	%eax, RUBY_ENGINE
	.stabn  162,0,0,0	
	# End include "/home/vagrant/hokstad/lib/core/stubs.rb"
	.stabn  68,0,99,.LM414 -.LFBB0	
.LM414:
	.stabs  "/home/vagrant/hokstad/lib/core/debug.rb",130,0,0,0	
	subl	$20, %esp
	movl	$.L500, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	pushl	%eax
	popl	%eax
	movl	%eax, __FILE__
	.stabn  68,0,1,.LM415 -.LFBB0	
.LM415:
	.stabn  68,0,7,.LM416 -.LFBB0	
.LM416:
	movl	$printregs, %eax
	subl	$20, %esp
	movl	$.L500, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	pushl	%eax
	popl	%eax
	movl	%eax, __FILE__
	.stabn  162,0,0,0	
	# End include "/home/vagrant/hokstad/lib/core/debug.rb"
	.stabn  162,0,0,0	
	# End include "/home/vagrant/hokstad/lib/core/core.rb"
	.stabn  68,0,1,.LM417	
.LM417:
	# === class Integer ===
	# if: [:sexp, [:eq, :Integer, 0]]
	movl	Integer, %eax
	movl	%eax, %ecx
	movl	$0, %eax
	cmpl	%eax, %ecx
	sete	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L502_else
	# then: [:assign, :Integer, [:sexp, [:call, :__new_class_object, [668, :Object, 668, :Class]]]]
	subl	$32, %esp
	movl	$668, (%esp)
	movl	Object, %eax
	movl	%eax, 4(%esp)
	movl	$668, 8(%esp)
	movl	Class, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	__new_class_object
	addl	$32, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	pushl	%eax
	popl	%eax
	movl	%eax, Integer
	# else: nil
.L502_else:
	movl	Integer, %eax
	movl	%eax, %edi
	addl	$4, %edi
	movl	$1, (%edi)
	movl	$.L401, %eax
	pushl	%eax
	movl	Integer, %eax
	movl	%eax, %edx
	addl	$8, %edx
	popl	%eax
	movl	%eax, (%edx)
	.stabn  68,0,2,.LM418	
.LM418:
	subl	$28, %esp
	movl	Integer, %eax
	movl	%eax, (%esp)
	movl	$132, 4(%esp)
	movl	$__method_Integer___mul, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	# === end class Integer ===
	movl	Integer, %eax
	.stabn  68,0,7,.LM419	
.LM419:
	subl	$28, %esp
	movl	Object, %eax
	movl	%eax, (%esp)
	movl	$166, 4(%esp)
	movl	$__method_Object_multiply, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	.stabn  68,0,11,.LM420	
.LM420:
.L507:
	movl	true, %eax
	cmpl	%eax, nil
	je	.L506
	cmpl	%eax, false
	je	.L506
	# callm :self.:puts
	subl	$28, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	# callm :self.:multiply
	subl	$32, %esp
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	__I14, %eax
	movl	%eax, 8(%esp)
	movl	__I2, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__multiply(%eax)
	# Evicting self
	# Static adj: 32
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.multiply END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	# [:global, :self, :esi]
	movl	self, %esi
	movl	(%esi), %eax
	call	*__voff__puts(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.puts END
	jmp	.L507
.L506:
	movl	nil, %eax
	subl	$20, %esp
	movl	$0, (%esp)
	movl	$1, %ebx
	call	exit
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ecx
	popl	%ebp
	ret	
	.size	main, .-main
		
		
		
	########################### __method_missing ###########################	
		
	.stabs  "__method_missing:F(0,0)",36,0,0,__method_missing	
.globl __method_missing
	.type	__method_missing, @function
__method_missing:
.LFBB1:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# METHOD BODY:
	subl	$12, %esp
	addl	$3, %ebx
	# callm [:index, :ob, 0].:inspect
	subl	$24, %esp
	movl	12(%ebp), %eax
	movl	%eax, %ecx
	movl	(%ecx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__inspect(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :ob, 0].inspect END
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	subl	$28, %esp
	movl	$.L509, %eax
	movl	%eax, (%esp)
	# callm [:callm, :cname, :to_s].:__get_raw
	subl	$24, %esp
	# callm :cname.:to_s
	subl	$24, %esp
	movl	-16(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm cname.to_s END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____get_raw(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :cname, :to_s].__get_raw END
	movl	%eax, 4(%esp)
	# callm [:callm, :sym, :to_s].:__get_raw
	subl	$24, %esp
	# callm :sym.:to_s
	subl	$24, %esp
	movl	8(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm sym.to_s END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____get_raw(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :sym, :to_s].__get_raw END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	printf
	addl	$28, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	pushl	$0
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	movl	$0, %eax
	addl	$12, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_missing, .-__method_missing
.Lscope1:
	.stabs  "",36,0,0,.Lscope1-.LFBB1	
		
	########################################################################	
		
		
		
		
		
		
		
	############################### __alloc ################################	
		
	.stabs  "__alloc:F(0,0)",36,0,0,__alloc	
.globl __alloc
	.type	__alloc, @function
__alloc:
.LFBB2:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# METHOD BODY:
	subl	$12, %esp
	addl	$3, %ebx
	subl	$24, %esp
	movl	8(%ebp), %eax
	movl	%eax, (%esp)
	movl	$1, 4(%esp)
	movl	$2, %ebx
	call	calloc
	addl	$24, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# if: [:eq, :ptr, 0]
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	movl	$0, %eax
	cmpl	%eax, %ecx
	sete	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L511_else
	# then: [:return, 0]
	movl	$0, %eax
	movl	-4(%ebp), %ebx
	# [:global, :self, :esi]
	movl	self, %esi
	leave	
	ret	
	# else: nil
.L511_else:
	subl	$28, %esp
	movl	-12(%ebp), %eax
	movl	%eax, (%esp)
	movl	8(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	12(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	tgc_add
	addl	$28, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	movl	-4(%ebp), %ebx
	# [:global, :self, :esi]
	movl	self, %esi
	leave	
	ret	
	addl	$12, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__alloc, .-__alloc
.Lscope2:
	.stabs  "",36,0,0,.Lscope2-.LFBB2	
		
	########################################################################	
		
		
		
		
		
		
		
	############################# __alloc_mem ##############################	
		
	.stabs  "__alloc_mem:F(0,0)",36,0,0,__alloc_mem	
.globl __alloc_mem
	.type	__alloc_mem, @function
__alloc_mem:
.LFBB3:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# METHOD BODY:
	subl	$24, %esp
	movl	8(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	call	__alloc
	addl	$24, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	movl	-4(%ebp), %ebx
	# [:global, :self, :esi]
	movl	self, %esi
	leave	
	ret	
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__alloc_mem, .-__alloc_mem
.Lscope3:
	.stabs  "",36,0,0,.Lscope3-.LFBB3	
		
	########################################################################	
		
		
		
		
		
		
		
	############################# __alloc_leaf #############################	
		
	.stabs  "__alloc_leaf:F(0,0)",36,0,0,__alloc_leaf	
.globl __alloc_leaf
	.type	__alloc_leaf, @function
__alloc_leaf:
.LFBB4:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# METHOD BODY:
	subl	$24, %esp
	movl	8(%ebp), %eax
	movl	%eax, (%esp)
	movl	$1, 4(%esp)
	movl	$2, %ebx
	call	__alloc
	addl	$24, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	movl	-4(%ebp), %ebx
	# [:global, :self, :esi]
	movl	self, %esi
	leave	
	ret	
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__alloc_leaf, .-__alloc_leaf
.Lscope4:
	.stabs  "",36,0,0,.Lscope4-.LFBB4	
		
	########################################################################	
		
		
		
		
		
		
		
	############################## __realloc ###############################	
		
	.stabs  "__realloc:F(0,0)",36,0,0,__realloc	
.globl __realloc
	.type	__realloc, @function
__realloc:
.LFBB5:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# METHOD BODY:
	subl	$24, %esp
	movl	8(%ebp), %eax
	movl	%eax, (%esp)
	movl	12(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	call	tgc_realloc
	addl	$24, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__realloc, .-__realloc
.Lscope5:
	.stabs  "",36,0,0,.Lscope5-.LFBB5	
		
	########################################################################	
		
		
		
		
		
		
		
	############################### __array ################################	
		
	.stabs  "__array:F(0,0)",36,0,0,__array	
.globl __array
	.type	__array, @function
__array:
.LFBB6:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# METHOD BODY:
	subl	$20, %esp
	movl	8(%ebp), %eax
	movl	%eax, %edi
	movl	$4, %eax
	imull	%edi, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__array, .-__array
.Lscope6:
	.stabs  "",36,0,0,.Lscope6-.LFBB6	
		
	########################################################################	
		
		
		
		
		
		
		
	############################# __array_leaf #############################	
		
	.stabs  "__array_leaf:F(0,0)",36,0,0,__array_leaf	
.globl __array_leaf
	.type	__array_leaf, @function
__array_leaf:
.LFBB7:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# METHOD BODY:
	subl	$20, %esp
	movl	8(%ebp), %eax
	movl	%eax, %edx
	movl	$4, %eax
	imull	%edx, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__alloc_leaf
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__array_leaf, .-__array_leaf
.Lscope7:
	.stabs  "",36,0,0,.Lscope7-.LFBB7	
		
	########################################################################	
		
		
		
		
		
		
		
	############################### __docnt ################################	
		
	.stabs  "__docnt:F(0,0)",36,0,0,__docnt	
.globl __docnt
	.type	__docnt, @function
__docnt:
.LFBB8:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# METHOD BODY:
	movl	__cnt, %eax
	movl	%eax, %ecx
	movl	$1, %eax
	addl	%ecx, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, __cnt
	subl	$24, %esp
	movl	$.L519, %eax
	movl	%eax, (%esp)
	movl	__cnt, %eax
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	call	printf
	addl	$24, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__docnt, .-__docnt
.Lscope8:
	.stabs  "",36,0,0,.Lscope8-.LFBB8	
		
	########################################################################	
		
		
		
		
		
		
		
	########################## __new_class_object ##########################	
		
	.stabs  "__new_class_object:F(0,0)",36,0,0,__new_class_object	
.globl __new_class_object
	.type	__new_class_object, @function
__new_class_object:
.LFBB9:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# METHOD BODY:
	subl	$16, %esp
	addl	$4, %ebx
	# if: [:eq, :classob, 0]
	movl	20(%ebp), %eax
	movl	%eax, %edi
	movl	$0, %eax
	cmpl	%eax, %edi
	sete	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L521_else
	# then: [:assign, :classob, :Class]
	movl	Class, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, 20(%ebp)
	# else: nil
.L521_else:
	subl	$20, %esp
	movl	8(%ebp), %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__array
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	movl	$6, -16(%ebp)
.L524:
	movl	-16(%ebp), %eax
	movl	%eax, %edx
	movl	16(%ebp), %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L523
	movl	12(%ebp), %eax
	movl	%eax, %ecx
	pushl	%ecx
	movl	-16(%ebp), %eax
	sall	$2, %eax
	popl	%ecx
	addl	%eax, %ecx
	movl	(%ecx), %eax
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %edi
	pushl	%edi
	movl	-16(%ebp), %eax
	sall	$2, %eax
	popl	%edi
	addl	%eax, %edi
	popl	%eax
	movl	%eax, (%edi)
	movl	-16(%ebp), %eax
	movl	%eax, %edx
	movl	$1, %eax
	addl	%edx, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	jmp	.L524
.L523:
	movl	nil, %eax
.L526:
	movl	-16(%ebp), %eax
	movl	%eax, %ecx
	movl	8(%ebp), %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L525
	movl	$__base_vtable, %eax
	movl	%eax, %edi
	pushl	%edi
	movl	-16(%ebp), %eax
	sall	$2, %eax
	popl	%edi
	addl	%eax, %edi
	movl	(%edi), %eax
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %edx
	pushl	%edx
	movl	-16(%ebp), %eax
	sall	$2, %eax
	popl	%edx
	addl	%eax, %edx
	popl	%eax
	movl	%eax, (%edx)
	movl	-16(%ebp), %eax
	movl	%eax, %ecx
	movl	$1, %eax
	addl	%ecx, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	jmp	.L526
.L525:
	movl	nil, %eax
	movl	20(%ebp), %eax
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %edi
	popl	%eax
	movl	%eax, (%edi)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %edx
	addl	$12, %edx
	popl	%eax
	movl	%eax, (%edx)
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	addl	$16, %ecx
	movl	$0, (%ecx)
	# if: [:eq, :superclass, 0]
	movl	12(%ebp), %eax
	movl	%eax, %edi
	movl	$0, %eax
	cmpl	%eax, %edi
	sete	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L527_else
	# then: [:assign, [:index, :ob, 5], 0]
	movl	-12(%ebp), %eax
	movl	%eax, %edx
	addl	$20, %edx
	movl	$0, (%edx)
	jmp	.L528_endif
	# else: [:do, [:assign, [:index, :ob, 5], [:index, :superclass, 4]], [:assign, [:index, :superclass, 4], :ob]]
.L527_else:
	movl	12(%ebp), %eax
	movl	%eax, %ecx
	addl	$16, %ecx
	movl	(%ecx), %eax
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %edi
	addl	$20, %edi
	popl	%eax
	movl	%eax, (%edi)
	movl	-12(%ebp), %eax
	pushl	%eax
	movl	12(%ebp), %eax
	movl	%eax, %edx
	addl	$16, %edx
	popl	%eax
	movl	%eax, (%edx)
.L528_endif:
	movl	-12(%ebp), %eax
	addl	$16, %esp
	# Reloading self if evicted:
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	leave	
	ret	
	.size	__new_class_object, .-__new_class_object
.Lscope9:
	.stabs  "",36,0,0,.Lscope9-.LFBB9	
		
	########################################################################	
		
		
		
		
		
		
		
	############################# __set_vtable #############################	
		
	.stabs  "__set_vtable:F(0,0)",36,0,0,__set_vtable	
.globl __set_vtable
	.type	__set_vtable, @function
__set_vtable:
.LFBB10:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# METHOD BODY:
	subl	$12, %esp
	addl	$3, %ebx
	movl	8(%ebp), %eax
	movl	%eax, %ecx
	addl	$16, %ecx
	movl	(%ecx), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
.L531:
	movl	-12(%ebp), %eax
	testl	%eax, %eax
	je	.L530
	# if: [:eq, [:index, :p, :off], [:index, :vtable, :off]]
	movl	-12(%ebp), %eax
	movl	%eax, %edi
	pushl	%edi
	movl	12(%ebp), %eax
	sall	$2, %eax
	popl	%edi
	addl	%eax, %edi
	movl	(%edi), %eax
	movl	%eax, %edx
	movl	8(%ebp), %eax
	movl	%eax, %ecx
	pushl	%ecx
	movl	12(%ebp), %eax
	sall	$2, %eax
	popl	%ecx
	addl	%eax, %ecx
	movl	(%ecx), %eax
	cmpl	%eax, %edx
	sete	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L532_else
	# then: [:__set_vtable, :p, :off, :ptr]
	subl	$28, %esp
	movl	-12(%ebp), %eax
	movl	%eax, (%esp)
	movl	12(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	__set_vtable
	addl	$28, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	# else: nil
.L532_else:
	movl	-12(%ebp), %eax
	movl	%eax, %edi
	addl	$20, %edi
	movl	(%edi), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	jmp	.L531
.L530:
	movl	nil, %eax
	movl	16(%ebp), %eax
	pushl	%eax
	movl	8(%ebp), %eax
	movl	%eax, %ecx
	pushl	%ecx
	movl	12(%ebp), %eax
	sall	$2, %eax
	popl	%ecx
	addl	%eax, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	addl	$12, %esp
	# Reloading self if evicted:
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	leave	
	ret	
	.size	__set_vtable, .-__set_vtable
.Lscope10:
	.stabs  "",36,0,0,.Lscope10-.LFBB10	
		
	########################################################################	
		
		
		
		
		
		
		
	##################### __method_Class___initialize ######################	
		
	.stabs  "__method_Class___initialize:F(0,0)",36,0,0,__method_Class___initialize	
.globl __method_Class___initialize
	.type	__method_Class___initialize, @function
__method_Class___initialize:
.LFBB11:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L535_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Class___initialize", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L534, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L535_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L538_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Class___initialize", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L534, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L538_else:
	# METHOD BODY:
	.stabn  68,0,83,.LM421	
.LM421:
	movl	nil, %eax
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Class___initialize, .-__method_Class___initialize
.Lscope11:
	.stabs  "",36,0,0,.Lscope11-.LFBB11	
		
	########################################################################	
		
		
		
		
		
		
		
	####################### __method_Class_allocate ########################	
		
	.stabs  "__method_Class_allocate:F(0,0)",36,0,0,__method_Class_allocate	
.globl __method_Class_allocate
	.type	__method_Class_allocate, @function
__method_Class_allocate:
.LFBB12:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L542_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Class_allocate", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L541, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L542_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L544_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Class_allocate", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L541, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L544_else:
	# METHOD BODY:
	.stabn  68,0,89,.LM422	
.LM422:
	subl	$16, %esp
	addl	$4, %ebx
	.stabn  68,0,90,.LM423	
.LM423:
	subl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__array
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# if: [:eq, :ob, 0]
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	# Locked register ecx
	movl	$0, %eax
	cmpl	%eax, %ecx
	sete	%al
	movzbl	%al, %eax
	# Unlocked register ecx
	testl	%eax, %eax
	je	.L546_else
	# then: [:do, [:printf, "FATAL: Failed to allocate object of size %ld, class %s\n", [:mul, 4, :@instance_size], [:index, :self, 2]], [:div, 0, 0]]
	subl	$28, %esp
	movl	$.L547, %eax
	movl	%eax, (%esp)
	movl	$4, %edi
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	imull	%edi, %eax
	movl	%eax, 4(%esp)
	movl	%esi, %edx
	addl	$8, %edx
	movl	(%edx), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	printf
	addl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$0
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L546_else:
	.stabn  68,0,94,.LM424	
.LM424:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%esi
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	movl	%edi, %eax
	addl	$16, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Class_allocate, .-__method_Class_allocate
.Lscope12:
	.stabs  "",36,0,0,.Lscope12-.LFBB12	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Class___new #########################	
		
	.stabs  "__method_Class___new:F(0,0)",36,0,0,__method_Class___new	
.globl __method_Class___new
	.type	__method_Class___new, @function
__method_Class___new:
.LFBB13:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L550_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Class___new", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L549, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L550_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L552_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Class___new", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L549, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L552_else:
	# METHOD BODY:
	.stabn  68,0,103,.LM425	
.LM425:
	subl	$12, %esp
	addl	$3, %ebx
	.stabn  68,0,104,.LM426	
.LM426:
	# callm :self.:allocate
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__allocate(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.allocate END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# callm :ob.:__initialize
	subl	$24, %esp
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____initialize(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm ob.__initialize END
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, %eax
	addl	$12, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Class___new, .-__method_Class___new
.Lscope13:
	.stabs  "",36,0,0,.Lscope13-.LFBB13	
		
	########################################################################	
		
		
		
		
		
		
		
	########################## __method_Class_new ##########################	
		
	.stabs  "__method_Class_new:F(0,0)",36,0,0,__method_Class_new	
.globl __method_Class_new
	.type	__method_Class_new, @function
__method_Class_new:
.LFBB14:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L555_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Class_new", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L554, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L555_else:
	# METHOD BODY:
	.stabn  68,0,109,.LM427	
.LM427:
	subl	$16, %esp
	addl	$4, %ebx
	subl	$24, %esp
	leal	16(%ebp), %eax
	movl	%eax, (%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$0, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	call	__splat_to_Array
	addl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	.stabn  68,0,110,.LM428	
.LM428:
	# callm :self.:allocate
	subl	$24, %esp
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__allocate(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.allocate END
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	# callm :ob.:initialize
	# BEGIN Calculating argument count for splat
	# [:lvar, 3, :ecx]
	movl	-20(%ebp), %ecx
	movl	%ecx, %edx
	addl	$4, %edx
	movl	(%edx), %eax
	movl	%eax, %edi
	movl	$2, %eax
	addl	%edi, %eax
	movl	%eax, %ebx
	# END Calculating argument count for splat; numargs is now in ebx
	# Moving stack pointer to start of argument array:
	imull	$4, %eax
	subl	%eax, %esp
	# BEGIN Pushing arguments:
	movl	%esp, %edx
	pushl	%ebx
	# BEGIN args.each do |a|
	# [:lvar, 2, :edi]
	movl	-16(%ebp), %edi
	movl	%edi, (%edx)
	addl	$4, %edx
	movl	$0, (%edx)
	addl	$4, %edx
	# SPLAT
	movl	-20(%ebp), %eax
	addl	$4, %eax
	movl	(%eax), %ecx
	addl	$4, %eax
	movl	(%eax), %eax
	testl	%eax, %eax
	je	.L557
.L559:
	testl	%ecx, %ecx
	je	.L558
	pushl	(%eax)
	popl	(%edx)
	addl	$4, %eax
	addl	$4, %edx
	subl	$1, %ecx
	jmp	.L559
.L558:
.L557:
	# END args.each
	popl	%ebx
	# END Pushing arguments
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__initialize(%eax)
	# Evicting self
	# Re-adjusting stack post-call:
	imull	$4, %ebx
	addl	%ebx, %esp
	# callm ob.initialize END
	# [:lvar, 2, :edi]
	movl	-16(%ebp), %edi
	movl	%edi, %eax
	addl	$16, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Class_new, .-__method_Class_new
.Lscope14:
	.stabs  "",36,0,0,.Lscope14-.LFBB14	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Class_name ##########################	
		
	.stabs  "__method_Class_name:F(0,0)",36,0,0,__method_Class_name	
.globl __method_Class_name
	.type	__method_Class_name, @function
__method_Class_name:
.LFBB15:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L561_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Class_name", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L560, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L561_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L563_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Class_name", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L560, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L563_else:
	# METHOD BODY:
	.stabn  68,0,115,.LM429	
.LM429:
	.stabn  68,0,116,.LM430	
.LM430:
	subl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	8(%esi), %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Class_name, .-__method_Class_name
.Lscope15:
	.stabs  "",36,0,0,.Lscope15-.LFBB15	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Class_to_s ##########################	
		
	.stabs  "__method_Class_to_s:F(0,0)",36,0,0,__method_Class_to_s	
.globl __method_Class_to_s
	.type	__method_Class_to_s, @function
__method_Class_to_s:
.LFBB16:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L566_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Class_to_s", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L565, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L566_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L568_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Class_to_s", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L565, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L568_else:
	# METHOD BODY:
	.stabn  68,0,119,.LM431	
.LM431:
	# callm :self.:name
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__name(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.name END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Class_to_s, .-__method_Class_to_s
.Lscope16:
	.stabs  "",36,0,0,.Lscope16-.LFBB16	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Class_inspect ########################	
		
	.stabs  "__method_Class_inspect:F(0,0)",36,0,0,__method_Class_inspect	
.globl __method_Class_inspect
	.type	__method_Class_inspect, @function
__method_Class_inspect:
.LFBB17:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L571_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Class_inspect", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L570, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L571_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L573_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Class_inspect", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L570, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L573_else:
	# METHOD BODY:
	.stabn  68,0,123,.LM432	
.LM432:
	# callm :self.:name
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__name(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.name END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Class_inspect, .-__method_Class_inspect
.Lscope17:
	.stabs  "",36,0,0,.Lscope17-.LFBB17	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Class___X__3d ########################	
		
	.stabs  "__method_Class___X__3d:F(0,0)",36,0,0,__method_Class___X__3d	
.globl __method_Class___X__3d
	.type	__method_Class___X__3d, @function
__method_Class___X__3d:
.LFBB18:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L576_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Class___X__3d", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L575, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L576_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L578_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Class___X__3d", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L575, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L578_else:
	# METHOD BODY:
	.stabn  68,0,127,.LM433	
.LM433:
	.stabn  68,0,128,.LM434	
.LM434:
	# callm [:callm, :self, :==, [:other]].:!
	subl	$24, %esp
	# callm :self.:==
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.== END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____X(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :self, :==, [:other]].! END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Class___X__3d, .-__method_Class___X__3d
.Lscope18:
	.stabs  "",36,0,0,.Lscope18-.LFBB18	
		
	########################################################################	
		
		
		
		
		
		
		
	###################### __method_Class_superclass #######################	
		
	.stabs  "__method_Class_superclass:F(0,0)",36,0,0,__method_Class_superclass	
.globl __method_Class_superclass
	.type	__method_Class_superclass, @function
__method_Class_superclass:
.LFBB19:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L581_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Class_superclass", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L580, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L581_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L583_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Class_superclass", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L580, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L583_else:
	# METHOD BODY:
	.stabn  68,0,135,.LM435	
.LM435:
	.stabn  68,0,136,.LM436	
.LM436:
	# if: [:index, :self, 3]
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, %edi
	addl	$12, %edi
	movl	(%edi), %eax
	testl	%eax, %eax
	je	.L585_else
	# then: [:index, :self, 3]
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, %ecx
	addl	$12, %ecx
	movl	(%ecx), %eax
	jmp	.L586_endif
	# else: :Object
.L585_else:
	movl	Object, %eax
.L586_endif:
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Class_superclass, .-__method_Class_superclass
.Lscope19:
	.stabs  "",36,0,0,.Lscope19-.LFBB19	
		
	########################################################################	
		
		
		
		
		
		
		
	##################### __method_Class_define_method #####################	
		
	.stabs  "__method_Class_define_method:F(0,0)",36,0,0,__method_Class_define_method	
.globl __method_Class_define_method
	.type	__method_Class_define_method, @function
__method_Class_define_method:
.LFBB20:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$3, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L588_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Class_define_method", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L587, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L588_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L590_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Class_define_method", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L587, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L590_else:
	# METHOD BODY:
	.stabn  68,0,150,.LM437	
.LM437:
	.stabn  68,0,151,.LM438	
.LM438:
	subl	$24, %esp
	movl	$.L592, %eax
	movl	%eax, (%esp)
	# callm [:callm, :sym, :to_s].:__get_raw
	subl	$24, %esp
	# callm :sym.:to_s
	subl	$24, %esp
	movl	16(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm sym.to_s END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____get_raw(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :sym, :to_s].__get_raw END
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	call	printf
	addl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Class_define_method, .-__method_Class_define_method
.Lscope20:
	.stabs  "",36,0,0,.Lscope20-.LFBB20	
		
	########################################################################	
		
		
		
		
		
		
		
	##################### __method_Class_attr_accessor #####################	
		
	.stabs  "__method_Class_attr_accessor:F(0,0)",36,0,0,__method_Class_attr_accessor	
.globl __method_Class_attr_accessor
	.type	__method_Class_attr_accessor, @function
__method_Class_attr_accessor:
.LFBB21:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L594_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Class_attr_accessor", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L593, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L594_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L596_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Class_attr_accessor", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L593, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L596_else:
	# METHOD BODY:
	.stabn  68,0,155,.LM439	
.LM439:
	.stabn  68,0,156,.LM440	
.LM440:
	# callm :self.:attr_reader
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__attr_reader(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.attr_reader END
	# callm :self.:attr_writer
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__attr_writer(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.attr_writer END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Class_attr_accessor, .-__method_Class_attr_accessor
.Lscope21:
	.stabs  "",36,0,0,.Lscope21-.LFBB21	
		
	########################################################################	
		
		
		
		
		
		
		
	###################### __method_Class_attr_reader ######################	
		
	.stabs  "__method_Class_attr_reader:F(0,0)",36,0,0,__method_Class_attr_reader	
.globl __method_Class_attr_reader
	.type	__method_Class_attr_reader, @function
__method_Class_attr_reader:
.LFBB22:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L599_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Class_attr_reader", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L598, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L599_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L601_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Class_attr_reader", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L598, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L601_else:
	# METHOD BODY:
	.stabn  68,0,160,.LM441	
.LM441:
	subl	$16, %esp
	addl	$4, %ebx
	subl	$20, %esp
	movl	$8, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	.stabn  68,0,161,.LM442	
.LM442:
	subl	$24, %esp
	movl	$.L603, %eax
	movl	%eax, (%esp)
	# callm [:callm, :sym, :to_s].:__get_raw
	subl	$24, %esp
	# callm :sym.:to_s
	subl	$24, %esp
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm sym.to_s END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____get_raw(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :sym, :to_s].__get_raw END
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	call	printf
	addl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	# callm :self.:define_method
	subl	$28, %esp
	movl	%esi, (%esp)
	.stabn  68,0,162,.LM443	
.LM443:
	# Stack frame
	pushl	%ebp
	movl	-12(%ebp), %eax
	movl	%eax, %edx
	popl	%eax
	movl	%eax, (%edx)
	movl	$__lambda_L64, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	subl	$32, %esp
	movl	-16(%ebp), %eax
	movl	%eax, (%esp)
	movl	-12(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%esi, 8(%esp)
	movl	$0, 12(%esp)
	movl	$4, %ebx
	call	__new_proc
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 4(%esp)
	# [:arg, 2, :ecx]
	movl	16(%ebp), %ecx
	movl	%ecx, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__define_method(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.define_method END
	addl	$16, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Class_attr_reader, .-__method_Class_attr_reader
.Lscope22:
	.stabs  "",36,0,0,.Lscope22-.LFBB22	
		
	########################################################################	
		
		
		
		
		
		
		
	###################### __method_Class_attr_writer ######################	
		
	.stabs  "__method_Class_attr_writer:F(0,0)",36,0,0,__method_Class_attr_writer	
.globl __method_Class_attr_writer
	.type	__method_Class_attr_writer, @function
__method_Class_attr_writer:
.LFBB23:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L606_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Class_attr_writer", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L605, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L606_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L608_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Class_attr_writer", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L605, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L608_else:
	# METHOD BODY:
	.stabn  68,0,168,.LM444	
.LM444:
	subl	$16, %esp
	addl	$4, %ebx
	subl	$20, %esp
	movl	$8, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	.stabn  68,0,169,.LM445	
.LM445:
	subl	$24, %esp
	movl	$.L610, %eax
	movl	%eax, (%esp)
	# callm [:callm, :sym, :to_s].:__get_raw
	subl	$24, %esp
	# callm :sym.:to_s
	subl	$24, %esp
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm sym.to_s END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____get_raw(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :sym, :to_s].__get_raw END
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	call	printf
	addl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	# callm :self.:define_method
	subl	$28, %esp
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	# callm [:callm, [:callm, [:callm, [:sexp, [:call, :__get_string, :".L0"]], :to_s], :concat, [[:callm, [:callm, :sym, :to_s], :to_s]]], :concat, [[:callm, [:sexp, [:call, :__get_string, :".L1"]], :to_s]]].:to_sym
	subl	$24, %esp
	# callm [:callm, [:callm, [:sexp, [:call, :__get_string, :".L0"]], :to_s], :concat, [[:callm, [:callm, :sym, :to_s], :to_s]]].:concat
	subl	$28, %esp
	# callm [:callm, [:sexp, [:call, :__get_string, :".L0"]], :to_s].:concat
	subl	$28, %esp
	# callm [:sexp, [:call, :__get_string, :".L0"]].:to_s
	subl	$24, %esp
	subl	$20, %esp
	movl	$.L0, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:sexp, [:call, :__get_string, :".L0"]].to_s END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm [:callm, :sym, :to_s].:to_s
	subl	$24, %esp
	.stabn  68,0,172,.LM446	
.LM446:
	# callm :sym.:to_s
	subl	$24, %esp
	# [:arg, 2, :edx]
	movl	16(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm sym.to_s END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :sym, :to_s].to_s END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__concat(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:sexp, [:call, :__get_string, :".L0"]], :to_s].concat END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm [:sexp, [:call, :__get_string, :".L1"]].:to_s
	subl	$24, %esp
	subl	$20, %esp
	movl	$.L1, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:sexp, [:call, :__get_string, :".L1"]].to_s END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__concat(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:callm, [:sexp, [:call, :__get_string, :".L0"]], :to_s], :concat, [[:callm, [:callm, :sym, :to_s], :to_s]]].concat END
	movl	%eax, (%esp)
	# Stack frame
	pushl	%ebp
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	movl	$__lambda_L65, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	subl	$32, %esp
	movl	-16(%ebp), %eax
	movl	%eax, (%esp)
	movl	-12(%ebp), %eax
	movl	%eax, 4(%esp)
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, 8(%esp)
	movl	$1, 12(%esp)
	movl	$4, %ebx
	call	__new_proc
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_sym(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:callm, [:callm, [:sexp, [:call, :__get_string, :".L0"]], :to_s], :concat, [[:callm, [:callm, :sym, :to_s], :to_s]]], :concat, [[:callm, [:sexp, [:call, :__get_string, :".L1"]], :to_s]]].to_sym END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	(%esi), %eax
	call	*__voff__define_method(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.define_method END
	addl	$16, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Class_attr_writer, .-__method_Class_attr_writer
.Lscope23:
	.stabs  "",36,0,0,.Lscope23-.LFBB23	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Kernel_puts #########################	
		
	.stabs  "__method_Kernel_puts:F(0,0)",36,0,0,__method_Kernel_puts	
.globl __method_Kernel_puts
	.type	__method_Kernel_puts, @function
__method_Kernel_puts:
.LFBB24:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L613_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Kernel_puts", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L612, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L613_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L615_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Kernel_puts", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L612, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L615_else:
	# METHOD BODY:
	.stabn  68,0,3,.LM447	
.LM447:
	.stabn  68,0,4,.LM448	
.LM448:
	subl	$20, %esp
	movl	16(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	movl	(%ecx), %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	puts
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Kernel_puts, .-__method_Kernel_puts
.Lscope24:
	.stabs  "",36,0,0,.Lscope24-.LFBB24	
		
	########################################################################	
		
		
		
		
		
		
		
	###################### __method_Object_initialize ######################	
		
	.stabs  "__method_Object_initialize:F(0,0)",36,0,0,__method_Object_initialize	
.globl __method_Object_initialize
	.type	__method_Object_initialize, @function
__method_Object_initialize:
.LFBB25:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L618_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Object_initialize", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L617, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L618_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L620_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Object_initialize", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L617, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L620_else:
	# METHOD BODY:
	.stabn  68,0,14,.LM449	
.LM449:
	movl	nil, %eax
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Object_initialize, .-__method_Object_initialize
.Lscope25:
	.stabs  "",36,0,0,.Lscope25-.LFBB25	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Object_class #########################	
		
	.stabs  "__method_Object_class:F(0,0)",36,0,0,__method_Object_class	
.globl __method_Object_class
	.type	__method_Object_class, @function
__method_Object_class:
.LFBB26:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L623_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Object_class", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L622, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L623_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L625_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Object_class", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L622, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L625_else:
	# METHOD BODY:
	.stabn  68,0,18,.LM450	
.LM450:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	0(%esi), %eax
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Object_class, .-__method_Object_class
.Lscope26:
	.stabs  "",36,0,0,.Lscope26-.LFBB26	
		
	########################################################################	
		
		
		
		
		
		
		
	###################### __method_Object_object_id #######################	
		
	.stabs  "__method_Object_object_id:F(0,0)",36,0,0,__method_Object_object_id	
.globl __method_Object_object_id
	.type	__method_Object_object_id, @function
__method_Object_object_id:
.LFBB27:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L628_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Object_object_id", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L627, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L628_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L630_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Object_object_id", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L627, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L630_else:
	# METHOD BODY:
	.stabn  68,0,22,.LM451	
.LM451:
	.stabn  68,0,23,.LM452	
.LM452:
	subl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$1, %ebx
	call	__int
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Object_object_id, .-__method_Object_object_id
.Lscope27:
	.stabs  "",36,0,0,.Lscope27-.LFBB27	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Object_hash #########################	
		
	.stabs  "__method_Object_hash:F(0,0)",36,0,0,__method_Object_hash	
.globl __method_Object_hash
	.type	__method_Object_hash, @function
__method_Object_hash:
.LFBB28:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L633_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Object_hash", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L632, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L633_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L635_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Object_hash", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L632, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L635_else:
	# METHOD BODY:
	.stabn  68,0,26,.LM453	
.LM453:
	# callm :self.:object_id
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__object_id(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.object_id END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Object_hash, .-__method_Object_hash
.Lscope28:
	.stabs  "",36,0,0,.Lscope28-.LFBB28	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Object_eql__Q ########################	
		
	.stabs  "__method_Object_eql__Q:F(0,0)",36,0,0,__method_Object_eql__Q	
.globl __method_Object_eql__Q
	.type	__method_Object_eql__Q, @function
__method_Object_eql__Q:
.LFBB29:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L638_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Object_eql__Q", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L637, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L638_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L640_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Object_eql__Q", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L637, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L640_else:
	# METHOD BODY:
	.stabn  68,0,30,.LM454	
.LM454:
	.stabn  68,0,31,.LM455	
.LM455:
	# callm :self.:==
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.== END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Object_eql__Q, .-__method_Object_eql__Q
.Lscope29:
	.stabs  "",36,0,0,.Lscope29-.LFBB29	
		
	########################################################################	
		
		
		
		
		
		
		
	####################### __method_Object___eq__3d #######################	
		
	.stabs  "__method_Object___eq__3d:F(0,0)",36,0,0,__method_Object___eq__3d	
.globl __method_Object___eq__3d
	.type	__method_Object___eq__3d, @function
__method_Object___eq__3d:
.LFBB30:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L643_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Object___eq__3d", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L642, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L643_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L645_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Object___eq__3d", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L642, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L645_else:
	# METHOD BODY:
	.stabn  68,0,34,.LM456	
.LM456:
	.stabn  68,0,35,.LM457	
.LM457:
	# callm :self.:==
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.== END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Object___eq__3d, .-__method_Object___eq__3d
.Lscope30:
	.stabs  "",36,0,0,.Lscope30-.LFBB30	
		
	########################################################################	
		
		
		
		
		
		
		
	####################### __method_Object_inspect ########################	
		
	.stabs  "__method_Object_inspect:F(0,0)",36,0,0,__method_Object_inspect	
.globl __method_Object_inspect
	.type	__method_Object_inspect, @function
__method_Object_inspect:
.LFBB31:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L648_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Object_inspect", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L647, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L648_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L650_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Object_inspect", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L647, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L650_else:
	# METHOD BODY:
	.stabn  68,0,38,.LM458	
.LM458:
	subl	$12, %esp
	addl	$3, %ebx
	.stabn  68,0,39,.LM459	
.LM459:
	subl	$20, %esp
	movl	$20, (%esp)
	movl	$1, %ebx
	call	__alloc_leaf
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	subl	$32, %esp
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$20, 4(%esp)
	movl	$.L652, %eax
	movl	%eax, 8(%esp)
	movl	%esi, 12(%esp)
	movl	$4, %ebx
	call	snprintf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	.stabn  68,0,40,.LM460	
.LM460:
	subl	$20, %esp
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	.stabn  68,0,41,.LM461	
.LM461:
	# callm [:callm, [:callm, [:callm, [:callm, [:sexp, [:call, :__get_string, :".L2"]], :to_s], :concat, [[:callm, [:callm, [:callm, :self, :class], :name], :to_s]]], :concat, [[:callm, [:sexp, [:call, :__get_string, :".L3"]], :to_s]]], :concat, [[:callm, :buf, :to_s]]].:concat
	subl	$28, %esp
	# callm [:callm, [:callm, [:callm, [:sexp, [:call, :__get_string, :".L2"]], :to_s], :concat, [[:callm, [:callm, [:callm, :self, :class], :name], :to_s]]], :concat, [[:callm, [:sexp, [:call, :__get_string, :".L3"]], :to_s]]].:concat
	subl	$28, %esp
	# callm [:callm, [:callm, [:sexp, [:call, :__get_string, :".L2"]], :to_s], :concat, [[:callm, [:callm, [:callm, :self, :class], :name], :to_s]]].:concat
	subl	$28, %esp
	# callm [:callm, [:sexp, [:call, :__get_string, :".L2"]], :to_s].:concat
	subl	$28, %esp
	# callm [:sexp, [:call, :__get_string, :".L2"]].:to_s
	subl	$24, %esp
	subl	$20, %esp
	movl	$.L2, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:sexp, [:call, :__get_string, :".L2"]].to_s END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm [:callm, [:callm, :self, :class], :name].:to_s
	subl	$24, %esp
	.stabn  68,0,42,.LM462	
.LM462:
	# callm [:callm, :self, :class].:name
	subl	$24, %esp
	# callm :self.:class
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__class(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.class END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__name(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :self, :class].name END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:callm, :self, :class], :name].to_s END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__concat(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:sexp, [:call, :__get_string, :".L2"]], :to_s].concat END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm [:sexp, [:call, :__get_string, :".L3"]].:to_s
	subl	$24, %esp
	subl	$20, %esp
	movl	$.L3, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:sexp, [:call, :__get_string, :".L3"]].to_s END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__concat(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:callm, [:sexp, [:call, :__get_string, :".L2"]], :to_s], :concat, [[:callm, [:callm, [:callm, :self, :class], :name], :to_s]]].concat END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :buf.:to_s
	subl	$24, %esp
	# [:lvar, 1, :edx]
	movl	-12(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm buf.to_s END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__concat(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:callm, [:callm, [:sexp, [:call, :__get_string, :".L2"]], :to_s], :concat, [[:callm, [:callm, [:callm, :self, :class], :name], :to_s]]], :concat, [[:callm, [:sexp, [:call, :__get_string, :".L3"]], :to_s]]].concat END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm [:sexp, [:call, :__get_string, :".L4"]].:to_s
	subl	$24, %esp
	subl	$20, %esp
	movl	$.L4, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:sexp, [:call, :__get_string, :".L4"]].to_s END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__concat(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:callm, [:callm, [:callm, [:sexp, [:call, :__get_string, :".L2"]], :to_s], :concat, [[:callm, [:callm, [:callm, :self, :class], :name], :to_s]]], :concat, [[:callm, [:sexp, [:call, :__get_string, :".L3"]], :to_s]]], :concat, [[:callm, :buf, :to_s]]].concat END
	addl	$12, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Object_inspect, .-__method_Object_inspect
.Lscope31:
	.stabs  "",36,0,0,.Lscope31-.LFBB31	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Object_to_s #########################	
		
	.stabs  "__method_Object_to_s:F(0,0)",36,0,0,__method_Object_to_s	
.globl __method_Object_to_s
	.type	__method_Object_to_s, @function
__method_Object_to_s:
.LFBB32:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L654_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Object_to_s", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L653, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L654_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L656_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Object_to_s", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L653, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L656_else:
	# METHOD BODY:
	.stabn  68,0,45,.LM463	
.LM463:
	# callm :self.:inspect
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__inspect(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.inspect END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Object_to_s, .-__method_Object_to_s
.Lscope32:
	.stabs  "",36,0,0,.Lscope32-.LFBB32	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Object___eq #########################	
		
	.stabs  "__method_Object___eq:F(0,0)",36,0,0,__method_Object___eq	
.globl __method_Object___eq
	.type	__method_Object___eq, @function
__method_Object___eq:
.LFBB33:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L659_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Object___eq", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L658, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L659_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L661_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Object___eq", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L658, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L661_else:
	# METHOD BODY:
	.stabn  68,0,49,.LM464	
.LM464:
	.stabn  68,0,50,.LM465	
.LM465:
	# callm :object_id.:==
	subl	$28, %esp
	# callm :self.:object_id
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__object_id(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.object_id END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :other.:object_id
	subl	$24, %esp
	movl	16(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__object_id(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm other.object_id END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm object_id.== END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Object___eq, .-__method_Object___eq
.Lscope33:
	.stabs  "",36,0,0,.Lscope33-.LFBB33	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Object___X ##########################	
		
	.stabs  "__method_Object___X:F(0,0)",36,0,0,__method_Object___X	
.globl __method_Object___X
	.type	__method_Object___X, @function
__method_Object___X:
.LFBB34:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L664_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Object___X", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L663, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L664_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L666_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Object___X", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L663, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L666_else:
	# METHOD BODY:
	.stabn  68,0,53,.LM466	
.LM466:
	movl	false, %eax
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Object___X, .-__method_Object___X
.Lscope34:
	.stabs  "",36,0,0,.Lscope34-.LFBB34	
		
	########################################################################	
		
		
		
		
		
		
		
	####################### __method_Object___X__3d ########################	
		
	.stabs  "__method_Object___X__3d:F(0,0)",36,0,0,__method_Object___X__3d	
.globl __method_Object___X__3d
	.type	__method_Object___X__3d, @function
__method_Object___X__3d:
.LFBB35:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L669_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Object___X__3d", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L668, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L669_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L671_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Object___X__3d", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L668, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L671_else:
	# METHOD BODY:
	.stabn  68,0,57,.LM467	
.LM467:
	.stabn  68,0,58,.LM468	
.LM468:
	# callm [:callm, :self, :==, [:other]].:!
	subl	$24, %esp
	# callm :self.:==
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.== END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____X(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :self, :==, [:other]].! END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Object___X__3d, .-__method_Object___X__3d
.Lscope35:
	.stabs  "",36,0,0,.Lscope35-.LFBB35	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Object_nil__Q ########################	
		
	.stabs  "__method_Object_nil__Q:F(0,0)",36,0,0,__method_Object_nil__Q	
.globl __method_Object_nil__Q
	.type	__method_Object_nil__Q, @function
__method_Object_nil__Q:
.LFBB36:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L674_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Object_nil__Q", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L673, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L674_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L676_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Object_nil__Q", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L673, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L676_else:
	# METHOD BODY:
	.stabn  68,0,61,.LM469	
.LM469:
	movl	false, %eax
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Object_nil__Q, .-__method_Object_nil__Q
.Lscope36:
	.stabs  "",36,0,0,.Lscope36-.LFBB36	
		
	########################################################################	
		
		
		
		
		
		
		
	#################### __method_Object_method_missing ####################	
		
	.stabs  "__method_Object_method_missing:F(0,0)",36,0,0,__method_Object_method_missing	
.globl __method_Object_method_missing
	.type	__method_Object_method_missing, @function
__method_Object_method_missing:
.LFBB37:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L679_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Object_method_missing", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L678, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L679_else:
	# METHOD BODY:
	.stabn  68,0,65,.LM470	
.LM470:
	subl	$16, %esp
	addl	$4, %ebx
	subl	$24, %esp
	leal	20(%ebp), %eax
	movl	%eax, (%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$1, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	call	__splat_to_Array
	addl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	.stabn  68,0,66,.LM471	
.LM471:
	# callm [:callm, :self, :class].:inspect
	subl	$24, %esp
	# callm :self.:class
	subl	$24, %esp
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__class(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.class END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__inspect(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :self, :class].inspect END
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	# callm :self.:puts
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	# callm [:callm, [:callm, [:callm, [:sexp, [:call, :__get_string, :".L5"]], :to_s], :concat, [[:callm, :cname, :to_s]]], :concat, [[:callm, [:sexp, [:call, :__get_string, :".L6"]], :to_s]]].:concat
	subl	$28, %esp
	# callm [:callm, [:callm, [:sexp, [:call, :__get_string, :".L5"]], :to_s], :concat, [[:callm, :cname, :to_s]]].:concat
	subl	$28, %esp
	# callm [:callm, [:sexp, [:call, :__get_string, :".L5"]], :to_s].:concat
	subl	$28, %esp
	# callm [:sexp, [:call, :__get_string, :".L5"]].:to_s
	subl	$24, %esp
	subl	$20, %esp
	movl	$.L5, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:sexp, [:call, :__get_string, :".L5"]].to_s END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :cname.:to_s
	subl	$24, %esp
	# [:lvar, 2, :ecx]
	movl	-16(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm cname.to_s END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__concat(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:sexp, [:call, :__get_string, :".L5"]], :to_s].concat END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm [:sexp, [:call, :__get_string, :".L6"]].:to_s
	subl	$24, %esp
	subl	$20, %esp
	movl	$.L6, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:sexp, [:call, :__get_string, :".L6"]].to_s END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__concat(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:callm, [:sexp, [:call, :__get_string, :".L5"]], :to_s], :concat, [[:callm, :cname, :to_s]]].concat END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm [:callm, :sym, :to_s].:to_s
	subl	$24, %esp
	.stabn  68,0,67,.LM472	
.LM472:
	# callm :sym.:to_s
	subl	$24, %esp
	movl	16(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm sym.to_s END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :sym, :to_s].to_s END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__concat(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:callm, [:callm, [:sexp, [:call, :__get_string, :".L5"]], :to_s], :concat, [[:callm, :cname, :to_s]]], :concat, [[:callm, [:sexp, [:call, :__get_string, :".L6"]], :to_s]]].concat END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	(%esi), %eax
	call	*__voff__puts(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.puts END
	pushl	$0
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	addl	$16, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Object_method_missing, .-__method_Object_method_missing
.Lscope37:
	.stabs  "",36,0,0,.Lscope37-.LFBB37	
		
	########################################################################	
		
		
		
		
		
		
		
	#################### __method_Object_respond_to__Q #####################	
		
	.stabs  "__method_Object_respond_to__Q:F(0,0)",36,0,0,__method_Object_respond_to__Q	
.globl __method_Object_respond_to__Q
	.type	__method_Object_respond_to__Q, @function
__method_Object_respond_to__Q:
.LFBB38:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L682_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Object_respond_to__Q", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L681, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L682_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L684_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Object_respond_to__Q", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L681, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L684_else:
	# METHOD BODY:
	.stabn  68,0,71,.LM473	
.LM473:
	subl	$24, %esp
	addl	$6, %ebx
	.stabn  68,0,74,.LM474	
.LM474:
	# callm :Class.:method_to_voff
	subl	$24, %esp
	movl	Class, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__method_to_voff(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm Class.method_to_voff END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# callm :m.:[]
	subl	$28, %esp
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	movl	%edi, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm m.[] END
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	.stabn  68,0,76,.LM475	
.LM475:
	# if: [:callm, :voff, :!]
	# callm :voff.:!
	subl	$24, %esp
	# [:lvar, 2, :edx]
	movl	-16(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____X(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm voff.! END
	cmpl	%eax, nil
	je	.L686_else
	cmpl	%eax, false
	je	.L686_else
	# then: [:return, :false]
	movl	false, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L686_else:
	.stabn  68,0,77,.LM476	
.LM476:
	# callm :voff.:__get_raw
	subl	$24, %esp
	# [:lvar, 2, :ecx]
	movl	-16(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____get_raw(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm voff.__get_raw END
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	.stabn  68,0,79,.LM477	
.LM477:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, %edi
	movl	(%edi), %eax
	movl	%eax, %edx
	pushl	%edx
	# [:lvar, 3, :ecx]
	movl	-20(%ebp), %ecx
	movl	%ecx, %eax
	sall	$2, %eax
	popl	%edx
	addl	%eax, %edx
	movl	(%edx), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -24(%ebp)
	.stabn  68,0,80,.LM478	
.LM478:
	# if: [:lt, :ptr, :__vtable_thunks_start]
	# [:lvar, 4, :edi]
	movl	-24(%ebp), %edi
	# Locked register edi
	movl	$__vtable_thunks_start, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	# Unlocked register edi
	testl	%eax, %eax
	je	.L688_else
	# then: [:return, :true]
	movl	true, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L688_else:
	.stabn  68,0,81,.LM479	
.LM479:
	# if: [:gt, :ptr, :__vtable_thunks_end]
	# [:lvar, 4, :edx]
	movl	-24(%ebp), %edx
	# Locked register edx
	movl	$__vtable_thunks_end, %eax
	cmpl	%eax, %edx
	setg	%al
	movzbl	%al, %eax
	# Unlocked register edx
	testl	%eax, %eax
	je	.L690_else
	# then: [:return, :true]
	movl	true, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L690_else:
	.stabn  68,0,82,.LM480	
.LM480:
	movl	false, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	addl	$24, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Object_respond_to__Q, .-__method_Object_respond_to__Q
.Lscope38:
	.stabs  "",36,0,0,.Lscope38-.LFBB38	
		
	########################################################################	
		
		
		
		
		
		
		
	####################### __method_Object_is_a__Q ########################	
		
	.stabs  "__method_Object_is_a__Q:F(0,0)",36,0,0,__method_Object_is_a__Q	
.globl __method_Object_is_a__Q
	.type	__method_Object_is_a__Q, @function
__method_Object_is_a__Q:
.LFBB39:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L693_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Object_is_a__Q", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L692, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L693_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L695_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Object_is_a__Q", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L692, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L695_else:
	# METHOD BODY:
	.stabn  68,0,92,.LM481	
.LM481:
	subl	$12, %esp
	addl	$3, %ebx
	.stabn  68,0,93,.LM482	
.LM482:
	# callm :self.:class
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__class(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.class END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
.L698:
	# if: [:ne, :k, :c]
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	# Locked register ecx
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	movl	%edi, %eax
	cmpl	%eax, %ecx
	setne	%al
	movzbl	%al, %eax
	# Unlocked register ecx
	testl	%eax, %eax
	je	.L699_else
	# then: [:ne, :k, :Object]
	# [:lvar, 1, :edx]
	movl	-12(%ebp), %edx
	# Locked register edx
	movl	Object, %eax
	cmpl	%eax, %edx
	setne	%al
	movzbl	%al, %eax
	# Unlocked register edx
	# else: nil
.L699_else:
	testl	%eax, %eax
	je	.L697
	# callm :k.:superclass
	subl	$24, %esp
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__superclass(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm k.superclass END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	jmp	.L698
.L697:
	movl	nil, %eax
	.stabn  68,0,96,.LM483	
.LM483:
	# if: [:eq, :k, :c]
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	# Locked register edi
	# [:arg, 2, :edx]
	movl	16(%ebp), %edx
	movl	%edx, %eax
	cmpl	%eax, %edi
	sete	%al
	movzbl	%al, %eax
	# Unlocked register edi
	testl	%eax, %eax
	je	.L701_else
	# then: [:return, :true]
	movl	true, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	jmp	.L702_endif
	# else: [:return, :false]
.L701_else:
	movl	false, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
.L702_endif:
	addl	$12, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Object_is_a__Q, .-__method_Object_is_a__Q
.Lscope39:
	.stabs  "",36,0,0,.Lscope39-.LFBB39	
		
	########################################################################	
		
		
		
		
		
		
		
	###################### __method_Object_kind_of__Q ######################	
		
	.stabs  "__method_Object_kind_of__Q:F(0,0)",36,0,0,__method_Object_kind_of__Q	
.globl __method_Object_kind_of__Q
	.type	__method_Object_kind_of__Q, @function
__method_Object_kind_of__Q:
.LFBB40:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L704_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Object_kind_of__Q", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L703, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L704_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L706_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Object_kind_of__Q", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L703, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L706_else:
	# METHOD BODY:
	.stabn  68,0,103,.LM484	
.LM484:
	.stabn  68,0,104,.LM485	
.LM485:
	# callm :self.:is_a?
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__is_a__Q(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.is_a? END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Object_kind_of__Q, .-__method_Object_kind_of__Q
.Lscope40:
	.stabs  "",36,0,0,.Lscope40-.LFBB40	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Object_send #########################	
		
	.stabs  "__method_Object_send:F(0,0)",36,0,0,__method_Object_send	
.globl __method_Object_send
	.type	__method_Object_send, @function
__method_Object_send:
.LFBB41:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L709_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Object_send", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L708, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L709_else:
	# METHOD BODY:
	.stabn  68,0,108,.LM486	
.LM486:
	subl	$12, %esp
	addl	$3, %ebx
	subl	$24, %esp
	leal	20(%ebp), %eax
	movl	%eax, (%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$1, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	call	__splat_to_Array
	addl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	.stabn  68,0,109,.LM487	
.LM487:
	# callm :self.:__send__
	# BEGIN Calculating argument count for splat
	# [:lvar, 2, :ecx]
	movl	-16(%ebp), %ecx
	movl	%ecx, %edx
	addl	$4, %edx
	movl	(%edx), %eax
	movl	%eax, %edi
	movl	$3, %eax
	addl	%edi, %eax
	movl	%eax, %ebx
	# END Calculating argument count for splat; numargs is now in ebx
	# Moving stack pointer to start of argument array:
	imull	$4, %eax
	subl	%eax, %esp
	# BEGIN Pushing arguments:
	movl	%esp, %edx
	pushl	%ebx
	# BEGIN args.each do |a|
	movl	%esi, (%edx)
	addl	$4, %edx
	movl	$0, (%edx)
	addl	$4, %edx
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	movl	%edi, (%edx)
	addl	$4, %edx
	# SPLAT
	movl	-16(%ebp), %eax
	addl	$4, %eax
	movl	(%eax), %ecx
	addl	$4, %eax
	movl	(%eax), %eax
	testl	%eax, %eax
	je	.L711
.L713:
	testl	%ecx, %ecx
	je	.L712
	pushl	(%eax)
	popl	(%edx)
	addl	$4, %eax
	addl	$4, %edx
	subl	$1, %ecx
	jmp	.L713
.L712:
.L711:
	# END args.each
	popl	%ebx
	# END Pushing arguments
	# Reload self?
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	(%esi), %eax
	call	*__voff____send__(%eax)
	# Evicting self
	# Re-adjusting stack post-call:
	imull	$4, %ebx
	addl	%ebx, %esp
	# callm self.__send__ END
	addl	$12, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Object_send, .-__method_Object_send
.Lscope41:
	.stabs  "",36,0,0,.Lscope41-.LFBB41	
		
	########################################################################	
		
		
		
		
		
		
		
	####################### __method_Object___send__ #######################	
		
	.stabs  "__method_Object___send__:F(0,0)",36,0,0,__method_Object___send__	
.globl __method_Object___send__
	.type	__method_Object___send__, @function
__method_Object___send__:
.LFBB42:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L715_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Object___send__", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L714, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L715_else:
	# METHOD BODY:
	.stabn  68,0,112,.LM488	
.LM488:
	subl	$12, %esp
	addl	$3, %ebx
	subl	$24, %esp
	leal	20(%ebp), %eax
	movl	%eax, (%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$1, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	call	__splat_to_Array
	addl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	.stabn  68,0,113,.LM489	
.LM489:
	# callm [:callm, :self, :class].:__send_for_obj__
	# BEGIN Calculating argument count for splat
	# [:lvar, 2, :edi]
	movl	-16(%ebp), %edi
	movl	%edi, %edx
	addl	$4, %edx
	movl	(%edx), %eax
	movl	%eax, %ecx
	movl	$4, %eax
	addl	%ecx, %eax
	movl	%eax, %ebx
	# END Calculating argument count for splat; numargs is now in ebx
	# Moving stack pointer to start of argument array:
	imull	$4, %eax
	subl	%eax, %esp
	# BEGIN Pushing arguments:
	movl	%esp, %edx
	pushl	%ebx
	# BEGIN args.each do |a|
	# callm :self.:class
	pushl	%edx
	subl	$24, %esp
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__class(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	popl	%edx
	# callm self.class END
	movl	%eax, (%edx)
	addl	$4, %edx
	movl	$0, (%edx)
	addl	$4, %edx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%edx)
	addl	$4, %edx
	# [:arg, 2, :ecx]
	movl	16(%ebp), %ecx
	movl	%ecx, (%edx)
	addl	$4, %edx
	# SPLAT
	movl	-16(%ebp), %eax
	addl	$4, %eax
	movl	(%eax), %edi
	addl	$4, %eax
	movl	(%eax), %eax
	testl	%eax, %eax
	je	.L717
.L719:
	testl	%edi, %edi
	je	.L718
	pushl	(%eax)
	popl	(%edx)
	addl	$4, %eax
	addl	$4, %edx
	subl	$1, %edi
	jmp	.L719
.L718:
.L717:
	# END args.each
	popl	%ebx
	# END Pushing arguments
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____send_for_obj__(%eax)
	# Evicting self
	# Re-adjusting stack post-call:
	imull	$4, %ebx
	addl	%ebx, %esp
	# callm [:callm, :self, :class].__send_for_obj__ END
	addl	$12, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Object___send__, .-__method_Object___send__
.Lscope42:
	.stabs  "",36,0,0,.Lscope42-.LFBB42	
		
	########################################################################	
		
		
		
		
		
		
		
	########################## __method_Object_p ###########################	
		
	.stabs  "__method_Object_p:F(0,0)",36,0,0,__method_Object_p	
.globl __method_Object_p
	.type	__method_Object_p, @function
__method_Object_p:
.LFBB43:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L721_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Object_p", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L720, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L721_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L723_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Object_p", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L720, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L723_else:
	# METHOD BODY:
	.stabn  68,0,123,.LM490	
.LM490:
	.stabn  68,0,124,.LM491	
.LM491:
	# callm :self.:puts
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	# callm :ob.:inspect
	subl	$24, %esp
	movl	16(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__inspect(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm ob.inspect END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	(%esi), %eax
	call	*__voff__puts(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.puts END
	movl	16(%ebp), %eax
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Object_p, .-__method_Object_p
.Lscope43:
	.stabs  "",36,0,0,.Lscope43-.LFBB43	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Object_exit #########################	
		
	.stabs  "__method_Object_exit:F(0,0)",36,0,0,__method_Object_exit	
.globl __method_Object_exit
	.type	__method_Object_exit, @function
__method_Object_exit:
.LFBB44:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L726_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Object_exit", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L725, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L726_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L728_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Object_exit", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L725, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L728_else:
	# METHOD BODY:
	.stabn  68,0,129,.LM492	
.LM492:
	.stabn  68,0,130,.LM493	
.LM493:
	subl	$20, %esp
	# callm :code.:__get_raw
	subl	$24, %esp
	movl	16(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____get_raw(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm code.__get_raw END
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	exit
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Object_exit, .-__method_Object_exit
.Lscope44:
	.stabs  "",36,0,0,.Lscope44-.LFBB44	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Object_puts #########################	
		
	.stabs  "__method_Object_puts:F(0,0)",36,0,0,__method_Object_puts	
.globl __method_Object_puts
	.type	__method_Object_puts, @function
__method_Object_puts:
.LFBB45:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L731_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Object_puts", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L730, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L731_else:
	# METHOD BODY:
	.stabn  68,0,134,.LM494	
.LM494:
	subl	$28, %esp
	addl	$7, %ebx
	subl	$24, %esp
	leal	16(%ebp), %eax
	movl	%eax, (%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$0, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	call	__splat_to_Array
	addl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -32(%ebp)
	.stabn  68,0,135,.LM495	
.LM495:
	# callm :str.:length
	subl	$24, %esp
	# [:lvar, 6, :ecx]
	movl	-32(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__length(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm str.length END
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	# if: [:callm, :na, :==, [[:sexp, :__I0]]]
	# callm :na.:==
	subl	$28, %esp
	# [:lvar, 2, :edx]
	movl	-16(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	__I0, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm na.== END
	cmpl	%eax, nil
	je	.L733_else
	cmpl	%eax, false
	je	.L733_else
	# then: [:do, [:sexp, [:puts, ""]], [:return]]
	.stabn  68,0,137,.LM496	
.LM496:
	subl	$20, %esp
	movl	$.L0, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	puts
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	nil, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L733_else:
	.stabn  68,0,139,.LM497	
.LM497:
	movl	__I0, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	.stabn  68,0,141,.LM498	
.LM498:
.L736:
	# callm :i.:<
	subl	$28, %esp
	# [:lvar, 3, :edi]
	movl	-20(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 2, :ecx]
	movl	-16(%ebp), %ecx
	movl	%ecx, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm i.< END
	cmpl	%eax, nil
	je	.L735
	cmpl	%eax, false
	je	.L735
	.stabn  68,0,142,.LM499	
.LM499:
	# callm :str.:[]
	subl	$28, %esp
	# [:lvar, 6, :edx]
	movl	-32(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 3, :ecx]
	movl	-20(%ebp), %ecx
	movl	%ecx, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm str.[] END
	pushl	%eax
	popl	%eax
	movl	%eax, -24(%ebp)
	.stabn  68,0,143,.LM500	
.LM500:
	# if: :raw
	# [:lvar, 4, :edi]
	movl	-24(%ebp), %edi
	movl	%edi, %eax
	cmpl	%eax, nil
	je	.L737_else
	cmpl	%eax, false
	je	.L737_else
	# then: [:do, [:assign, :raw, [:callm, :raw, :to_s]], [:assign, :last, [:callm, :raw, :[], [[:sexp, :__Ineg1]]]], [:assign, :raw, [:callm, :raw, :__get_raw]], [:sexp, [:if, [:ne, :raw, 0], [:printf, "%s", :raw]]], [:if, [:callm, [:callm, :last, :ord], :!=, [[:sexp, :__I10]]], [:do, [:sexp, [:puts, ""]]]]]
	.stabn  68,0,145,.LM501	
.LM501:
	# callm :raw.:to_s
	subl	$24, %esp
	# [:lvar, 4, :edx]
	movl	-24(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm raw.to_s END
	pushl	%eax
	popl	%eax
	movl	%eax, -24(%ebp)
	# callm :raw.:[]
	subl	$28, %esp
	# [:lvar, 4, :ecx]
	movl	-24(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	__Ineg1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm raw.[] END
	pushl	%eax
	popl	%eax
	movl	%eax, -28(%ebp)
	.stabn  68,0,146,.LM502	
.LM502:
	# callm :raw.:__get_raw
	subl	$24, %esp
	# [:lvar, 4, :edi]
	movl	-24(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____get_raw(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm raw.__get_raw END
	pushl	%eax
	popl	%eax
	movl	%eax, -24(%ebp)
	.stabn  68,0,147,.LM503	
.LM503:
	# if: [:ne, :raw, 0]
	# [:lvar, 4, :edx]
	movl	-24(%ebp), %edx
	# Locked register edx
	movl	$0, %eax
	cmpl	%eax, %edx
	setne	%al
	movzbl	%al, %eax
	# Unlocked register edx
	testl	%eax, %eax
	je	.L738_else
	# then: [:printf, "%s", :raw]
	subl	$24, %esp
	movl	$.L739, %eax
	movl	%eax, (%esp)
	# [:lvar, 4, :ecx]
	movl	-24(%ebp), %ecx
	movl	%ecx, 4(%esp)
	movl	$2, %ebx
	call	printf
	addl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	# else: nil
.L738_else:
	.stabn  68,0,148,.LM504	
.LM504:
	# if: [:callm, [:callm, :last, :ord], :!=, [[:sexp, :__I10]]]
	# callm [:callm, :last, :ord].:!=
	subl	$28, %esp
	# callm :last.:ord
	subl	$24, %esp
	# [:lvar, 5, :edi]
	movl	-28(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__ord(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm last.ord END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I10, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____X__3d(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :last, :ord].!= END
	cmpl	%eax, nil
	je	.L741_else
	cmpl	%eax, false
	je	.L741_else
	# then: [:do, [:sexp, [:puts, ""]]]
	.stabn  68,0,150,.LM505	
.LM505:
	subl	$20, %esp
	movl	$.L0, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	puts
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	# else: nil
.L741_else:
	jmp	.L743_endif
	# else: [:do, [:sexp, [:puts, ""]]]
.L737_else:
	.stabn  68,0,153,.LM506	
.LM506:
	subl	$20, %esp
	movl	$.L0, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	puts
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
.L743_endif:
	.stabn  68,0,154,.LM507	
.LM507:
	# callm :i.:+
	subl	$28, %esp
	# [:lvar, 3, :edx]
	movl	-20(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm i.+ END
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	jmp	.L736
.L735:
	movl	nil, %eax
	movl	nil, %eax
	addl	$28, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Object_puts, .-__method_Object_puts
.Lscope45:
	.stabs  "",36,0,0,.Lscope45-.LFBB45	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Object_print #########################	
		
	.stabs  "__method_Object_print:F(0,0)",36,0,0,__method_Object_print	
.globl __method_Object_print
	.type	__method_Object_print, @function
__method_Object_print:
.LFBB46:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L745_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Object_print", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L744, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L745_else:
	# METHOD BODY:
	.stabn  68,0,160,.LM508	
.LM508:
	subl	$24, %esp
	addl	$6, %ebx
	subl	$24, %esp
	leal	16(%ebp), %eax
	movl	%eax, (%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$0, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	call	__splat_to_Array
	addl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -28(%ebp)
	.stabn  68,0,161,.LM509	
.LM509:
	# callm :str.:length
	subl	$24, %esp
	# [:lvar, 5, :ecx]
	movl	-28(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__length(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm str.length END
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	# if: [:callm, :na, :==, [[:sexp, :__I0]]]
	# callm :na.:==
	subl	$28, %esp
	# [:lvar, 2, :edx]
	movl	-16(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	__I0, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm na.== END
	cmpl	%eax, nil
	je	.L747_else
	cmpl	%eax, false
	je	.L747_else
	# then: [:do, [:sexp, [:printf, "nil"]], [:return]]
	.stabn  68,0,164,.LM510	
.LM510:
	subl	$20, %esp
	movl	$.L9, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	printf
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	nil, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L747_else:
	.stabn  68,0,166,.LM511	
.LM511:
	movl	__I0, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	.stabn  68,0,168,.LM512	
.LM512:
.L750:
	# callm :i.:<
	subl	$28, %esp
	# [:lvar, 3, :edi]
	movl	-20(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 2, :ecx]
	movl	-16(%ebp), %ecx
	movl	%ecx, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm i.< END
	cmpl	%eax, nil
	je	.L749
	cmpl	%eax, false
	je	.L749
	.stabn  68,0,169,.LM513	
.LM513:
	# callm [:callm, [:callm, :str, :[], [:i]], :to_s].:__get_raw
	subl	$24, %esp
	# callm [:callm, :str, :[], [:i]].:to_s
	subl	$24, %esp
	# callm :str.:[]
	subl	$28, %esp
	# [:lvar, 5, :edx]
	movl	-28(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 3, :ecx]
	movl	-20(%ebp), %ecx
	movl	%ecx, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm str.[] END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :str, :[], [:i]].to_s END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____get_raw(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:callm, :str, :[], [:i]], :to_s].__get_raw END
	pushl	%eax
	popl	%eax
	movl	%eax, -24(%ebp)
	.stabn  68,0,170,.LM514	
.LM514:
	# if: :raw
	# [:lvar, 4, :edi]
	movl	-24(%ebp), %edi
	movl	%edi, %eax
	cmpl	%eax, nil
	je	.L751_else
	cmpl	%eax, false
	je	.L751_else
	# then: [:do, [:sexp, [:printf, "%s", :raw]]]
	.stabn  68,0,172,.LM515	
.LM515:
	subl	$24, %esp
	movl	$.L739, %eax
	movl	%eax, (%esp)
	# [:lvar, 4, :edx]
	movl	-24(%ebp), %edx
	movl	%edx, 4(%esp)
	movl	$2, %ebx
	call	printf
	addl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	# else: nil
.L751_else:
	.stabn  68,0,173,.LM516	
.LM516:
	# callm :i.:+
	subl	$28, %esp
	# [:lvar, 3, :ecx]
	movl	-20(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm i.+ END
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	jmp	.L750
.L749:
	movl	nil, %eax
	addl	$24, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Object_print, .-__method_Object_print
.Lscope46:
	.stabs  "",36,0,0,.Lscope46-.LFBB46	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Object_Array #########################	
		
	.stabs  "__method_Object_Array:F(0,0)",36,0,0,__method_Object_Array	
.globl __method_Object_Array
	.type	__method_Object_Array, @function
__method_Object_Array:
.LFBB47:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L754_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Object_Array", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L753, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L754_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L756_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Object_Array", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L753, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L756_else:
	# METHOD BODY:
	.stabn  68,0,179,.LM517	
.LM517:
	.stabn  68,0,180,.LM518	
.LM518:
	# if: [:callm, :arg, :respond_to?, [:":to_ary"]]
	# callm :arg.:respond_to?
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	subl	$20, %esp
	movl	$.L758, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__respond_to__Q(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm arg.respond_to? END
	cmpl	%eax, nil
	je	.L759_else
	cmpl	%eax, false
	je	.L759_else
	# then: [:do, [:callm, :arg, :to_ary]]
	.stabn  68,0,181,.LM519	
.LM519:
	# callm :arg.:to_ary
	subl	$24, %esp
	movl	16(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_ary(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm arg.to_ary END
	jmp	.L760_endif
	# else: [:do, [:if, [:callm, :arg, :respond_to?, [:":to_a"]], [:do, [:callm, :arg, :to_a]], [:do, [:array, :arg]]]]
.L759_else:
	.stabn  68,0,182,.LM520	
.LM520:
	# if: [:callm, :arg, :respond_to?, [:":to_a"]]
	# callm :arg.:respond_to?
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	subl	$20, %esp
	movl	$.L761, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__respond_to__Q(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm arg.respond_to? END
	cmpl	%eax, nil
	je	.L762_else
	cmpl	%eax, false
	je	.L762_else
	# then: [:do, [:callm, :arg, :to_a]]
	.stabn  68,0,183,.LM521	
.LM521:
	# callm :arg.:to_a
	subl	$24, %esp
	movl	16(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_a(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm arg.to_a END
	jmp	.L763_endif
	# else: [:do, [:array, :arg]]
.L762_else:
	.stabn  68,0,185,.LM522	
.LM522:
	# callm :Array.:[]
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm Array.[] END
.L763_endif:
.L760_endif:
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Object_Array, .-__method_Object_Array
.Lscope47:
	.stabs  "",36,0,0,.Lscope47-.LFBB47	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Object_dup ##########################	
		
	.stabs  "__method_Object_dup:F(0,0)",36,0,0,__method_Object_dup	
.globl __method_Object_dup
	.type	__method_Object_dup, @function
__method_Object_dup:
.LFBB48:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L765_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Object_dup", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L764, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L765_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L767_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Object_dup", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L764, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L767_else:
	# METHOD BODY:
	.stabn  68,0,189,.LM523	
.LM523:
	.stabn  68,0,191,.LM524	
.LM524:
	# callm [:callm, :self, :class].:new
	subl	$24, %esp
	# callm :self.:class
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__class(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.class END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__new(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :self, :class].new END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Object_dup, .-__method_Object_dup
.Lscope48:
	.stabs  "",36,0,0,.Lscope48-.LFBB48	
		
	########################################################################	
		
		
		
		
		
		
		
	####################### __method_Proc_initialize #######################	
		
	.stabs  "__method_Proc_initialize:F(0,0)",36,0,0,__method_Proc_initialize	
.globl __method_Proc_initialize
	.type	__method_Proc_initialize, @function
__method_Proc_initialize:
.LFBB49:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L770_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Proc_initialize", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L769, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L770_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L772_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Proc_initialize", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L769, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L772_else:
	# METHOD BODY:
	.stabn  68,0,3,.LM525	
.LM525:
	.stabn  68,0,4,.LM526	
.LM526:
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	pushl	%eax
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ecx
	movl	%ecx, 4(%esi)
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	pushl	%eax
	popl	%edi
	movl	%edi, 8(%esi)
	.stabn  68,0,5,.LM527	
.LM527:
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	pushl	%eax
	popl	%edx
	movl	%edx, 12(%esi)
	.stabn  68,0,6,.LM528	
.LM528:
	movl	__I0, %eax
	pushl	%eax
	popl	%eax
	pushl	%eax
	popl	%ecx
	movl	%ecx, 16(%esi)
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Proc_initialize, .-__method_Proc_initialize
.Lscope49:
	.stabs  "",36,0,0,.Lscope49-.LFBB49	
		
	########################################################################	
		
		
		
		
		
		
		
	####################### __method_Proc___set_raw ########################	
		
	.stabs  "__method_Proc___set_raw:F(0,0)",36,0,0,__method_Proc___set_raw	
.globl __method_Proc___set_raw
	.type	__method_Proc___set_raw, @function
__method_Proc___set_raw:
.LFBB50:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 6]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$6, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L775_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Proc___set_raw", 4, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L774, %eax
	movl	%eax, 4(%esp)
	movl	$4, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L775_else:
	# if: [:gt, :numargs, 6]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$6, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L777_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Proc___set_raw", 4, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L774, %eax
	movl	%eax, 4(%esp)
	movl	$4, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L777_else:
	# METHOD BODY:
	.stabn  68,0,15,.LM529	
.LM529:
	.stabn  68,0,16,.LM530	
.LM530:
	movl	16(%ebp), %eax
	pushl	%eax
	popl	%eax
	pushl	%eax
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ecx
	movl	%ecx, 4(%esi)
	movl	20(%ebp), %eax
	pushl	%eax
	popl	%eax
	pushl	%eax
	popl	%edi
	movl	%edi, 8(%esi)
	.stabn  68,0,17,.LM531	
.LM531:
	movl	24(%ebp), %eax
	pushl	%eax
	popl	%eax
	pushl	%eax
	popl	%edx
	movl	%edx, 12(%esi)
	.stabn  68,0,18,.LM532	
.LM532:
	movl	28(%ebp), %eax
	pushl	%eax
	popl	%eax
	pushl	%eax
	popl	%ecx
	movl	%ecx, 16(%esi)
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Proc___set_raw, .-__method_Proc___set_raw
.Lscope50:
	.stabs  "",36,0,0,.Lscope50-.LFBB50	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Proc_arity ##########################	
		
	.stabs  "__method_Proc_arity:F(0,0)",36,0,0,__method_Proc_arity	
.globl __method_Proc_arity
	.type	__method_Proc_arity, @function
__method_Proc_arity:
.LFBB51:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L780_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Proc_arity", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L779, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L780_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L782_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Proc_arity", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L779, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L782_else:
	# METHOD BODY:
	.stabn  68,0,22,.LM533	
.LM533:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	16(%esi), %eax
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Proc_arity, .-__method_Proc_arity
.Lscope51:
	.stabs  "",36,0,0,.Lscope51-.LFBB51	
		
	########################################################################	
		
		
		
		
		
		
		
	########################## __method_Proc_call ##########################	
		
	.stabs  "__method_Proc_call:F(0,0)",36,0,0,__method_Proc_call	
.globl __method_Proc_call
	.type	__method_Proc_call, @function
__method_Proc_call:
.LFBB52:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L785_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Proc_call", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L784, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L785_else:
	# METHOD BODY:
	.stabn  68,0,26,.LM534	
.LM534:
	subl	$12, %esp
	addl	$3, %ebx
	subl	$24, %esp
	leal	16(%ebp), %eax
	movl	%eax, (%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$0, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	call	__splat_to_Array
	addl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	.stabn  68,0,27,.LM535	
.LM535:
	# BEGIN Calculating argument count for splat
	# [:lvar, 2, :ecx]
	movl	-16(%ebp), %ecx
	movl	%ecx, %edx
	addl	$4, %edx
	movl	(%edx), %eax
	movl	%eax, %edi
	movl	$3, %eax
	addl	%edi, %eax
	movl	%eax, %ebx
	# END Calculating argument count for splat; numargs is now in ebx
	# Moving stack pointer to start of argument array:
	imull	$4, %eax
	subl	%eax, %esp
	# BEGIN Pushing arguments:
	movl	%esp, %edx
	pushl	%ebx
	# BEGIN args.each do |a|
	movl	12(%esi), %eax
	movl	%eax, (%edx)
	addl	$4, %edx
	movl	$0, (%edx)
	addl	$4, %edx
	movl	8(%esi), %eax
	movl	%eax, (%edx)
	addl	$4, %edx
	# SPLAT
	addl	$4, %ecx
	movl	(%ecx), %edi
	addl	$4, %ecx
	movl	(%ecx), %eax
	testl	%eax, %eax
	je	.L787
.L789:
	testl	%edi, %edi
	je	.L788
	pushl	(%eax)
	popl	(%edx)
	addl	$4, %eax
	addl	$4, %edx
	subl	$1, %edi
	jmp	.L789
.L788:
.L787:
	# END args.each
	popl	%ebx
	# END Pushing arguments
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	call	*%eax
	# Re-adjusting stack post-call:
	imull	$4, %ebx
	addl	%ebx, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	addl	$12, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Proc_call, .-__method_Proc_call
.Lscope52:
	.stabs  "",36,0,0,.Lscope52-.LFBB52	
		
	########################################################################	
		
		
		
		
		
		
		
	############################## __new_proc ##############################	
		
	.stabs  "__new_proc:F(0,0)",36,0,0,__new_proc	
.globl __new_proc
	.type	__new_proc, @function
__new_proc:
.LFBB53:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# METHOD BODY:
	subl	$12, %esp
	addl	$3, %ebx
	# callm :Proc.:new
	subl	$24, %esp
	movl	Proc, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__new(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm Proc.new END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# callm :p.:__set_raw
	subl	$40, %esp
	movl	-12(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	8(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	12(%ebp), %eax
	movl	%eax, 12(%esp)
	# [:arg, 2, :esi]
	movl	16(%ebp), %esi
	movl	%esi, 16(%esp)
	subl	$20, %esp
	movl	20(%ebp), %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__int
	addl	$20, %esp
	# [:arg, 2, :esi]
	movl	16(%ebp), %esi
	movl	%eax, 20(%esp)
	movl	$6, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____set_raw(%eax)
	# Evicting self
	# Static adj: 40
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm p.__set_raw END
	movl	-12(%ebp), %eax
	addl	$12, %esp
	# Reloading self if evicted:
	# [:arg, 2, :esi]
	movl	16(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__new_proc, .-__new_proc
.Lscope53:
	.stabs  "",36,0,0,.Lscope53-.LFBB53	
		
	########################################################################	
		
		
		
		
		
		
		
	##################### __method_Array___initialize ######################	
		
	.stabs  "__method_Array___initialize:F(0,0)",36,0,0,__method_Array___initialize	
.globl __method_Array___initialize
	.type	__method_Array___initialize, @function
__method_Array___initialize:
.LFBB54:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L792_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array___initialize", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L791, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L792_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L794_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array___initialize", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L791, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L794_else:
	# METHOD BODY:
	.stabn  68,0,8,.LM536	
.LM536:
	.stabn  68,0,9,.LM537	
.LM537:
	pushl	$0
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ecx
	movl	%ecx, 4(%esi)
	pushl	$0
	popl	%edi
	movl	%edi, 8(%esi)
	.stabn  68,0,10,.LM538	
.LM538:
	pushl	$0
	popl	%edx
	movl	%edx, 12(%esi)
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array___initialize, .-__method_Array___initialize
.Lscope54:
	.stabs  "",36,0,0,.Lscope54-.LFBB54	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Array___len #########################	
		
	.stabs  "__method_Array___len:F(0,0)",36,0,0,__method_Array___len	
.globl __method_Array___len
	.type	__method_Array___len, @function
__method_Array___len:
.LFBB55:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L797_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array___len", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L796, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L797_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L799_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array___len", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L796, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L799_else:
	# METHOD BODY:
	.stabn  68,0,15,.LM539	
.LM539:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array___len, .-__method_Array___len
.Lscope55:
	.stabs  "",36,0,0,.Lscope55-.LFBB55	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Array___ptr #########################	
		
	.stabs  "__method_Array___ptr:F(0,0)",36,0,0,__method_Array___ptr	
.globl __method_Array___ptr
	.type	__method_Array___ptr, @function
__method_Array___ptr:
.LFBB56:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L802_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array___ptr", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L801, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L802_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L804_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array___ptr", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L801, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L804_else:
	# METHOD BODY:
	.stabn  68,0,19,.LM540	
.LM540:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	8(%esi), %eax
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array___ptr, .-__method_Array___ptr
.Lscope56:
	.stabs  "",36,0,0,.Lscope56-.LFBB56	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Array___grow #########################	
		
	.stabs  "__method_Array___grow:F(0,0)",36,0,0,__method_Array___grow	
.globl __method_Array___grow
	.type	__method_Array___grow, @function
__method_Array___grow:
.LFBB57:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L807_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array___grow", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L806, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L807_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L809_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array___grow", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L806, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L809_else:
	# METHOD BODY:
	.stabn  68,0,23,.LM541	
.LM541:
	.stabn  68,0,32,.LM542	
.LM542:
	movl	16(%ebp), %eax
	movl	%eax, %ecx
	movl	$4, %eax
	imull	%ecx, %eax
	pushl	%eax
	movl	$3, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	movl	%eax, %ecx
	movl	$4, %eax
	addl	%ecx, %eax
	pushl	%eax
	popl	%eax
	pushl	%eax
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%edi
	movl	%edi, 12(%esi)
	# if: [:ne, :@ptr, 0]
	movl	8(%esi), %eax
	movl	%eax, %edx
	movl	$0, %eax
	cmpl	%eax, %edx
	setne	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L811_else
	# then: [:assign, :@ptr, [:__realloc, :@ptr, [:mul, :@capacity, 4]]]
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	8(%esi), %eax
	movl	%eax, (%esp)
	movl	12(%esi), %eax
	movl	%eax, %ecx
	movl	$4, %eax
	imull	%ecx, %eax
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	call	__realloc
	addl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	pushl	%eax
	popl	%edi
	movl	%edi, 8(%esi)
	jmp	.L812_endif
	# else: [:assign, :@ptr, [:__array, :@capacity]]
.L811_else:
	subl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	12(%esi), %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__array
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	pushl	%eax
	popl	%edx
	movl	%edx, 8(%esi)
.L812_endif:
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Array___grow, .-__method_Array___grow
.Lscope57:
	.stabs  "",36,0,0,.Lscope57-.LFBB57	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Array___set #########################	
		
	.stabs  "__method_Array___set:F(0,0)",36,0,0,__method_Array___set	
.globl __method_Array___set
	.type	__method_Array___set, @function
__method_Array___set:
.LFBB58:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$4, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L814_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array___set", 2, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L813, %eax
	movl	%eax, 4(%esp)
	movl	$2, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L814_else:
	# if: [:gt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$4, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L816_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array___set", 2, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L813, %eax
	movl	%eax, 4(%esp)
	movl	$2, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L816_else:
	# METHOD BODY:
	.stabn  68,0,41,.LM543	
.LM543:
	subl	$12, %esp
	addl	$3, %ebx
	.stabn  68,0,42,.LM544	
.LM544:
	# if: [:ge, :idx, :@len]
	# [:arg, 2, :ecx]
	movl	16(%ebp), %ecx
	# Locked register ecx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	cmpl	%eax, %ecx
	setge	%al
	movzbl	%al, %eax
	# Unlocked register ecx
	testl	%eax, %eax
	je	.L818_else
	# then: [:assign, :@len, [:add, :idx, 1]]
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	# Locked register edi
	movl	$1, %eax
	addl	%edi, %eax
	# Unlocked register edi
	pushl	%eax
	popl	%eax
	pushl	%eax
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%edx
	movl	%edx, 4(%esi)
	# else: nil
.L818_else:
	# [:arg, 3, :ecx]
	movl	20(%ebp), %ecx
	pushl	%ecx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	8(%esi), %eax
	movl	%eax, %edx
	pushl	%edx
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	movl	%edi, %eax
	sall	$2, %eax
	popl	%edx
	addl	%eax, %edx
	popl	%eax
	movl	%eax, (%edx)
	addl	$12, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array___set, .-__method_Array___set
.Lscope58:
	.stabs  "",36,0,0,.Lscope58-.LFBB58	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Array_to_a ##########################	
		
	.stabs  "__method_Array_to_a:F(0,0)",36,0,0,__method_Array_to_a	
.globl __method_Array_to_a
	.type	__method_Array_to_a, @function
__method_Array_to_a:
.LFBB59:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L821_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_to_a", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L820, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L821_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L823_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_to_a", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L820, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L823_else:
	# METHOD BODY:
	.stabn  68,0,46,.LM545	
.LM545:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, %eax
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_to_a, .-__method_Array_to_a
.Lscope59:
	.stabs  "",36,0,0,.Lscope59-.LFBB59	
		
	########################################################################	
		
		
		
		
		
		
		
	########################### __splat_to_Array ###########################	
		
	.stabs  "__splat_to_Array:F(0,0)",36,0,0,__splat_to_Array	
.globl __splat_to_Array
	.type	__splat_to_Array, @function
__splat_to_Array:
.LFBB60:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# METHOD BODY:
	subl	$24, %esp
	addl	$6, %ebx
	# callm :Array.:__new
	subl	$24, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____new(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm Array.__new END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	movl	$0, -16(%ebp)
	movl	12(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -24(%ebp)
	# callm :splat.:__grow
	subl	$28, %esp
	movl	-12(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	-24(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____grow(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm splat.__grow END
.L827:
	movl	-16(%ebp), %eax
	movl	%eax, %ecx
	movl	-24(%ebp), %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L826
	# callm :splat.:__set
	subl	$32, %esp
	movl	-12(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	-16(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	8(%ebp), %eax
	movl	%eax, %edx
	pushl	%edx
	movl	-16(%ebp), %eax
	sall	$2, %eax
	popl	%edx
	addl	%eax, %edx
	movl	(%edx), %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____set(%eax)
	# Evicting self
	# Static adj: 32
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm splat.__set END
	movl	-16(%ebp), %eax
	movl	%eax, %edi
	movl	$1, %eax
	addl	%edi, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	jmp	.L827
.L826:
	movl	nil, %eax
	movl	-12(%ebp), %eax
	addl	$24, %esp
	# Reloading self if evicted:
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	leave	
	ret	
	.size	__splat_to_Array, .-__splat_to_Array
.Lscope60:
	.stabs  "",36,0,0,.Lscope60-.LFBB60	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_TrueClass___X ########################	
		
	.stabs  "__method_TrueClass___X:F(0,0)",36,0,0,__method_TrueClass___X	
.globl __method_TrueClass___X
	.type	__method_TrueClass___X, @function
__method_TrueClass___X:
.LFBB61:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L829_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_TrueClass___X", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L828, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L829_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L831_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_TrueClass___X", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L828, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L831_else:
	# METHOD BODY:
	.stabn  68,0,4,.LM546	
.LM546:
	movl	false, %eax
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_TrueClass___X, .-__method_TrueClass___X
.Lscope61:
	.stabs  "",36,0,0,.Lscope61-.LFBB61	
		
	########################################################################	
		
		
		
		
		
		
		
	####################### __method_TrueClass_to_s ########################	
		
	.stabs  "__method_TrueClass_to_s:F(0,0)",36,0,0,__method_TrueClass_to_s	
.globl __method_TrueClass_to_s
	.type	__method_TrueClass_to_s, @function
__method_TrueClass_to_s:
.LFBB62:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L834_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_TrueClass_to_s", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L833, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L834_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L836_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_TrueClass_to_s", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L833, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L836_else:
	# METHOD BODY:
	.stabn  68,0,8,.LM547	
.LM547:
	subl	$20, %esp
	movl	$.L7, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_TrueClass_to_s, .-__method_TrueClass_to_s
.Lscope62:
	.stabs  "",36,0,0,.Lscope62-.LFBB62	
		
	########################################################################	
		
		
		
		
		
		
		
	###################### __method_TrueClass_inspect ######################	
		
	.stabs  "__method_TrueClass_inspect:F(0,0)",36,0,0,__method_TrueClass_inspect	
.globl __method_TrueClass_inspect
	.type	__method_TrueClass_inspect, @function
__method_TrueClass_inspect:
.LFBB63:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L839_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_TrueClass_inspect", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L838, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L839_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L841_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_TrueClass_inspect", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L838, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L841_else:
	# METHOD BODY:
	.stabn  68,0,12,.LM548	
.LM548:
	# callm :self.:to_s
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.to_s END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_TrueClass_inspect, .-__method_TrueClass_inspect
.Lscope63:
	.stabs  "",36,0,0,.Lscope63-.LFBB63	
		
	########################################################################	
		
		
		
		
		
		
		
	####################### __method_TrueClass___eq ########################	
		
	.stabs  "__method_TrueClass___eq:F(0,0)",36,0,0,__method_TrueClass___eq	
.globl __method_TrueClass___eq
	.type	__method_TrueClass___eq, @function
__method_TrueClass___eq:
.LFBB64:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L844_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_TrueClass___eq", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L843, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L844_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L846_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_TrueClass___eq", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L843, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L846_else:
	# METHOD BODY:
	.stabn  68,0,16,.LM549	
.LM549:
	.stabn  68,0,17,.LM550	
.LM550:
	# if: [:eq, :other, :true]
	movl	16(%ebp), %eax
	movl	%eax, %edi
	movl	true, %eax
	cmpl	%eax, %edi
	sete	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L848_else
	# then: :true
	movl	true, %eax
	jmp	.L849_endif
	# else: :false
.L848_else:
	movl	false, %eax
.L849_endif:
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_TrueClass___eq, .-__method_TrueClass___eq
.Lscope64:
	.stabs  "",36,0,0,.Lscope64-.LFBB64	
		
	########################################################################	
		
		
		
		
		
		
		
	#################### __method_FalseClass___true__Q #####################	
		
	.stabs  "__method_FalseClass___true__Q:F(0,0)",36,0,0,__method_FalseClass___true__Q	
.globl __method_FalseClass___true__Q
	.type	__method_FalseClass___true__Q, @function
__method_FalseClass___true__Q:
.LFBB65:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L851_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_FalseClass___true__Q", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L850, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L851_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L853_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_FalseClass___true__Q", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L850, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L853_else:
	# METHOD BODY:
	.stabn  68,0,4,.LM551	
.LM551:
	.stabn  68,0,5,.LM552	
.LM552:
	movl	$0, %eax
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_FalseClass___true__Q, .-__method_FalseClass___true__Q
.Lscope65:
	.stabs  "",36,0,0,.Lscope65-.LFBB65	
		
	########################################################################	
		
		
		
		
		
		
		
	####################### __method_FalseClass_to_s #######################	
		
	.stabs  "__method_FalseClass_to_s:F(0,0)",36,0,0,__method_FalseClass_to_s	
.globl __method_FalseClass_to_s
	.type	__method_FalseClass_to_s, @function
__method_FalseClass_to_s:
.LFBB66:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L856_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_FalseClass_to_s", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L855, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L856_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L858_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_FalseClass_to_s", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L855, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L858_else:
	# METHOD BODY:
	.stabn  68,0,8,.LM553	
.LM553:
	subl	$20, %esp
	movl	$.L8, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_FalseClass_to_s, .-__method_FalseClass_to_s
.Lscope66:
	.stabs  "",36,0,0,.Lscope66-.LFBB66	
		
	########################################################################	
		
		
		
		
		
		
		
	##################### __method_FalseClass_inspect ######################	
		
	.stabs  "__method_FalseClass_inspect:F(0,0)",36,0,0,__method_FalseClass_inspect	
.globl __method_FalseClass_inspect
	.type	__method_FalseClass_inspect, @function
__method_FalseClass_inspect:
.LFBB67:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L861_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_FalseClass_inspect", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L860, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L861_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L863_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_FalseClass_inspect", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L860, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L863_else:
	# METHOD BODY:
	.stabn  68,0,12,.LM554	
.LM554:
	# callm :self.:to_s
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.to_s END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_FalseClass_inspect, .-__method_FalseClass_inspect
.Lscope67:
	.stabs  "",36,0,0,.Lscope67-.LFBB67	
		
	########################################################################	
		
		
		
		
		
		
		
	####################### __method_FalseClass___X ########################	
		
	.stabs  "__method_FalseClass___X:F(0,0)",36,0,0,__method_FalseClass___X	
.globl __method_FalseClass___X
	.type	__method_FalseClass___X, @function
__method_FalseClass___X:
.LFBB68:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L866_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_FalseClass___X", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L865, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L866_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L868_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_FalseClass___X", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L865, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L868_else:
	# METHOD BODY:
	.stabn  68,0,16,.LM555	
.LM555:
	movl	true, %eax
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_FalseClass___X, .-__method_FalseClass___X
.Lscope68:
	.stabs  "",36,0,0,.Lscope68-.LFBB68	
		
	########################################################################	
		
		
		
		
		
		
		
	##################### __method_NilClass___true__Q ######################	
		
	.stabs  "__method_NilClass___true__Q:F(0,0)",36,0,0,__method_NilClass___true__Q	
.globl __method_NilClass___true__Q
	.type	__method_NilClass___true__Q, @function
__method_NilClass___true__Q:
.LFBB69:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L871_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_NilClass___true__Q", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L870, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L871_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L873_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_NilClass___true__Q", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L870, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L873_else:
	# METHOD BODY:
	.stabn  68,0,4,.LM556	
.LM556:
	.stabn  68,0,5,.LM557	
.LM557:
	movl	$0, %eax
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_NilClass___true__Q, .-__method_NilClass___true__Q
.Lscope69:
	.stabs  "",36,0,0,.Lscope69-.LFBB69	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_NilClass___eq ########################	
		
	.stabs  "__method_NilClass___eq:F(0,0)",36,0,0,__method_NilClass___eq	
.globl __method_NilClass___eq
	.type	__method_NilClass___eq, @function
__method_NilClass___eq:
.LFBB70:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L876_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_NilClass___eq", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L875, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L876_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L878_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_NilClass___eq", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L875, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L878_else:
	# METHOD BODY:
	.stabn  68,0,8,.LM558	
.LM558:
	.stabn  68,0,9,.LM559	
.LM559:
	# callm :other.:nil?
	subl	$24, %esp
	movl	16(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__nil__Q(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm other.nil? END
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_NilClass___eq, .-__method_NilClass___eq
.Lscope70:
	.stabs  "",36,0,0,.Lscope70-.LFBB70	
		
	########################################################################	
		
		
		
		
		
		
		
	####################### __method_NilClass_nil__Q #######################	
		
	.stabs  "__method_NilClass_nil__Q:F(0,0)",36,0,0,__method_NilClass_nil__Q	
.globl __method_NilClass_nil__Q
	.type	__method_NilClass_nil__Q, @function
__method_NilClass_nil__Q:
.LFBB71:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L881_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_NilClass_nil__Q", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L880, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L881_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L883_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_NilClass_nil__Q", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L880, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L883_else:
	# METHOD BODY:
	.stabn  68,0,12,.LM560	
.LM560:
	movl	true, %eax
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_NilClass_nil__Q, .-__method_NilClass_nil__Q
.Lscope71:
	.stabs  "",36,0,0,.Lscope71-.LFBB71	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_NilClass___X #########################	
		
	.stabs  "__method_NilClass___X:F(0,0)",36,0,0,__method_NilClass___X	
.globl __method_NilClass___X
	.type	__method_NilClass___X, @function
__method_NilClass___X:
.LFBB72:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L886_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_NilClass___X", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L885, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L886_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L888_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_NilClass___X", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L885, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L888_else:
	# METHOD BODY:
	.stabn  68,0,16,.LM561	
.LM561:
	movl	true, %eax
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_NilClass___X, .-__method_NilClass___X
.Lscope72:
	.stabs  "",36,0,0,.Lscope72-.LFBB72	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_NilClass_to_s ########################	
		
	.stabs  "__method_NilClass_to_s:F(0,0)",36,0,0,__method_NilClass_to_s	
.globl __method_NilClass_to_s
	.type	__method_NilClass_to_s, @function
__method_NilClass_to_s:
.LFBB73:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L891_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_NilClass_to_s", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L890, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L891_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L893_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_NilClass_to_s", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L890, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L893_else:
	# METHOD BODY:
	.stabn  68,0,20,.LM562	
.LM562:
	subl	$20, %esp
	movl	$.L0, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_NilClass_to_s, .-__method_NilClass_to_s
.Lscope73:
	.stabs  "",36,0,0,.Lscope73-.LFBB73	
		
	########################################################################	
		
		
		
		
		
		
		
	###################### __method_NilClass_inspect #######################	
		
	.stabs  "__method_NilClass_inspect:F(0,0)",36,0,0,__method_NilClass_inspect	
.globl __method_NilClass_inspect
	.type	__method_NilClass_inspect, @function
__method_NilClass_inspect:
.LFBB74:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L896_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_NilClass_inspect", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L895, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L896_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L898_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_NilClass_inspect", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L895, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L898_else:
	# METHOD BODY:
	.stabn  68,0,24,.LM563	
.LM563:
	subl	$20, %esp
	movl	$.L9, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_NilClass_inspect, .-__method_NilClass_inspect
.Lscope74:
	.stabs  "",36,0,0,.Lscope74-.LFBB74	
		
	########################################################################	
		
		
		
		
		
		
		
	###################### __method_Class_allocate__1 ######################	
		
	.stabs  "__method_Class_allocate__1:F(0,0)",36,0,0,__method_Class_allocate__1	
.globl __method_Class_allocate__1
	.type	__method_Class_allocate__1, @function
__method_Class_allocate__1:
.LFBB75:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L901_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Class_allocate__1", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L900, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L901_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L903_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Class_allocate__1", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L900, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L903_else:
	# METHOD BODY:
	.stabn  68,0,8,.LM564	
.LM564:
	subl	$24, %esp
	addl	$6, %ebx
	.stabn  68,0,9,.LM565	
.LM565:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	subl	$20, %esp
	movl	4(%esi), %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__array
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	.stabn  68,0,10,.LM566	
.LM566:
	movl	$1, -20(%ebp)
	.stabn  68,0,11,.LM567	
.LM567:
.L906:
	# [:lvar, 3, :edi]
	movl	-20(%ebp), %edi
	# Locked register edi
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	# Unlocked register edi
	testl	%eax, %eax
	je	.L905
	movl	nil, %eax
	pushl	%eax
	# [:lvar, 2, :edx]
	movl	-16(%ebp), %edx
	movl	%edx, %edi
	pushl	%edi
	# [:lvar, 3, :ecx]
	movl	-20(%ebp), %ecx
	movl	%ecx, %eax
	sall	$2, %eax
	popl	%edi
	addl	%eax, %edi
	popl	%eax
	movl	%eax, (%edi)
	# Locked register ecx
	movl	$1, %eax
	addl	%ecx, %eax
	# Unlocked register ecx
	pushl	%eax
	# Marked ecx dirty (lvar,3)
	popl	%eax
	movl	%eax, %ecx
	# Saving ecx to lvar,3
	movl	%ecx, -20(%ebp)
	jmp	.L906
.L905:
	movl	nil, %eax
	.stabn  68,0,17,.LM568	
.LM568:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%esi
	# [:lvar, 2, :edi]
	movl	-16(%ebp), %edi
	movl	%edi, %edx
	popl	%eax
	movl	%eax, (%edx)
	movl	%edi, %eax
	addl	$24, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Class_allocate__1, .-__method_Class_allocate__1
.Lscope75:
	.stabs  "",36,0,0,.Lscope75-.LFBB75	
		
	########################################################################	
		
		
		
		
		
		
		
	###################### __method_Range_initialize #######################	
		
	.stabs  "__method_Range_initialize:F(0,0)",36,0,0,__method_Range_initialize	
.globl __method_Range_initialize
	.type	__method_Range_initialize, @function
__method_Range_initialize:
.LFBB76:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$4, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L908_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Range_initialize", 2, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L907, %eax
	movl	%eax, 4(%esp)
	movl	$2, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L908_else:
	# if: [:gt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$4, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L910_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Range_initialize", 2, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L907, %eax
	movl	%eax, 4(%esp)
	movl	$2, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L910_else:
	# METHOD BODY:
	.stabn  68,0,6,.LM569	
.LM569:
	.stabn  68,0,7,.LM570	
.LM570:
	movl	16(%ebp), %eax
	pushl	%eax
	popl	%eax
	pushl	%eax
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%edi
	movl	%edi, 4(%esi)
	movl	20(%ebp), %eax
	pushl	%eax
	popl	%eax
	pushl	%eax
	popl	%ecx
	movl	%ecx, 8(%esi)
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Range_initialize, .-__method_Range_initialize
.Lscope76:
	.stabs  "",36,0,0,.Lscope76-.LFBB76	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Range_to_s ##########################	
		
	.stabs  "__method_Range_to_s:F(0,0)",36,0,0,__method_Range_to_s	
.globl __method_Range_to_s
	.type	__method_Range_to_s, @function
__method_Range_to_s:
.LFBB77:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L913_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Range_to_s", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L912, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L913_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L915_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Range_to_s", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L912, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L915_else:
	# METHOD BODY:
	.stabn  68,0,11,.LM571	
.LM571:
	.stabn  68,0,12,.LM572	
.LM572:
	# callm [:callm, [:callm, [:callm, [:sexp, [:call, :__get_string, :".L0"]], :to_s], :concat, [[:callm, :@min, :to_s]]], :concat, [[:callm, [:sexp, [:call, :__get_string, :".L10"]], :to_s]]].:concat
	subl	$28, %esp
	# callm [:callm, [:callm, [:sexp, [:call, :__get_string, :".L0"]], :to_s], :concat, [[:callm, :@min, :to_s]]].:concat
	subl	$28, %esp
	# callm [:callm, [:sexp, [:call, :__get_string, :".L0"]], :to_s].:concat
	subl	$28, %esp
	# callm [:sexp, [:call, :__get_string, :".L0"]].:to_s
	subl	$24, %esp
	subl	$20, %esp
	movl	$.L0, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:sexp, [:call, :__get_string, :".L0"]].to_s END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :@min.:to_s
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @min.to_s END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__concat(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:sexp, [:call, :__get_string, :".L0"]], :to_s].concat END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm [:sexp, [:call, :__get_string, :".L10"]].:to_s
	subl	$24, %esp
	subl	$20, %esp
	movl	$.L10, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:sexp, [:call, :__get_string, :".L10"]].to_s END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__concat(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:callm, [:sexp, [:call, :__get_string, :".L0"]], :to_s], :concat, [[:callm, :@min, :to_s]]].concat END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :@max.:to_s
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	8(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @max.to_s END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__concat(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:callm, [:callm, [:sexp, [:call, :__get_string, :".L0"]], :to_s], :concat, [[:callm, :@min, :to_s]]], :concat, [[:callm, [:sexp, [:call, :__get_string, :".L10"]], :to_s]]].concat END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Range_to_s, .-__method_Range_to_s
.Lscope77:
	.stabs  "",36,0,0,.Lscope77-.LFBB77	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Range_inspect ########################	
		
	.stabs  "__method_Range_inspect:F(0,0)",36,0,0,__method_Range_inspect	
.globl __method_Range_inspect
	.type	__method_Range_inspect, @function
__method_Range_inspect:
.LFBB78:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L918_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Range_inspect", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L917, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L918_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L920_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Range_inspect", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L917, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L920_else:
	# METHOD BODY:
	.stabn  68,0,15,.LM573	
.LM573:
	# callm :self.:to_s
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.to_s END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Range_inspect, .-__method_Range_inspect
.Lscope78:
	.stabs  "",36,0,0,.Lscope78-.LFBB78	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Range_first #########################	
		
	.stabs  "__method_Range_first:F(0,0)",36,0,0,__method_Range_first	
.globl __method_Range_first
	.type	__method_Range_first, @function
__method_Range_first:
.LFBB79:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L923_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Range_first", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L922, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L923_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L925_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Range_first", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L922, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L925_else:
	# METHOD BODY:
	.stabn  68,0,19,.LM574	
.LM574:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Range_first, .-__method_Range_first
.Lscope79:
	.stabs  "",36,0,0,.Lscope79-.LFBB79	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Range_last ##########################	
		
	.stabs  "__method_Range_last:F(0,0)",36,0,0,__method_Range_last	
.globl __method_Range_last
	.type	__method_Range_last, @function
__method_Range_last:
.LFBB80:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L928_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Range_last", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L927, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L928_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L930_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Range_last", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L927, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L930_else:
	# METHOD BODY:
	.stabn  68,0,23,.LM575	
.LM575:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	8(%esi), %eax
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Range_last, .-__method_Range_last
.Lscope80:
	.stabs  "",36,0,0,.Lscope80-.LFBB80	
		
	########################################################################	
		
		
		
		
		
		
		
	####################### __method_Range_member__Q #######################	
		
	.stabs  "__method_Range_member__Q:F(0,0)",36,0,0,__method_Range_member__Q	
.globl __method_Range_member__Q
	.type	__method_Range_member__Q, @function
__method_Range_member__Q:
.LFBB81:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L933_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Range_member__Q", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L932, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L933_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L935_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Range_member__Q", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L932, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L935_else:
	# METHOD BODY:
	.stabn  68,0,30,.LM576	
.LM576:
	.stabn  68,0,31,.LM577	
.LM577:
	# if: [:callm, :val, :!]
	# callm :val.:!
	subl	$24, %esp
	movl	16(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____X(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm val.! END
	cmpl	%eax, nil
	je	.L937_else
	cmpl	%eax, false
	je	.L937_else
	# then: [:do, [:return, :false]]
	.stabn  68,0,32,.LM578	
.LM578:
	movl	false, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L937_else:
	.stabn  68,0,33,.LM579	
.LM579:
	# if: [:callm, :val, :>=, [:@min]]
	# callm :val.:>=
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____ge(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm val.>= END
	cmpl	%eax, nil
	je	.L939_else
	cmpl	%eax, false
	je	.L939_else
	# then: [:callm, :val, :<=, [:@max]]
	# callm :val.:<=
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	8(%esi), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____le(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm val.<= END
	# else: nil
.L939_else:
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Range_member__Q, .-__method_Range_member__Q
.Lscope81:
	.stabs  "",36,0,0,.Lscope81-.LFBB81	
		
	########################################################################	
		
		
		
		
		
		
		
	###################### __method_Range_include__Q #######################	
		
	.stabs  "__method_Range_include__Q:F(0,0)",36,0,0,__method_Range_include__Q	
.globl __method_Range_include__Q
	.type	__method_Range_include__Q, @function
__method_Range_include__Q:
.LFBB82:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L942_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Range_include__Q", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L941, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L942_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L944_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Range_include__Q", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L941, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L944_else:
	# METHOD BODY:
	.stabn  68,0,37,.LM580	
.LM580:
	.stabn  68,0,38,.LM581	
.LM581:
	# callm :self.:member?
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__member__Q(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.member? END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Range_include__Q, .-__method_Range_include__Q
.Lscope82:
	.stabs  "",36,0,0,.Lscope82-.LFBB82	
		
	########################################################################	
		
		
		
		
		
		
		
	####################### __method_Range___eq__3d ########################	
		
	.stabs  "__method_Range___eq__3d:F(0,0)",36,0,0,__method_Range___eq__3d	
.globl __method_Range___eq__3d
	.type	__method_Range___eq__3d, @function
__method_Range___eq__3d:
.LFBB83:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L947_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Range___eq__3d", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L946, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L947_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L949_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Range___eq__3d", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L946, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L949_else:
	# METHOD BODY:
	.stabn  68,0,41,.LM582	
.LM582:
	.stabn  68,0,42,.LM583	
.LM583:
	# callm :self.:member?
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__member__Q(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.member? END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Range___eq__3d, .-__method_Range___eq__3d
.Lscope83:
	.stabs  "",36,0,0,.Lscope83-.LFBB83	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Range_each ##########################	
		
	.stabs  "__method_Range_each:F(0,0)",36,0,0,__method_Range_each	
.globl __method_Range_each
	.type	__method_Range_each, @function
__method_Range_each:
.LFBB84:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L952_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Range_each", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L951, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L952_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L954_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Range_each", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L951, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L954_else:
	# METHOD BODY:
	.stabn  68,0,45,.LM584	
.LM584:
	subl	$20, %esp
	addl	$5, %ebx
	subl	$20, %esp
	movl	$8, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-16(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	.stabn  68,0,46,.LM585	
.LM585:
	movl	4(%esi), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
.L957:
	# callm :i.:<=
	subl	$28, %esp
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	8(%esi), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____le(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm i.<= END
	cmpl	%eax, nil
	je	.L956
	cmpl	%eax, false
	je	.L956
	.stabn  68,0,47,.LM586	
.LM586:
	# callm [:index, :__env__, 1].:call
	subl	$28, %esp
	movl	-16(%ebp), %eax
	movl	%eax, %edx
	addl	$4, %edx
	movl	(%edx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__call(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].call END
	.stabn  68,0,48,.LM587	
.LM587:
	# callm :i.:+
	subl	$28, %esp
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm i.+ END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	jmp	.L957
.L956:
	movl	nil, %eax
	addl	$20, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Range_each, .-__method_Range_each
.Lscope84:
	.stabs  "",36,0,0,.Lscope84-.LFBB84	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Range_to_a ##########################	
		
	.stabs  "__method_Range_to_a:F(0,0)",36,0,0,__method_Range_to_a	
.globl __method_Range_to_a
	.type	__method_Range_to_a, @function
__method_Range_to_a:
.LFBB85:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L959_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Range_to_a", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L958, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L959_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L961_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Range_to_a", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L958, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L961_else:
	# METHOD BODY:
	.stabn  68,0,53,.LM588	
.LM588:
	subl	$16, %esp
	addl	$4, %ebx
	subl	$20, %esp
	movl	$12, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %edi
	addl	$8, %edi
	popl	%eax
	movl	%eax, (%edi)
	.stabn  68,0,54,.LM589	
.LM589:
	# callm :Array.:[]
	subl	$24, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm Array.[] END
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	# callm :self.:each
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	.stabn  68,0,55,.LM590	
.LM590:
	# Stack frame
	pushl	%ebp
	movl	-12(%ebp), %eax
	movl	%eax, %edx
	popl	%eax
	movl	%eax, (%edx)
	movl	$__lambda_L66, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	subl	$32, %esp
	movl	-16(%ebp), %eax
	movl	%eax, (%esp)
	movl	-12(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%esi, 8(%esp)
	movl	$1, 12(%esp)
	movl	$4, %ebx
	call	__new_proc
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__each(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.each END
	movl	-12(%ebp), %eax
	movl	%eax, %edi
	addl	$4, %edi
	movl	(%edi), %eax
	addl	$16, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Range_to_a, .-__method_Range_to_a
.Lscope85:
	.stabs  "",36,0,0,.Lscope85-.LFBB85	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Range_to_enum ########################	
		
	.stabs  "__method_Range_to_enum:F(0,0)",36,0,0,__method_Range_to_enum	
.globl __method_Range_to_enum
	.type	__method_Range_to_enum, @function
__method_Range_to_enum:
.LFBB86:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L965_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Range_to_enum", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L964, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L965_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L967_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Range_to_enum", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L964, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L967_else:
	# METHOD BODY:
	.stabn  68,0,61,.LM591	
.LM591:
	.stabn  68,0,62,.LM592	
.LM592:
	# callm :RangeEnumerator.:new
	subl	$28, %esp
	movl	RangeEnumerator, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__new(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm RangeEnumerator.new END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Range_to_enum, .-__method_Range_to_enum
.Lscope86:
	.stabs  "",36,0,0,.Lscope86-.LFBB86	
		
	########################################################################	
		
		
		
		
		
		
		
	###################### __method_Array_initialize #######################	
		
	.stabs  "__method_Array_initialize:F(0,0)",36,0,0,__method_Array_initialize	
.globl __method_Array_initialize
	.type	__method_Array_initialize, @function
__method_Array_initialize:
.LFBB87:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L970_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_initialize", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L969, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L970_else:
	# METHOD BODY:
	.stabn  68,0,12,.LM593	
.LM593:
	subl	$12, %esp
	addl	$3, %ebx
	subl	$24, %esp
	leal	16(%ebp), %eax
	movl	%eax, (%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$0, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	call	__splat_to_Array
	addl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	# callm :self.:__initialize
	subl	$24, %esp
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____initialize(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.__initialize END
	.stabn  68,0,23,.LM594	
.LM594:
	# if: [:callm, [:callm, :elements, :length], :>, [[:sexp, :__I0]]]
	# callm [:callm, :elements, :length].:>
	subl	$28, %esp
	# callm :elements.:length
	subl	$24, %esp
	# [:lvar, 2, :edi]
	movl	-16(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__length(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm elements.length END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I0, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____gt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :elements, :length].> END
	cmpl	%eax, nil
	je	.L972_else
	cmpl	%eax, false
	je	.L972_else
	# then: [:do, [:call, :__grow, [[:callm, [:callm, :elements, :[], [[:sexp, :__I0]]], :__get_raw]]]]
	.stabn  68,0,25,.LM595	
.LM595:
	# callm :self.:__grow
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	# callm [:callm, :elements, :[], [[:sexp, :__I0]]].:__get_raw
	subl	$24, %esp
	# callm :elements.:[]
	subl	$28, %esp
	# [:lvar, 2, :edx]
	movl	-16(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	__I0, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm elements.[] END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____get_raw(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :elements, :[], [[:sexp, :__I0]]].__get_raw END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	(%esi), %eax
	call	*__voff____grow(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.__grow END
	# else: nil
.L972_else:
	addl	$12, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_initialize, .-__method_Array_initialize
.Lscope87:
	.stabs  "",36,0,0,.Lscope87-.LFBB87	
		
	########################################################################	
		
		
		
		
		
		
		
	####################### __method_Array_capacity ########################	
		
	.stabs  "__method_Array_capacity:F(0,0)",36,0,0,__method_Array_capacity	
.globl __method_Array_capacity
	.type	__method_Array_capacity, @function
__method_Array_capacity:
.LFBB88:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L975_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_capacity", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L974, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L975_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L977_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_capacity", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L974, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L977_else:
	# METHOD BODY:
	.stabn  68,0,29,.LM596	
.LM596:
	.stabn  68,0,30,.LM597	
.LM597:
	subl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	12(%esi), %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__int
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_capacity, .-__method_Array_capacity
.Lscope88:
	.stabs  "",36,0,0,.Lscope88-.LFBB88	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Array___get #########################	
		
	.stabs  "__method_Array___get:F(0,0)",36,0,0,__method_Array___get	
.globl __method_Array___get
	.type	__method_Array___get, @function
__method_Array___get:
.LFBB89:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L980_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array___get", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L979, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L980_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L982_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array___get", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L979, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L982_else:
	# METHOD BODY:
	.stabn  68,0,34,.LM598	
.LM598:
	.stabn  68,0,35,.LM599	
.LM599:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	8(%esi), %eax
	movl	%eax, %ecx
	pushl	%ecx
	movl	16(%ebp), %eax
	sall	$2, %eax
	popl	%ecx
	addl	%eax, %ecx
	movl	(%ecx), %eax
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array___get, .-__method_Array___get
.Lscope89:
	.stabs  "",36,0,0,.Lscope89-.LFBB89	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Array_find ##########################	
		
	.stabs  "__method_Array_find:F(0,0)",36,0,0,__method_Array_find	
.globl __method_Array_find
	.type	__method_Array_find, @function
__method_Array_find:
.LFBB90:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L985_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_find", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L984, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L985_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L987_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_find", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L984, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L987_else:
	# METHOD BODY:
	.stabn  68,0,41,.LM600	
.LM600:
	subl	$16, %esp
	addl	$4, %ebx
	subl	$20, %esp
	movl	$8, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	.stabn  68,0,42,.LM601	
.LM601:
	# callm :self.:each
	subl	$24, %esp
	movl	%esi, (%esp)
	# Stack frame
	pushl	%ebp
	movl	-12(%ebp), %eax
	movl	%eax, %edi
	popl	%eax
	movl	%eax, (%edi)
	movl	$__lambda_L67, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	subl	$32, %esp
	movl	-16(%ebp), %eax
	movl	%eax, (%esp)
	movl	-12(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%esi, 8(%esp)
	movl	$1, 12(%esp)
	movl	$4, %ebx
	call	__new_proc
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__each(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.each END
	.stabn  68,0,45,.LM602	
.LM602:
	movl	nil, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	addl	$16, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_find, .-__method_Array_find
.Lscope90:
	.stabs  "",36,0,0,.Lscope90-.LFBB90	
		
	########################################################################	
		
		
		
		
		
		
		
	###################### __method_Array_include__Q #######################	
		
	.stabs  "__method_Array_include__Q:F(0,0)",36,0,0,__method_Array_include__Q	
.globl __method_Array_include__Q
	.type	__method_Array_include__Q, @function
__method_Array_include__Q:
.LFBB91:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$3, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L991_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_include__Q", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L990, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L991_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L993_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_include__Q", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L990, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L993_else:
	# METHOD BODY:
	.stabn  68,0,50,.LM603	
.LM603:
	subl	$16, %esp
	addl	$4, %ebx
	subl	$20, %esp
	movl	$12, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	pushl	%edi
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %edx
	addl	$8, %edx
	popl	%eax
	movl	%eax, (%edx)
	.stabn  68,0,51,.LM604	
.LM604:
	# callm :self.:each
	subl	$24, %esp
	movl	%esi, (%esp)
	# Stack frame
	pushl	%ebp
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	movl	$__lambda_L68, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	subl	$32, %esp
	movl	-16(%ebp), %eax
	movl	%eax, (%esp)
	movl	-12(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%esi, 8(%esp)
	movl	$1, 12(%esp)
	movl	$4, %ebx
	call	__new_proc
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__each(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.each END
	.stabn  68,0,53,.LM605	
.LM605:
	movl	false, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	addl	$16, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_include__Q, .-__method_Array_include__Q
.Lscope91:
	.stabs  "",36,0,0,.Lscope91-.LFBB91	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Array_reject #########################	
		
	.stabs  "__method_Array_reject:F(0,0)",36,0,0,__method_Array_reject	
.globl __method_Array_reject
	.type	__method_Array_reject, @function
__method_Array_reject:
.LFBB92:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L997_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_reject", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L996, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L997_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L999_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_reject", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L996, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L999_else:
	# METHOD BODY:
	.stabn  68,0,58,.LM606	
.LM606:
	subl	$16, %esp
	addl	$4, %ebx
	subl	$20, %esp
	movl	$12, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	addl	$8, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	.stabn  68,0,59,.LM607	
.LM607:
	# callm [:callm, :self, :class].:new
	subl	$24, %esp
	# callm :self.:class
	subl	$24, %esp
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__class(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.class END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__new(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :self, :class].new END
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %edi
	addl	$4, %edi
	popl	%eax
	movl	%eax, (%edi)
	# callm :self.:each
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	.stabn  68,0,60,.LM608	
.LM608:
	# Stack frame
	pushl	%ebp
	movl	-12(%ebp), %eax
	movl	%eax, %edx
	popl	%eax
	movl	%eax, (%edx)
	movl	$__lambda_L69, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	subl	$32, %esp
	movl	-16(%ebp), %eax
	movl	%eax, (%esp)
	movl	-12(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%esi, 8(%esp)
	movl	$1, 12(%esp)
	movl	$4, %ebx
	call	__new_proc
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__each(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.each END
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	movl	(%ecx), %eax
	addl	$16, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_reject, .-__method_Array_reject
.Lscope92:
	.stabs  "",36,0,0,.Lscope92-.LFBB92	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Array_collect ########################	
		
	.stabs  "__method_Array_collect:F(0,0)",36,0,0,__method_Array_collect	
.globl __method_Array_collect
	.type	__method_Array_collect, @function
__method_Array_collect:
.LFBB93:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1003_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_collect", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1002, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1003_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1005_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_collect", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1002, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1005_else:
	# METHOD BODY:
	.stabn  68,0,69,.LM609	
.LM609:
	subl	$16, %esp
	addl	$4, %ebx
	subl	$20, %esp
	movl	$12, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	addl	$8, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	.stabn  68,0,70,.LM610	
.LM610:
	# if: :block_given?
	# if: [:ne, :__closure__, 0]
	movl	12(%ebp), %eax
	movl	%eax, %edi
	movl	$0, %eax
	cmpl	%eax, %edi
	setne	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1007_else
	# then: :true
	movl	true, %eax
	jmp	.L1008_endif
	# else: :false
.L1007_else:
	movl	false, %eax
.L1008_endif:
	cmpl	%eax, nil
	je	.L1009_else
	cmpl	%eax, false
	je	.L1009_else
	# then: [:do, [:assign, [:index, :__env__, 1], [:callm, :Array, :new]], [:call, :each, [], [:do, [:assign, [:index, :__env__, 0], [:stackframe]], [:assign, :__tmp_proc, [:defun, "__lambda_L70", [:self, :__closure__, :__env__, [:item, :default, :nil]], [:let, [], [:callm, [:index, :__env__, 1], :<<, [[:callm, [:index, :__env__, 2], :call, [:item]]]]]]], [:sexp, [:call, :__new_proc, [:__tmp_proc, :__env__, :self, 1]]]]], [:return, [:index, :__env__, 1]]]
	.stabn  68,0,71,.LM611	
.LM611:
	# callm :Array.:new
	subl	$24, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__new(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm Array.new END
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %edx
	addl	$4, %edx
	popl	%eax
	movl	%eax, (%edx)
	# callm :self.:each
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	.stabn  68,0,72,.LM612	
.LM612:
	# Stack frame
	pushl	%ebp
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	movl	$__lambda_L70, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	subl	$32, %esp
	movl	-16(%ebp), %eax
	movl	%eax, (%esp)
	movl	-12(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%esi, 8(%esp)
	movl	$1, 12(%esp)
	movl	$4, %ebx
	call	__new_proc
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__each(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.each END
	.stabn  68,0,74,.LM613	
.LM613:
	movl	-12(%ebp), %eax
	movl	%eax, %edi
	addl	$4, %edi
	movl	(%edi), %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	jmp	.L1011_endif
	# else: [:do, [:return, :self]]
.L1009_else:
	.stabn  68,0,77,.LM614	
.LM614:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
.L1011_endif:
	addl	$16, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_collect, .-__method_Array_collect
.Lscope93:
	.stabs  "",36,0,0,.Lscope93-.LFBB93	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Array_detect #########################	
		
	.stabs  "__method_Array_detect:F(0,0)",36,0,0,__method_Array_detect	
.globl __method_Array_detect
	.type	__method_Array_detect, @function
__method_Array_detect:
.LFBB94:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1013_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_detect", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1012, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1013_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1015_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_detect", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1012, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1015_else:
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for ifnone at position 4
	# :nil
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1017_else
	# then: [:assign, :"#ifnone", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L1018_endif
	# else: [:assign, :"#ifnone", :ifnone]
.L1017_else:
	# [:arg, 2, :ecx]
	movl	16(%ebp), %ecx
	pushl	%ecx
	popl	%eax
	movl	%eax, -8(%ebp)
.L1018_endif:
	# METHOD BODY:
	.stabn  68,0,83,.LM615	
.LM615:
	subl	$16, %esp
	addl	$4, %ebx
	subl	$20, %esp
	movl	$8, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-16(%ebp), %eax
	movl	%eax, %edx
	addl	$4, %edx
	popl	%eax
	movl	%eax, (%edx)
	.stabn  68,0,84,.LM616	
.LM616:
	# callm :self.:each
	subl	$24, %esp
	movl	%esi, (%esp)
	# Stack frame
	pushl	%ebp
	movl	-16(%ebp), %eax
	movl	%eax, %edi
	popl	%eax
	movl	%eax, (%edi)
	movl	$__lambda_L71, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	subl	$32, %esp
	movl	-20(%ebp), %eax
	movl	%eax, (%esp)
	movl	-16(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%esi, 8(%esp)
	movl	$1, 12(%esp)
	movl	$4, %ebx
	call	__new_proc
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__each(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.each END
	.stabn  68,0,88,.LM617	
.LM617:
	# if: :ifnone
	# [:lvar, 0, :ecx]
	movl	-8(%ebp), %ecx
	movl	%ecx, %eax
	cmpl	%eax, nil
	je	.L1020_else
	cmpl	%eax, false
	je	.L1020_else
	# then: [:do, [:return, [:callm, :ifnone, :call]]]
	.stabn  68,0,90,.LM618	
.LM618:
	# callm :ifnone.:call
	subl	$24, %esp
	# [:lvar, 0, :edx]
	movl	-8(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__call(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm ifnone.call END
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L1020_else:
	.stabn  68,0,91,.LM619	
.LM619:
	movl	nil, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	addl	$16, %esp
	addl	$4, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_detect, .-__method_Array_detect
.Lscope94:
	.stabs  "",36,0,0,.Lscope94-.LFBB94	
		
	########################################################################	
		
		
		
		
		
		
		
	#################### __method_Array_each_with_index ####################	
		
	.stabs  "__method_Array_each_with_index:F(0,0)",36,0,0,__method_Array_each_with_index	
.globl __method_Array_each_with_index
	.type	__method_Array_each_with_index, @function
__method_Array_each_with_index:
.LFBB95:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1023_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_each_with_index", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1022, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1023_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1025_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_each_with_index", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1022, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1025_else:
	# METHOD BODY:
	.stabn  68,0,96,.LM620	
.LM620:
	subl	$16, %esp
	addl	$4, %ebx
	subl	$20, %esp
	movl	$12, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# [:arg, 1, :edi]
	movl	12(%ebp), %edi
	pushl	%edi
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %edx
	addl	$8, %edx
	popl	%eax
	movl	%eax, (%edx)
	.stabn  68,0,97,.LM621	
.LM621:
	# callm :self.:each_index
	subl	$24, %esp
	movl	%esi, (%esp)
	# Stack frame
	pushl	%ebp
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	movl	$__lambda_L72, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	subl	$32, %esp
	movl	-16(%ebp), %eax
	movl	%eax, (%esp)
	movl	-12(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%esi, 8(%esp)
	movl	$1, 12(%esp)
	movl	$4, %ebx
	call	__new_proc
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__each_index(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.each_index END
	addl	$16, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_each_with_index, .-__method_Array_each_with_index
.Lscope95:
	.stabs  "",36,0,0,.Lscope95-.LFBB95	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Array___plus #########################	
		
	.stabs  "__method_Array___plus:F(0,0)",36,0,0,__method_Array___plus	
.globl __method_Array___plus
	.type	__method_Array___plus, @function
__method_Array___plus:
.LFBB96:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$3, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1029_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array___plus", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1028, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1029_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1031_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array___plus", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1028, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1031_else:
	# METHOD BODY:
	.stabn  68,0,128,.LM622	
.LM622:
	subl	$12, %esp
	addl	$3, %ebx
	.stabn  68,0,129,.LM623	
.LM623:
	# callm :self.:dup
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__dup(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.dup END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# callm :added.:concat
	subl	$28, %esp
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	movl	%edi, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__concat(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm added.concat END
	.stabn  68,0,130,.LM624	
.LM624:
	# [:lvar, 1, :edx]
	movl	-12(%ebp), %edx
	movl	%edx, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	addl	$12, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array___plus, .-__method_Array___plus
.Lscope96:
	.stabs  "",36,0,0,.Lscope96-.LFBB96	
		
	########################################################################	
		
		
		
		
		
		
		
	####################### __method_Array___lt__lt ########################	
		
	.stabs  "__method_Array___lt__lt:F(0,0)",36,0,0,__method_Array___lt__lt	
.globl __method_Array___lt__lt
	.type	__method_Array___lt__lt, @function
__method_Array___lt__lt:
.LFBB97:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1034_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array___lt__lt", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1033, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1034_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1036_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array___lt__lt", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1033, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1036_else:
	# METHOD BODY:
	.stabn  68,0,147,.LM625	
.LM625:
	subl	$12, %esp
	addl	$3, %ebx
	.stabn  68,0,148,.LM626	
.LM626:
	# if: [:le, :@len, :@capacity]
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	movl	%eax, %ecx
	movl	12(%esi), %eax
	cmpl	%eax, %ecx
	setle	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1038_else
	# then: [:callm, :self, :__grow, [[:mul, [:add, :@len, 1], 2]]]
	# callm :self.:__grow
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	4(%esi), %eax
	movl	%eax, %edi
	movl	$1, %eax
	addl	%edi, %eax
	movl	%eax, %edx
	movl	$2, %eax
	imull	%edx, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____grow(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.__grow END
	# else: nil
.L1038_else:
	# [:arg, 2, :ecx]
	movl	16(%ebp), %ecx
	pushl	%ecx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	8(%esi), %eax
	movl	%eax, %edi
	pushl	%edi
	movl	4(%esi), %eax
	sall	$2, %eax
	popl	%edi
	addl	%eax, %edi
	popl	%eax
	movl	%eax, (%edi)
	.stabn  68,0,149,.LM627	
.LM627:
	movl	4(%esi), %eax
	movl	%eax, %edx
	movl	$1, %eax
	addl	%edx, %eax
	pushl	%eax
	popl	%eax
	pushl	%eax
	popl	%edi
	movl	%edi, 4(%esi)
	movl	%esi, %eax
	addl	$12, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array___lt__lt, .-__method_Array___lt__lt
.Lscope97:
	.stabs  "",36,0,0,.Lscope97-.LFBB97	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Array___eq ##########################	
		
	.stabs  "__method_Array___eq:F(0,0)",36,0,0,__method_Array___eq	
.globl __method_Array___eq
	.type	__method_Array___eq, @function
__method_Array___eq:
.LFBB98:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$3, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1041_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array___eq", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1040, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1041_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1043_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array___eq", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1040, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1043_else:
	# METHOD BODY:
	.stabn  68,0,182,.LM628	
.LM628:
	subl	$16, %esp
	addl	$4, %ebx
	subl	$20, %esp
	movl	$12, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# [:arg, 2, :ecx]
	movl	16(%ebp), %ecx
	pushl	%ecx
	movl	-12(%ebp), %eax
	movl	%eax, %edi
	addl	$4, %edi
	popl	%eax
	movl	%eax, (%edi)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %edx
	addl	$8, %edx
	popl	%eax
	movl	%eax, (%edx)
	.stabn  68,0,183,.LM629	
.LM629:
	# if: [:callm, [:callm, [:index, :__env__, 1], :is_a?, [:Array]], :!]
	# callm [:callm, [:index, :__env__, 1], :is_a?, [:Array]].:!
	subl	$24, %esp
	# callm [:index, :__env__, 1].:is_a?
	subl	$28, %esp
	movl	-12(%ebp), %eax
	movl	%eax, %edi
	addl	$4, %edi
	movl	(%edi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	Array, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__is_a__Q(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].is_a? END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____X(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:index, :__env__, 1], :is_a?, [:Array]].! END
	cmpl	%eax, nil
	je	.L1045_else
	cmpl	%eax, false
	je	.L1045_else
	# then: [:do, [:return, :false]]
	.stabn  68,0,184,.LM630	
.LM630:
	movl	false, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L1045_else:
	.stabn  68,0,185,.LM631	
.LM631:
	# if: [:callm, [:callm, :self, :size], :==, [[:callm, [:index, :__env__, 1], :size]]]
	# callm [:callm, :self, :size].:==
	subl	$28, %esp
	# callm :self.:size
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__size(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.size END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm [:index, :__env__, 1].:size
	subl	$24, %esp
	movl	-12(%ebp), %eax
	movl	%eax, %edx
	addl	$4, %edx
	movl	(%edx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__size(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].size END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :self, :size].== END
	cmpl	%eax, nil
	je	.L1047_else
	cmpl	%eax, false
	je	.L1047_else
	# then: [:do, [:callm, :self, :each_index, [], [:do, [:assign, [:index, :__env__, 0], [:stackframe]], [:assign, :__tmp_proc, [:defun, "__lambda_L73", [:self, :__closure__, :__env__, [:i, :default, :nil]], [:let, [], [:if, [:callm, [:callm, :self, :[], [:i]], :!=, [[:callm, [:index, :__env__, 1], :[], [:i]]]], [:do, [:preturn, :false]]]]]], [:sexp, [:call, :__new_proc, [:__tmp_proc, :__env__, :self, 1]]]]], [:return, :true]]
	.stabn  68,0,188,.LM632	
.LM632:
	# callm :self.:each_index
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	# Stack frame
	pushl	%ebp
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	movl	$__lambda_L73, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	subl	$32, %esp
	movl	-16(%ebp), %eax
	movl	%eax, (%esp)
	movl	-12(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%esi, 8(%esp)
	movl	$1, 12(%esp)
	movl	$4, %ebx
	call	__new_proc
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__each_index(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.each_index END
	.stabn  68,0,192,.LM633	
.LM633:
	movl	true, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L1047_else:
	.stabn  68,0,194,.LM634	
.LM634:
	movl	false, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	addl	$16, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array___eq, .-__method_Array___eq
.Lscope98:
	.stabs  "",36,0,0,.Lscope98-.LFBB98	
		
	########################################################################	
		
		
		
		
		
		
		
	########################### __method____NDX ############################	
		
	.stabs  "__method____NDX:F(0,0)",36,0,0,__method____NDX	
.globl __method____NDX
	.type	__method____NDX, @function
__method____NDX:
.LFBB99:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1051_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method____NDX", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1050, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1051_else:
	# METHOD BODY:
	.stabn  68,0,200,.LM635	
.LM635:
	subl	$20, %esp
	addl	$5, %ebx
	subl	$24, %esp
	leal	16(%ebp), %eax
	movl	%eax, (%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$0, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	call	__splat_to_Array
	addl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -24(%ebp)
	subl	$20, %esp
	movl	$12, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-16(%ebp), %eax
	movl	%eax, %ecx
	addl	$8, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	.stabn  68,0,201,.LM636	
.LM636:
	# callm :self.:new
	subl	$24, %esp
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__new(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.new END
	pushl	%eax
	movl	-16(%ebp), %eax
	movl	%eax, %edx
	addl	$4, %edx
	popl	%eax
	movl	%eax, (%edx)
	# callm :elements.:each
	subl	$24, %esp
	# [:lvar, 4, :edi]
	movl	-24(%ebp), %edi
	movl	%edi, (%esp)
	.stabn  68,0,202,.LM637	
.LM637:
	# Stack frame
	pushl	%ebp
	movl	-16(%ebp), %eax
	movl	%eax, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	movl	$__lambda_L74, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	subl	$32, %esp
	movl	-20(%ebp), %eax
	movl	%eax, (%esp)
	movl	-16(%ebp), %eax
	movl	%eax, 4(%esp)
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, 8(%esp)
	movl	$1, 12(%esp)
	movl	$4, %ebx
	call	__new_proc
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__each(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm elements.each END
	movl	-16(%ebp), %eax
	movl	%eax, %edx
	addl	$4, %edx
	movl	(%edx), %eax
	addl	$20, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method____NDX, .-__method____NDX
.Lscope99:
	.stabs  "",36,0,0,.Lscope99-.LFBB99	
		
	########################################################################	
		
		
		
		
		
		
		
	#################### __method_Array___offset_to_pos ####################	
		
	.stabs  "__method_Array___offset_to_pos:F(0,0)",36,0,0,__method_Array___offset_to_pos	
.globl __method_Array___offset_to_pos
	.type	__method_Array___offset_to_pos, @function
__method_Array___offset_to_pos:
.LFBB100:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1055_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array___offset_to_pos", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1054, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1055_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1057_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array___offset_to_pos", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1054, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1057_else:
	# METHOD BODY:
	.stabn  68,0,212,.LM638	
.LM638:
	.stabn  68,0,213,.LM639	
.LM639:
	# callm :idx.:__get_raw
	subl	$24, %esp
	movl	16(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____get_raw(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm idx.__get_raw END
	pushl	%eax
	popl	%eax
	movl	%eax, 16(%ebp)
	# if: [:lt, :idx, 0]
	movl	16(%ebp), %eax
	movl	%eax, %ecx
	movl	$0, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1059_else
	# then: [:do, [:assign, :idx, [:add, :@len, :idx]], [:if, [:lt, :idx, 0], [:return, -1]]]
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	movl	%eax, %edi
	movl	16(%ebp), %eax
	addl	%edi, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, 16(%ebp)
	# if: [:lt, :idx, 0]
	movl	16(%ebp), %eax
	movl	%eax, %edx
	movl	$0, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1060_else
	# then: [:return, -1]
	movl	$-1, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L1060_else:
	# else: nil
.L1059_else:
	.stabn  68,0,218,.LM640	
.LM640:
	# if: [:ge, :idx, :@len]
	movl	16(%ebp), %eax
	movl	%eax, %ecx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	cmpl	%eax, %ecx
	setge	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1063_else
	# then: [:return, -1]
	movl	$-1, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L1063_else:
	.stabn  68,0,221,.LM641	
.LM641:
	movl	16(%ebp), %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array___offset_to_pos, .-__method_Array___offset_to_pos
.Lscope100:
	.stabs  "",36,0,0,.Lscope100-.LFBB100	
		
	########################################################################	
		
		
		
		
		
		
		
	###################### __method_Array___range_get ######################	
		
	.stabs  "__method_Array___range_get:F(0,0)",36,0,0,__method_Array___range_get	
.globl __method_Array___range_get
	.type	__method_Array___range_get, @function
__method_Array___range_get:
.LFBB101:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1066_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array___range_get", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1065, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1066_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1068_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array___range_get", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1065, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1068_else:
	# METHOD BODY:
	.stabn  68,0,229,.LM642	
.LM642:
	subl	$20, %esp
	addl	$5, %ebx
	.stabn  68,0,230,.LM643	
.LM643:
	# callm :idx.:first
	subl	$24, %esp
	# [:arg, 2, :ecx]
	movl	16(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__first(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm idx.first END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# callm :idx.:last
	subl	$24, %esp
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__last(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm idx.last END
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	.stabn  68,0,231,.LM644	
.LM644:
	subl	$20, %esp
	# callm :self.:__offset_to_pos
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 1, :edx]
	movl	-12(%ebp), %edx
	movl	%edx, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____offset_to_pos(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.__offset_to_pos END
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__int
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	.stabn  68,0,232,.LM645	
.LM645:
	subl	$20, %esp
	# callm :self.:__offset_to_pos
	subl	$28, %esp
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 2, :ecx]
	movl	-16(%ebp), %ecx
	movl	%ecx, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____offset_to_pos(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.__offset_to_pos END
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__int
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	.stabn  68,0,233,.LM646	
.LM646:
	# if: [:callm, :start, :<, [[:sexp, :__I0]]]
	# callm :start.:<
	subl	$28, %esp
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	__I0, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm start.< END
	cmpl	%eax, nil
	je	.L1070_else
	cmpl	%eax, false
	je	.L1070_else
	# then: [:do, [:return, [:callm, :Array, :new]]]
	.stabn  68,0,236,.LM647	
.LM647:
	# callm :Array.:new
	subl	$24, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__new(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm Array.new END
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L1070_else:
	.stabn  68,0,237,.LM648	
.LM648:
	# if: [:callm, :xend, :<, [[:sexp, :__I0]]]
	# callm :xend.:<
	subl	$28, %esp
	# [:lvar, 2, :edx]
	movl	-16(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	__I0, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm xend.< END
	cmpl	%eax, nil
	je	.L1072_else
	cmpl	%eax, false
	je	.L1072_else
	# then: [:do, [:assign, :xend, [:callm, :length, :-, [[:sexp, :__I1]]]]]
	.stabn  68,0,240,.LM649	
.LM649:
	# callm :length.:-
	subl	$28, %esp
	# callm :self.:length
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__length(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.length END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____minus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm length.- END
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	# else: nil
.L1072_else:
	.stabn  68,0,241,.LM650	
.LM650:
	# callm :Array.:new
	subl	$24, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__new(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm Array.new END
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	.stabn  68,0,249,.LM651	
.LM651:
.L1075:
	# callm :start.:<=
	subl	$28, %esp
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 2, :edi]
	movl	-16(%ebp), %edi
	movl	%edi, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____le(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm start.<= END
	cmpl	%eax, nil
	je	.L1074
	cmpl	%eax, false
	je	.L1074
	.stabn  68,0,251,.LM652	
.LM652:
	# callm :tmp.:<<
	subl	$28, %esp
	# [:lvar, 3, :edx]
	movl	-20(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	# callm :self.:[]
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.[] END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt__lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm tmp.<< END
	.stabn  68,0,252,.LM653	
.LM653:
	# callm :start.:+
	subl	$28, %esp
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm start.+ END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	jmp	.L1075
.L1074:
	movl	nil, %eax
	.stabn  68,0,254,.LM654	
.LM654:
	# [:lvar, 3, :edx]
	movl	-20(%ebp), %edx
	movl	%edx, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	addl	$20, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array___range_get, .-__method_Array___range_get
.Lscope101:
	.stabs  "",36,0,0,.Lscope101-.LFBB101	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Array___NDX #########################	
		
	.stabs  "__method_Array___NDX:F(0,0)",36,0,0,__method_Array___NDX	
.globl __method_Array___NDX
	.type	__method_Array___NDX, @function
__method_Array___NDX:
.LFBB102:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1077_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array___NDX", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1076, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1077_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1079_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array___NDX", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1076, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1079_else:
	# METHOD BODY:
	.stabn  68,0,263,.LM655	
.LM655:
	subl	$12, %esp
	addl	$3, %ebx
	.stabn  68,0,265,.LM656	
.LM656:
	# if: [:callm, :idx, :is_a?, [:Range]]
	# callm :idx.:is_a?
	subl	$28, %esp
	# [:arg, 2, :ecx]
	movl	16(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	Range, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__is_a__Q(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm idx.is_a? END
	cmpl	%eax, nil
	je	.L1081_else
	cmpl	%eax, false
	je	.L1081_else
	# then: [:return, [:call, :__range_get, [:idx]]]
	# callm :self.:__range_get
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	movl	%edi, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____range_get(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.__range_get END
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L1081_else:
	# callm :self.:__offset_to_pos
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	# [:arg, 2, :edx]
	movl	16(%ebp), %edx
	movl	%edx, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____offset_to_pos(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.__offset_to_pos END
	pushl	%eax
	popl	%eax
	movl	%eax, 16(%ebp)
	.stabn  68,0,267,.LM657	
.LM657:
	# if: [:or, [:or, [:eq, :@ptr, 0], [:gt, :idx, :@len]], [:lt, :idx, 0]]
	# compile_or: [:or, [:eq, :@ptr, 0], [:gt, :idx, :@len]] || [:lt, :idx, 0]
	# compile_or: [:eq, :@ptr, 0] || [:gt, :idx, :@len]
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	8(%esi), %eax
	movl	%eax, %ecx
	movl	$0, %eax
	cmpl	%eax, %ecx
	sete	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1083_or
	jmp	.L1084_end_or
	# .. or:
.L1083_or:
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	# Locked register edi
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	# Unlocked register edi
.L1084_end_or:
	testl	%eax, %eax
	je	.L1085_or
	jmp	.L1086_end_or
	# .. or:
.L1085_or:
	# [:arg, 2, :edx]
	movl	16(%ebp), %edx
	# Locked register edx
	movl	$0, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	# Unlocked register edx
.L1086_end_or:
	testl	%eax, %eax
	je	.L1087_else
	# then: [:return, :nil]
	movl	nil, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L1087_else:
	.stabn  68,0,276,.LM658	
.LM658:
	# callm :self.:__get
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	# [:arg, 2, :ecx]
	movl	16(%ebp), %ecx
	movl	%ecx, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____get(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.__get END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	.stabn  68,0,278,.LM659	
.LM659:
	# if: [:eq, :tmp, 0]
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	# Locked register edi
	movl	$0, %eax
	cmpl	%eax, %edi
	sete	%al
	movzbl	%al, %eax
	# Unlocked register edi
	testl	%eax, %eax
	je	.L1089_else
	# then: [:return, :nil]
	movl	nil, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	jmp	.L1090_endif
	# else: [:return, :tmp]
.L1089_else:
	# [:lvar, 1, :edx]
	movl	-12(%ebp), %edx
	movl	%edx, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
.L1090_endif:
	addl	$12, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Array___NDX, .-__method_Array___NDX
.Lscope102:
	.stabs  "",36,0,0,.Lscope102-.LFBB102	
		
	########################################################################	
		
		
		
		
		
		
		
	####################### __method_Array___NDX__3d #######################	
		
	.stabs  "__method_Array___NDX__3d:F(0,0)",36,0,0,__method_Array___NDX__3d	
.globl __method_Array___NDX__3d
	.type	__method_Array___NDX__3d, @function
__method_Array___NDX__3d:
.LFBB103:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$4, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1092_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array___NDX__3d", 2, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1091, %eax
	movl	%eax, 4(%esp)
	movl	$2, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1092_else:
	# if: [:gt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$4, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1094_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array___NDX__3d", 2, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1091, %eax
	movl	%eax, 4(%esp)
	movl	$2, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1094_else:
	# METHOD BODY:
	.stabn  68,0,291,.LM660	
.LM660:
	subl	$12, %esp
	addl	$3, %ebx
	.stabn  68,0,292,.LM661	
.LM661:
	# callm :idx.:__get_raw
	subl	$24, %esp
	# [:arg, 2, :ecx]
	movl	16(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____get_raw(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm idx.__get_raw END
	pushl	%eax
	popl	%eax
	movl	%eax, 16(%ebp)
	# if: [:ge, :idx, :@capacity]
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	# Locked register edi
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	12(%esi), %eax
	cmpl	%eax, %edi
	setge	%al
	movzbl	%al, %eax
	# Unlocked register edi
	testl	%eax, %eax
	je	.L1096_else
	# then: [:callm, :self, :__grow, [:idx]]
	# callm :self.:__grow
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	# [:arg, 2, :edx]
	movl	16(%ebp), %edx
	movl	%edx, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____grow(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.__grow END
	# else: nil
.L1096_else:
	.stabn  68,0,303,.LM662	
.LM662:
	# if: [:ge, :idx, :@len]
	# [:arg, 2, :ecx]
	movl	16(%ebp), %ecx
	# Locked register ecx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	cmpl	%eax, %ecx
	setge	%al
	movzbl	%al, %eax
	# Unlocked register ecx
	testl	%eax, %eax
	je	.L1098_else
	# then: [:assign, :@len, [:add, :idx, 1]]
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	# Locked register edi
	movl	$1, %eax
	addl	%edi, %eax
	# Unlocked register edi
	pushl	%eax
	popl	%eax
	pushl	%eax
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%edx
	movl	%edx, 4(%esi)
	# else: nil
.L1098_else:
	.stabn  68,0,305,.LM663	
.LM663:
	# [:arg, 3, :ecx]
	movl	20(%ebp), %ecx
	pushl	%ecx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	8(%esi), %eax
	movl	%eax, %edx
	pushl	%edx
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	movl	%edi, %eax
	sall	$2, %eax
	popl	%edx
	addl	%eax, %edx
	popl	%eax
	movl	%eax, (%edx)
	addl	$12, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array___NDX__3d, .-__method_Array___NDX__3d
.Lscope103:
	.stabs  "",36,0,0,.Lscope103-.LFBB103	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Array_abbrev #########################	
		
	.stabs  "__method_Array_abbrev:F(0,0)",36,0,0,__method_Array_abbrev	
.globl __method_Array_abbrev
	.type	__method_Array_abbrev, @function
__method_Array_abbrev:
.LFBB104:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1101_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_abbrev", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1100, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1101_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1103_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_abbrev", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1100, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1103_else:
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for pattern at position 4
	# :nil
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1105_else
	# then: [:assign, :"#pattern", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L1106_endif
	# else: [:assign, :"#pattern", :pattern]
.L1105_else:
	movl	16(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L1106_endif:
	# METHOD BODY:
	.stabn  68,0,314,.LM664	
.LM664:
	.stabn  68,0,315,.LM665	
.LM665:
	subl	$20, %esp
	movl	$.L1107, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	puts
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	addl	$4, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_abbrev, .-__method_Array_abbrev
.Lscope104:
	.stabs  "",36,0,0,.Lscope104-.LFBB104	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Array_slice #########################	
		
	.stabs  "__method_Array_slice:F(0,0)",36,0,0,__method_Array_slice	
.globl __method_Array_slice
	.type	__method_Array_slice, @function
__method_Array_slice:
.LFBB105:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1109_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_slice", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1108, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1109_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1111_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_slice", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1108, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1111_else:
	# METHOD BODY:
	.stabn  68,0,318,.LM666	
.LM666:
	.stabn  68,0,319,.LM667	
.LM667:
	# callm :self.:[]
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.[] END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_slice, .-__method_Array_slice
.Lscope105:
	.stabs  "",36,0,0,.Lscope105-.LFBB105	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Array_assoc #########################	
		
	.stabs  "__method_Array_assoc:F(0,0)",36,0,0,__method_Array_assoc	
.globl __method_Array_assoc
	.type	__method_Array_assoc, @function
__method_Array_assoc:
.LFBB106:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1114_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_assoc", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1113, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1114_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1116_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_assoc", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1113, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1116_else:
	# METHOD BODY:
	.stabn  68,0,326,.LM668	
.LM668:
	subl	$16, %esp
	addl	$4, %ebx
	subl	$20, %esp
	movl	$12, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	pushl	%edi
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %edx
	addl	$8, %edx
	popl	%eax
	movl	%eax, (%edx)
	.stabn  68,0,327,.LM669	
.LM669:
	# callm :self.:each
	subl	$24, %esp
	movl	%esi, (%esp)
	# Stack frame
	pushl	%ebp
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	movl	$__lambda_L75, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	subl	$32, %esp
	movl	-16(%ebp), %eax
	movl	%eax, (%esp)
	movl	-12(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%esi, 8(%esp)
	movl	$1, 12(%esp)
	movl	$4, %ebx
	call	__new_proc
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__each(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.each END
	.stabn  68,0,333,.LM670	
.LM670:
	movl	nil, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	addl	$16, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_assoc, .-__method_Array_assoc
.Lscope106:
	.stabs  "",36,0,0,.Lscope106-.LFBB106	
		
	########################################################################	
		
		
		
		
		
		
		
	########################## __method_Array_at ###########################	
		
	.stabs  "__method_Array_at:F(0,0)",36,0,0,__method_Array_at	
.globl __method_Array_at
	.type	__method_Array_at, @function
__method_Array_at:
.LFBB107:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$3, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1120_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_at", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1119, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1120_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1122_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_at", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1119, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1122_else:
	# METHOD BODY:
	.stabn  68,0,342,.LM671	
.LM671:
	.stabn  68,0,344,.LM672	
.LM672:
	# callm :self.:[]
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.[] END
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_at, .-__method_Array_at
.Lscope107:
	.stabs  "",36,0,0,.Lscope107-.LFBB107	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Array_clear #########################	
		
	.stabs  "__method_Array_clear:F(0,0)",36,0,0,__method_Array_clear	
.globl __method_Array_clear
	.type	__method_Array_clear, @function
__method_Array_clear:
.LFBB108:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1125_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_clear", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1124, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1125_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1127_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_clear", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1124, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1127_else:
	# METHOD BODY:
	.stabn  68,0,349,.LM673	
.LM673:
	.stabn  68,0,351,.LM674	
.LM674:
	pushl	$0
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ecx
	movl	%ecx, 4(%esi)
	movl	%esi, %eax
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_clear, .-__method_Array_clear
.Lscope108:
	.stabs  "",36,0,0,.Lscope108-.LFBB108	
		
	########################################################################	
		
		
		
		
		
		
		
	###################### __method_Array_collect__X #######################	
		
	.stabs  "__method_Array_collect__X:F(0,0)",36,0,0,__method_Array_collect__X	
.globl __method_Array_collect__X
	.type	__method_Array_collect__X, @function
__method_Array_collect__X:
.LFBB109:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1130_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_collect__X", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1129, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1130_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1132_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_collect__X", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1129, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1132_else:
	# METHOD BODY:
	.stabn  68,0,359,.LM675	
.LM675:
	movl	nil, %eax
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_collect__X, .-__method_Array_collect__X
.Lscope109:
	.stabs  "",36,0,0,.Lscope109-.LFBB109	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Array_compact ########################	
		
	.stabs  "__method_Array_compact:F(0,0)",36,0,0,__method_Array_compact	
.globl __method_Array_compact
	.type	__method_Array_compact, @function
__method_Array_compact:
.LFBB110:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1135_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_compact", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1134, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1135_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1137_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_compact", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1134, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1137_else:
	# METHOD BODY:
	.stabn  68,0,365,.LM676	
.LM676:
	subl	$16, %esp
	addl	$4, %ebx
	subl	$20, %esp
	movl	$8, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	.stabn  68,0,366,.LM677	
.LM677:
	# callm :self.:reject
	subl	$24, %esp
	movl	%esi, (%esp)
	# Stack frame
	pushl	%ebp
	movl	-12(%ebp), %eax
	movl	%eax, %edi
	popl	%eax
	movl	%eax, (%edi)
	movl	$__lambda_L76, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	subl	$32, %esp
	movl	-16(%ebp), %eax
	movl	%eax, (%esp)
	movl	-12(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%esi, 8(%esp)
	movl	$1, 12(%esp)
	movl	$4, %ebx
	call	__new_proc
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__reject(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.reject END
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	addl	$16, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_compact, .-__method_Array_compact
.Lscope110:
	.stabs  "",36,0,0,.Lscope110-.LFBB110	
		
	########################################################################	
		
		
		
		
		
		
		
	###################### __method_Array_compact__X #######################	
		
	.stabs  "__method_Array_compact__X:F(0,0)",36,0,0,__method_Array_compact__X	
.globl __method_Array_compact__X
	.type	__method_Array_compact__X, @function
__method_Array_compact__X:
.LFBB111:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1141_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_compact__X", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1140, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1141_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1143_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_compact__X", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1140, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1143_else:
	# METHOD BODY:
	.stabn  68,0,371,.LM678	
.LM678:
	.stabn  68,0,372,.LM679	
.LM679:
	subl	$20, %esp
	movl	$.L1145, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	puts
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_compact__X, .-__method_Array_compact__X
.Lscope111:
	.stabs  "",36,0,0,.Lscope111-.LFBB111	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Array_concat #########################	
		
	.stabs  "__method_Array_concat:F(0,0)",36,0,0,__method_Array_concat	
.globl __method_Array_concat
	.type	__method_Array_concat, @function
__method_Array_concat:
.LFBB112:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1147_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_concat", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1146, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1147_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1149_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_concat", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1146, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1149_else:
	# METHOD BODY:
	.stabn  68,0,376,.LM680	
.LM680:
	subl	$16, %esp
	addl	$4, %ebx
	subl	$20, %esp
	movl	$12, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %edi
	addl	$8, %edi
	popl	%eax
	movl	%eax, (%edi)
	.stabn  68,0,377,.LM681	
.LM681:
	pushl	%esi
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	# callm :other_array.:each
	subl	$24, %esp
	# [:arg, 2, :edx]
	movl	16(%ebp), %edx
	movl	%edx, (%esp)
	.stabn  68,0,378,.LM682	
.LM682:
	# Stack frame
	pushl	%ebp
	movl	-12(%ebp), %eax
	movl	%eax, %edi
	popl	%eax
	movl	%eax, (%edi)
	movl	$__lambda_L77, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	subl	$32, %esp
	movl	-16(%ebp), %eax
	movl	%eax, (%esp)
	movl	-12(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%esi, 8(%esp)
	movl	$1, 12(%esp)
	movl	$4, %ebx
	call	__new_proc
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__each(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm other_array.each END
	.stabn  68,0,380,.LM683	
.LM683:
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	movl	(%ecx), %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	addl	$16, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_concat, .-__method_Array_concat
.Lscope112:
	.stabs  "",36,0,0,.Lscope112-.LFBB112	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Array_dclone #########################	
		
	.stabs  "__method_Array_dclone:F(0,0)",36,0,0,__method_Array_dclone	
.globl __method_Array_dclone
	.type	__method_Array_dclone, @function
__method_Array_dclone:
.LFBB113:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1153_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_dclone", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1152, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1153_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1155_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_dclone", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1152, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1155_else:
	# METHOD BODY:
	.stabn  68,0,385,.LM684	
.LM684:
	.stabn  68,0,386,.LM685	
.LM685:
	subl	$20, %esp
	movl	$.L1157, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	puts
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_dclone, .-__method_Array_dclone
.Lscope113:
	.stabs  "",36,0,0,.Lscope113-.LFBB113	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Array_delete #########################	
		
	.stabs  "__method_Array_delete:F(0,0)",36,0,0,__method_Array_delete	
.globl __method_Array_delete
	.type	__method_Array_delete, @function
__method_Array_delete:
.LFBB114:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1159_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_delete", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1158, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1159_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1161_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_delete", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1158, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1161_else:
	# METHOD BODY:
	.stabn  68,0,393,.LM686	
.LM686:
	subl	$24, %esp
	addl	$6, %ebx
	.stabn  68,0,394,.LM687	
.LM687:
	movl	__I0, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	movl	__I0, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	.stabn  68,0,395,.LM688	
.LM688:
	# callm :self.:length
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__length(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.length END
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	.stabn  68,0,396,.LM689	
.LM689:
.L1164:
	# callm :src.:<
	subl	$28, %esp
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 3, :edi]
	movl	-20(%ebp), %edi
	movl	%edi, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm src.< END
	cmpl	%eax, nil
	je	.L1163
	cmpl	%eax, false
	je	.L1163
	.stabn  68,0,398,.LM690	
.LM690:
	# callm :self.:[]
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 1, :edx]
	movl	-12(%ebp), %edx
	movl	%edx, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.[] END
	pushl	%eax
	popl	%eax
	movl	%eax, -24(%ebp)
	.stabn  68,0,399,.LM691	
.LM691:
	# if: [:callm, :sob, :!=, [:obj]]
	# callm :sob.:!=
	subl	$28, %esp
	# [:lvar, 4, :ecx]
	movl	-24(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	movl	%edi, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____X__3d(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm sob.!= END
	cmpl	%eax, nil
	je	.L1165_else
	cmpl	%eax, false
	je	.L1165_else
	# then: [:do, [:if, [:callm, :src, :!=, [:dest]], [:do, [:callm, :self, :[]=, [:dest, :sob]]]], [:assign, :dest, [:callm, :dest, :+, [[:sexp, :__I1]]]]]
	.stabn  68,0,401,.LM692	
.LM692:
	# if: [:callm, :src, :!=, [:dest]]
	# callm :src.:!=
	subl	$28, %esp
	# [:lvar, 1, :edx]
	movl	-12(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 2, :ecx]
	movl	-16(%ebp), %ecx
	movl	%ecx, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____X__3d(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm src.!= END
	cmpl	%eax, nil
	je	.L1166_else
	cmpl	%eax, false
	je	.L1166_else
	# then: [:do, [:callm, :self, :[]=, [:dest, :sob]]]
	.stabn  68,0,402,.LM693	
.LM693:
	# callm :self.:[]=
	subl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 2, :edi]
	movl	-16(%ebp), %edi
	movl	%edi, 8(%esp)
	# [:lvar, 4, :edx]
	movl	-24(%ebp), %edx
	movl	%edx, 12(%esp)
	movl	$4, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____NDX__3d(%eax)
	# Evicting self
	# Static adj: 32
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.[]= END
	# else: nil
.L1166_else:
	.stabn  68,0,403,.LM694	
.LM694:
	# callm :dest.:+
	subl	$28, %esp
	# [:lvar, 2, :ecx]
	movl	-16(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm dest.+ END
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	# else: nil
.L1165_else:
	.stabn  68,0,405,.LM695	
.LM695:
	# callm :src.:+
	subl	$28, %esp
	# [:lvar, 1, :edx]
	movl	-12(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm src.+ END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	jmp	.L1164
.L1163:
	movl	nil, %eax
	.stabn  68,0,407,.LM696	
.LM696:
	# callm :dest.:__get_raw
	subl	$24, %esp
	# [:lvar, 2, :edi]
	movl	-16(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____get_raw(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm dest.__get_raw END
	pushl	%eax
	popl	%eax
	pushl	%eax
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ecx
	movl	%ecx, 4(%esi)
	# [:arg, 2, :edx]
	movl	16(%ebp), %edx
	movl	%edx, %eax
	addl	$24, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_delete, .-__method_Array_delete
.Lscope114:
	.stabs  "",36,0,0,.Lscope114-.LFBB114	
		
	########################################################################	
		
		
		
		
		
		
		
	####################### __method_Array_delete_at #######################	
		
	.stabs  "__method_Array_delete_at:F(0,0)",36,0,0,__method_Array_delete_at	
.globl __method_Array_delete_at
	.type	__method_Array_delete_at, @function
__method_Array_delete_at:
.LFBB115:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1170_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_delete_at", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1169, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1170_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1172_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_delete_at", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1169, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1172_else:
	# METHOD BODY:
	.stabn  68,0,415,.LM697	
.LM697:
	subl	$24, %esp
	addl	$6, %ebx
	.stabn  68,0,416,.LM698	
.LM698:
	# if: [:callm, :idx, :<, [[:sexp, :__I0]]]
	# callm :idx.:<
	subl	$28, %esp
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	__I0, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm idx.< END
	cmpl	%eax, nil
	je	.L1174_else
	cmpl	%eax, false
	je	.L1174_else
	# then: [:return, :nil]
	movl	nil, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L1174_else:
	# callm :self.:length
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__length(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.length END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	.stabn  68,0,418,.LM699	
.LM699:
	# if: [:callm, :idx, :>=, [:l]]
	# callm :idx.:>=
	subl	$28, %esp
	# [:arg, 2, :ecx]
	movl	16(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 1, :edx]
	movl	-12(%ebp), %edx
	movl	%edx, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____ge(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm idx.>= END
	cmpl	%eax, nil
	je	.L1176_else
	cmpl	%eax, false
	je	.L1176_else
	# then: [:return, :nil]
	movl	nil, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L1176_else:
	.stabn  68,0,419,.LM700	
.LM700:
	# callm :self.:[]
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	movl	%edi, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.[] END
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	.stabn  68,0,421,.LM701	
.LM701:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%esi
	popl	%eax
	movl	%eax, -20(%ebp)
	.stabn  68,0,423,.LM702	
.LM702:
.L1179:
	# callm :idx.:<
	subl	$28, %esp
	# [:arg, 2, :edx]
	movl	16(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm idx.< END
	cmpl	%eax, nil
	je	.L1178
	cmpl	%eax, false
	je	.L1178
	.stabn  68,0,424,.LM703	
.LM703:
	# callm :x.:[]
	subl	$28, %esp
	# [:lvar, 3, :edi]
	movl	-20(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	# callm :idx.:+
	subl	$28, %esp
	# [:arg, 2, :edx]
	movl	16(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm idx.+ END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm x.[] END
	pushl	%eax
	popl	%eax
	movl	%eax, -24(%ebp)
	.stabn  68,0,428,.LM704	
.LM704:
	# callm :x.:[]=
	subl	$32, %esp
	# [:lvar, 3, :ecx]
	movl	-20(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	movl	%edi, 8(%esp)
	# [:lvar, 4, :edx]
	movl	-24(%ebp), %edx
	movl	%edx, 12(%esp)
	movl	$4, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX__3d(%eax)
	# Evicting self
	# Static adj: 32
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm x.[]= END
	.stabn  68,0,429,.LM705	
.LM705:
	# callm :idx.:+
	subl	$28, %esp
	# [:arg, 2, :edx]
	movl	16(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm idx.+ END
	pushl	%eax
	popl	%eax
	movl	%eax, 16(%ebp)
	jmp	.L1179
.L1178:
	movl	nil, %eax
	.stabn  68,0,431,.LM706	
.LM706:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	movl	%eax, %ecx
	movl	$1, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	pushl	%eax
	popl	%eax
	pushl	%eax
	popl	%edi
	movl	%edi, 4(%esi)
	.stabn  68,0,433,.LM707	
.LM707:
	# [:lvar, 2, :edx]
	movl	-16(%ebp), %edx
	movl	%edx, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	addl	$24, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_delete_at, .-__method_Array_delete_at
.Lscope115:
	.stabs  "",36,0,0,.Lscope115-.LFBB115	
		
	########################################################################	
		
		
		
		
		
		
		
	####################### __method_Array_delete_if #######################	
		
	.stabs  "__method_Array_delete_if:F(0,0)",36,0,0,__method_Array_delete_if	
.globl __method_Array_delete_if
	.type	__method_Array_delete_if, @function
__method_Array_delete_if:
.LFBB116:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1181_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_delete_if", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1180, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1181_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1183_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_delete_if", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1180, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1183_else:
	# METHOD BODY:
	.stabn  68,0,439,.LM708	
.LM708:
	.stabn  68,0,440,.LM709	
.LM709:
	subl	$20, %esp
	movl	$.L1185, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	puts
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_delete_if, .-__method_Array_delete_if
.Lscope116:
	.stabs  "",36,0,0,.Lscope116-.LFBB116	
		
	########################################################################	
		
		
		
		
		
		
		
	########################## __method_Array_dup ##########################	
		
	.stabs  "__method_Array_dup:F(0,0)",36,0,0,__method_Array_dup	
.globl __method_Array_dup
	.type	__method_Array_dup, @function
__method_Array_dup:
.LFBB117:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1187_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_dup", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1186, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1187_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1189_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_dup", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1186, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1189_else:
	# METHOD BODY:
	.stabn  68,0,444,.LM710	
.LM710:
	subl	$16, %esp
	addl	$4, %ebx
	subl	$20, %esp
	movl	$12, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	addl	$8, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	.stabn  68,0,445,.LM711	
.LM711:
	# callm [:callm, :self, :class].:new
	subl	$24, %esp
	# callm :self.:class
	subl	$24, %esp
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__class(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.class END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__new(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :self, :class].new END
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %edi
	addl	$4, %edi
	popl	%eax
	movl	%eax, (%edi)
	# callm :self.:each
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	.stabn  68,0,446,.LM712	
.LM712:
	# Stack frame
	pushl	%ebp
	movl	-12(%ebp), %eax
	movl	%eax, %edx
	popl	%eax
	movl	%eax, (%edx)
	movl	$__lambda_L78, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	subl	$32, %esp
	movl	-16(%ebp), %eax
	movl	%eax, (%esp)
	movl	-12(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%esi, 8(%esp)
	movl	$1, 12(%esp)
	movl	$4, %ebx
	call	__new_proc
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__each(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.each END
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	movl	(%ecx), %eax
	addl	$16, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_dup, .-__method_Array_dup
.Lscope117:
	.stabs  "",36,0,0,.Lscope117-.LFBB117	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Array_each ##########################	
		
	.stabs  "__method_Array_each:F(0,0)",36,0,0,__method_Array_each	
.globl __method_Array_each
	.type	__method_Array_each, @function
__method_Array_each:
.LFBB118:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1193_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_each", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1192, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1193_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1195_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_each", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1192, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1195_else:
	# METHOD BODY:
	.stabn  68,0,454,.LM713	
.LM713:
	subl	$32, %esp
	addl	$8, %ebx
	subl	$20, %esp
	movl	$8, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -28(%ebp)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-28(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	.stabn  68,0,455,.LM714	
.LM714:
	movl	__I0, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# callm :block.:arity
	subl	$24, %esp
	# [:arg, 1, :edi]
	movl	12(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__arity(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm block.arity END
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	.stabn  68,0,456,.LM715	
.LM715:
	# callm :self.:size
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__size(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.size END
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	.stabn  68,0,457,.LM716	
.LM716:
	# if: [:callm, :a, :==, [[:sexp, :__I1]]]
	# callm :a.:==
	subl	$28, %esp
	# [:lvar, 2, :edx]
	movl	-16(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm a.== END
	cmpl	%eax, nil
	je	.L1197_else
	cmpl	%eax, false
	je	.L1197_else
	# then: [:do, [:while, [:callm, :i, :<, [:s]], [:do, [:assign, :el, [:callm, :self, :[], [:i]]], [:callm, [:index, :__env__, 1], :call, [:el]], [:assign, :i, [:callm, :i, :+, [[:sexp, :__I1]]]]]], [:return, :nil]]
	.stabn  68,0,460,.LM717	
.LM717:
.L1199:
	# callm :i.:<
	subl	$28, %esp
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 3, :edi]
	movl	-20(%ebp), %edi
	movl	%edi, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm i.< END
	cmpl	%eax, nil
	je	.L1198
	cmpl	%eax, false
	je	.L1198
	# callm :self.:[]
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 1, :edx]
	movl	-12(%ebp), %edx
	movl	%edx, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.[] END
	pushl	%eax
	popl	%eax
	movl	%eax, -24(%ebp)
	.stabn  68,0,461,.LM718	
.LM718:
	# callm [:index, :__env__, 1].:call
	subl	$28, %esp
	movl	-28(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	movl	(%ecx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 4, :edi]
	movl	-24(%ebp), %edi
	movl	%edi, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__call(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].call END
	.stabn  68,0,462,.LM719	
.LM719:
	# callm :i.:+
	subl	$28, %esp
	# [:lvar, 1, :edx]
	movl	-12(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm i.+ END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	jmp	.L1199
.L1198:
	movl	nil, %eax
	.stabn  68,0,464,.LM720	
.LM720:
	movl	nil, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L1197_else:
	.stabn  68,0,466,.LM721	
.LM721:
.L1202:
	# callm :i.:<
	subl	$28, %esp
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 3, :edi]
	movl	-20(%ebp), %edi
	movl	%edi, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm i.< END
	cmpl	%eax, nil
	je	.L1201
	cmpl	%eax, false
	je	.L1201
	.stabn  68,0,468,.LM722	
.LM722:
	# callm :self.:[]
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 1, :edx]
	movl	-12(%ebp), %edx
	movl	%edx, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.[] END
	pushl	%eax
	popl	%eax
	movl	%eax, -24(%ebp)
	.stabn  68,0,469,.LM723	
.LM723:
	# if: [:callm, :el, :is_a?, [:Array]]
	# callm :el.:is_a?
	subl	$28, %esp
	# [:lvar, 4, :ecx]
	movl	-24(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	Array, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__is_a__Q(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm el.is_a? END
	cmpl	%eax, nil
	je	.L1203_else
	cmpl	%eax, false
	je	.L1203_else
	# then: [:do, [:callm, [:index, :__env__, 1], :call, [[:splat, :el]]]]
	.stabn  68,0,471,.LM724	
.LM724:
	# callm [:index, :__env__, 1].:call
	# BEGIN Calculating argument count for splat
	# [:lvar, 4, :edi]
	movl	-24(%ebp), %edi
	movl	%edi, %edx
	addl	$4, %edx
	movl	(%edx), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	addl	%ecx, %eax
	movl	%eax, %ebx
	# END Calculating argument count for splat; numargs is now in ebx
	# Moving stack pointer to start of argument array:
	imull	$4, %eax
	subl	%eax, %esp
	# BEGIN Pushing arguments:
	movl	%esp, %edx
	pushl	%ebx
	# BEGIN args.each do |a|
	movl	-28(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	movl	(%ecx), %eax
	movl	%eax, (%edx)
	addl	$4, %edx
	movl	$0, (%edx)
	addl	$4, %edx
	# SPLAT
	addl	$4, %edi
	movl	(%edi), %ecx
	addl	$4, %edi
	movl	(%edi), %eax
	testl	%eax, %eax
	je	.L1204
.L1206:
	testl	%ecx, %ecx
	je	.L1205
	pushl	(%eax)
	popl	(%edx)
	addl	$4, %eax
	addl	$4, %edx
	subl	$1, %ecx
	jmp	.L1206
.L1205:
.L1204:
	# END args.each
	popl	%ebx
	# END Pushing arguments
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__call(%eax)
	# Evicting self
	# Re-adjusting stack post-call:
	imull	$4, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].call END
	jmp	.L1207_endif
	# else: [:do, [:callm, [:index, :__env__, 1], :call, [:el]]]
.L1203_else:
	.stabn  68,0,473,.LM725	
.LM725:
	# callm [:index, :__env__, 1].:call
	subl	$28, %esp
	movl	-28(%ebp), %eax
	movl	%eax, %edi
	addl	$4, %edi
	movl	(%edi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 4, :ecx]
	movl	-24(%ebp), %ecx
	movl	%ecx, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__call(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].call END
.L1207_endif:
	.stabn  68,0,474,.LM726	
.LM726:
	# callm :i.:+
	subl	$28, %esp
	# [:lvar, 1, :edx]
	movl	-12(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm i.+ END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	jmp	.L1202
.L1201:
	movl	nil, %eax
	.stabn  68,0,476,.LM727	
.LM727:
	movl	nil, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	addl	$32, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_each, .-__method_Array_each
.Lscope118:
	.stabs  "",36,0,0,.Lscope118-.LFBB118	
		
	########################################################################	
		
		
		
		
		
		
		
	####################### __method_Array_member__Q #######################	
		
	.stabs  "__method_Array_member__Q:F(0,0)",36,0,0,__method_Array_member__Q	
.globl __method_Array_member__Q
	.type	__method_Array_member__Q, @function
__method_Array_member__Q:
.LFBB119:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1209_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_member__Q", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1208, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1209_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1211_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_member__Q", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1208, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1211_else:
	# METHOD BODY:
	.stabn  68,0,481,.LM728	
.LM728:
	subl	$16, %esp
	addl	$4, %ebx
	subl	$20, %esp
	movl	$12, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	pushl	%edi
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %edx
	addl	$8, %edx
	popl	%eax
	movl	%eax, (%edx)
	.stabn  68,0,482,.LM729	
.LM729:
	# callm :self.:each
	subl	$24, %esp
	movl	%esi, (%esp)
	# Stack frame
	pushl	%ebp
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	movl	$__lambda_L79, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	subl	$32, %esp
	movl	-16(%ebp), %eax
	movl	%eax, (%esp)
	movl	-12(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%esi, 8(%esp)
	movl	$1, 12(%esp)
	movl	$4, %ebx
	call	__new_proc
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__each(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.each END
	.stabn  68,0,484,.LM730	
.LM730:
	movl	false, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	addl	$16, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_member__Q, .-__method_Array_member__Q
.Lscope119:
	.stabs  "",36,0,0,.Lscope119-.LFBB119	
		
	########################################################################	
		
		
		
		
		
		
		
	###################### __method_Array_each_index #######################	
		
	.stabs  "__method_Array_each_index:F(0,0)",36,0,0,__method_Array_each_index	
.globl __method_Array_each_index
	.type	__method_Array_each_index, @function
__method_Array_each_index:
.LFBB120:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1215_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_each_index", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1214, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1215_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1217_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_each_index", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1214, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1217_else:
	# METHOD BODY:
	.stabn  68,0,491,.LM731	
.LM731:
	subl	$20, %esp
	addl	$5, %ebx
	subl	$20, %esp
	movl	$8, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-16(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	.stabn  68,0,492,.LM732	
.LM732:
	movl	__I0, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
.L1220:
	# callm :i.:<
	subl	$28, %esp
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	# callm :self.:size
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__size(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.size END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm i.< END
	cmpl	%eax, nil
	je	.L1219
	cmpl	%eax, false
	je	.L1219
	.stabn  68,0,493,.LM733	
.LM733:
	# callm [:index, :__env__, 1].:call
	subl	$28, %esp
	movl	-16(%ebp), %eax
	movl	%eax, %edx
	addl	$4, %edx
	movl	(%edx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__call(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].call END
	.stabn  68,0,494,.LM734	
.LM734:
	# callm :i.:+
	subl	$28, %esp
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm i.+ END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	jmp	.L1220
.L1219:
	movl	nil, %eax
	addl	$20, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_each_index, .-__method_Array_each_index
.Lscope120:
	.stabs  "",36,0,0,.Lscope120-.LFBB120	
		
	########################################################################	
		
		
		
		
		
		
		
	####################### __method_Array_empty__Q ########################	
		
	.stabs  "__method_Array_empty__Q:F(0,0)",36,0,0,__method_Array_empty__Q	
.globl __method_Array_empty__Q
	.type	__method_Array_empty__Q, @function
__method_Array_empty__Q:
.LFBB121:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1222_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_empty__Q", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1221, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1222_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1224_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_empty__Q", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1221, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1224_else:
	# METHOD BODY:
	.stabn  68,0,500,.LM735	
.LM735:
	.stabn  68,0,501,.LM736	
.LM736:
	# callm [:callm, :self, :size].:==
	subl	$28, %esp
	# callm :self.:size
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__size(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.size END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I0, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :self, :size].== END
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_empty__Q, .-__method_Array_empty__Q
.Lscope121:
	.stabs  "",36,0,0,.Lscope121-.LFBB121	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Array_eql__Q #########################	
		
	.stabs  "__method_Array_eql__Q:F(0,0)",36,0,0,__method_Array_eql__Q	
.globl __method_Array_eql__Q
	.type	__method_Array_eql__Q, @function
__method_Array_eql__Q:
.LFBB122:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1227_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_eql__Q", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1226, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1227_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1229_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_eql__Q", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1226, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1229_else:
	# METHOD BODY:
	.stabn  68,0,507,.LM737	
.LM737:
	subl	$16, %esp
	addl	$4, %ebx
	.stabn  68,0,508,.LM738	
.LM738:
	# if: [:callm, [:callm, :self, :object_id], :==, [[:callm, :other_array, :object_id]]]
	# callm [:callm, :self, :object_id].:==
	subl	$28, %esp
	# callm :self.:object_id
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__object_id(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.object_id END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :other_array.:object_id
	subl	$24, %esp
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__object_id(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm other_array.object_id END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :self, :object_id].== END
	cmpl	%eax, nil
	je	.L1231_else
	cmpl	%eax, false
	je	.L1231_else
	# then: [:return, :true]
	movl	true, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L1231_else:
	# if: [:callm, [:callm, :other_array, :kind_of?, [:Array]], :!]
	# callm [:callm, :other_array, :kind_of?, [:Array]].:!
	subl	$24, %esp
	# callm :other_array.:kind_of?
	subl	$28, %esp
	# [:arg, 2, :ecx]
	movl	16(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	Array, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__kind_of__Q(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm other_array.kind_of? END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____X(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :other_array, :kind_of?, [:Array]].! END
	cmpl	%eax, nil
	je	.L1233_else
	cmpl	%eax, false
	je	.L1233_else
	# then: [:return, :false]
	movl	false, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L1233_else:
	.stabn  68,0,509,.LM739	
.LM739:
	# if: [:callm, [:callm, :self, :length], :!=, [[:callm, :other_array, :length]]]
	# callm [:callm, :self, :length].:!=
	subl	$28, %esp
	# callm :self.:length
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__length(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.length END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :other_array.:length
	subl	$24, %esp
	# [:arg, 2, :edx]
	movl	16(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__length(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm other_array.length END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____X__3d(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :self, :length].!= END
	cmpl	%eax, nil
	je	.L1235_else
	cmpl	%eax, false
	je	.L1235_else
	# then: [:return, :false]
	movl	false, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L1235_else:
	.stabn  68,0,510,.LM740	
.LM740:
	movl	__I0, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	.stabn  68,0,512,.LM741	
.LM741:
	# callm :self.:length
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__length(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.length END
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	.stabn  68,0,513,.LM742	
.LM742:
.L1238:
	# callm :i.:<
	subl	$28, %esp
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 2, :ecx]
	movl	-16(%ebp), %ecx
	movl	%ecx, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm i.< END
	cmpl	%eax, nil
	je	.L1237
	cmpl	%eax, false
	je	.L1237
	.stabn  68,0,514,.LM743	
.LM743:
	# if: [:callm, [:callm, :self, :[], [:i]], :!=, [[:callm, :other_array, :[], [:i]]]]
	# callm [:callm, :self, :[], [:i]].:!=
	subl	$28, %esp
	# callm :self.:[]
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 1, :edx]
	movl	-12(%ebp), %edx
	movl	%edx, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.[] END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :other_array.:[]
	subl	$28, %esp
	# [:arg, 2, :ecx]
	movl	16(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm other_array.[] END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____X__3d(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :self, :[], [:i]].!= END
	cmpl	%eax, nil
	je	.L1239_else
	cmpl	%eax, false
	je	.L1239_else
	# then: [:return, :false]
	movl	false, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L1239_else:
	.stabn  68,0,516,.LM744	
.LM744:
	# callm :i.:+
	subl	$28, %esp
	# [:lvar, 1, :edx]
	movl	-12(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm i.+ END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	jmp	.L1238
.L1237:
	movl	nil, %eax
	.stabn  68,0,518,.LM745	
.LM745:
	movl	true, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	addl	$16, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_eql__Q, .-__method_Array_eql__Q
.Lscope122:
	.stabs  "",36,0,0,.Lscope122-.LFBB122	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Array_fetch #########################	
		
	.stabs  "__method_Array_fetch:F(0,0)",36,0,0,__method_Array_fetch	
.globl __method_Array_fetch
	.type	__method_Array_fetch, @function
__method_Array_fetch:
.LFBB123:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1242_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_fetch", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1241, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1242_else:
	# if: [:gt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$4, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1244_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_fetch", 2, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1241, %eax
	movl	%eax, 4(%esp)
	movl	$2, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1244_else:
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for default at position 5
	# :nil
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$4, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1246_else
	# then: [:assign, :"#default", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L1247_endif
	# else: [:assign, :"#default", :default]
.L1246_else:
	movl	20(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L1247_endif:
	# METHOD BODY:
	.stabn  68,0,529,.LM746	
.LM746:
	.stabn  68,0,530,.LM747	
.LM747:
	subl	$20, %esp
	movl	$.L1248, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	puts
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	addl	$4, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_fetch, .-__method_Array_fetch
.Lscope123:
	.stabs  "",36,0,0,.Lscope123-.LFBB123	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Array_fill ##########################	
		
	.stabs  "__method_Array_fill:F(0,0)",36,0,0,__method_Array_fill	
.globl __method_Array_fill
	.type	__method_Array_fill, @function
__method_Array_fill:
.LFBB124:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1250_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_fill", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1249, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1250_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1252_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_fill", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1249, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1252_else:
	# METHOD BODY:
	.stabn  68,0,534,.LM748	
.LM748:
	.stabn  68,0,535,.LM749	
.LM749:
	subl	$20, %esp
	movl	$.L1254, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	puts
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_fill, .-__method_Array_fill
.Lscope124:
	.stabs  "",36,0,0,.Lscope124-.LFBB124	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Array_first #########################	
		
	.stabs  "__method_Array_first:F(0,0)",36,0,0,__method_Array_first	
.globl __method_Array_first
	.type	__method_Array_first, @function
__method_Array_first:
.LFBB125:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1256_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_first", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1255, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1256_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1258_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_first", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1255, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1258_else:
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for n at position 4
	# :nil
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1260_else
	# then: [:assign, :"#n", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L1261_endif
	# else: [:assign, :"#n", :n]
.L1260_else:
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	pushl	%edi
	popl	%eax
	movl	%eax, -8(%ebp)
.L1261_endif:
	# METHOD BODY:
	.stabn  68,0,541,.LM750	
.LM750:
	subl	$16, %esp
	addl	$4, %ebx
	subl	$20, %esp
	movl	$12, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-16(%ebp), %eax
	movl	%eax, %edx
	addl	$8, %edx
	popl	%eax
	movl	%eax, (%edx)
	.stabn  68,0,542,.LM751	
.LM751:
	# if: :n
	# [:lvar, 0, :ecx]
	movl	-8(%ebp), %ecx
	movl	%ecx, %eax
	cmpl	%eax, nil
	je	.L1262_else
	cmpl	%eax, false
	je	.L1262_else
	# then: [:do, [:if, [:callm, :self, :empty?], [:do, [:return, [:callm, :Array, :new]]]], [:assign, [:index, :__env__, 1], [:callm, :Array, :new]], [:if, [:callm, :n, :>=, [[:callm, :self, :size]]], [:do, [:return, [:callm, :Array, :new, [:self]]]]], [:callm, :n, :times, [], [:do, [:assign, [:index, :__env__, 0], [:stackframe]], [:assign, :__tmp_proc, [:defun, "__lambda_L80", [:self, :__closure__, :__env__, [:i, :default, :nil]], [:let, [], [:callm, [:index, :__env__, 1], :<<, [[:callm, :self, :[], [:i]]]]]]], [:sexp, [:call, :__new_proc, [:__tmp_proc, :__env__, :self, 1]]]]], [:return, [:index, :__env__, 1]]]
	.stabn  68,0,543,.LM752	
.LM752:
	# if: [:callm, :self, :empty?]
	# callm :self.:empty?
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__empty__Q(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.empty? END
	cmpl	%eax, nil
	je	.L1263_else
	cmpl	%eax, false
	je	.L1263_else
	# then: [:do, [:return, [:callm, :Array, :new]]]
	.stabn  68,0,544,.LM753	
.LM753:
	# callm :Array.:new
	subl	$24, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__new(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm Array.new END
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L1263_else:
	.stabn  68,0,545,.LM754	
.LM754:
	# callm :Array.:new
	subl	$24, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__new(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm Array.new END
	pushl	%eax
	movl	-16(%ebp), %eax
	movl	%eax, %edi
	addl	$4, %edi
	popl	%eax
	movl	%eax, (%edi)
	.stabn  68,0,547,.LM755	
.LM755:
	# if: [:callm, :n, :>=, [[:callm, :self, :size]]]
	# callm :n.:>=
	subl	$28, %esp
	# [:lvar, 0, :edx]
	movl	-8(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	# callm :self.:size
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__size(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.size END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____ge(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm n.>= END
	cmpl	%eax, nil
	je	.L1265_else
	cmpl	%eax, false
	je	.L1265_else
	# then: [:do, [:return, [:callm, :Array, :new, [:self]]]]
	.stabn  68,0,549,.LM756	
.LM756:
	# callm :Array.:new
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__new(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm Array.new END
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L1265_else:
	.stabn  68,0,550,.LM757	
.LM757:
	# callm :n.:times
	subl	$24, %esp
	# [:lvar, 0, :ecx]
	movl	-8(%ebp), %ecx
	movl	%ecx, (%esp)
	.stabn  68,0,552,.LM758	
.LM758:
	# Stack frame
	pushl	%ebp
	movl	-16(%ebp), %eax
	movl	%eax, %edi
	popl	%eax
	movl	%eax, (%edi)
	movl	$__lambda_L80, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	subl	$32, %esp
	movl	-20(%ebp), %eax
	movl	%eax, (%esp)
	movl	-16(%ebp), %eax
	movl	%eax, 4(%esp)
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, 8(%esp)
	movl	$1, 12(%esp)
	movl	$4, %ebx
	call	__new_proc
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__times(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm n.times END
	.stabn  68,0,554,.LM759	
.LM759:
	movl	-16(%ebp), %eax
	movl	%eax, %edx
	addl	$4, %edx
	movl	(%edx), %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L1262_else:
	.stabn  68,0,556,.LM760	
.LM760:
	# if: [:callm, :self, :empty?]
	# callm :self.:empty?
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__empty__Q(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.empty? END
	cmpl	%eax, nil
	je	.L1269_else
	cmpl	%eax, false
	je	.L1269_else
	# then: [:do, [:return, :nil]]
	.stabn  68,0,559,.LM761	
.LM761:
	movl	nil, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	jmp	.L1270_endif
	# else: [:do, [:return, [:callm, :self, :[], [[:sexp, :__I0]]]]]
.L1269_else:
	.stabn  68,0,561,.LM762	
.LM762:
	# callm :self.:[]
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	__I0, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.[] END
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
.L1270_endif:
	addl	$16, %esp
	addl	$4, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_first, .-__method_Array_first
.Lscope125:
	.stabs  "",36,0,0,.Lscope125-.LFBB125	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Array_flatten ########################	
		
	.stabs  "__method_Array_flatten:F(0,0)",36,0,0,__method_Array_flatten	
.globl __method_Array_flatten
	.type	__method_Array_flatten, @function
__method_Array_flatten:
.LFBB126:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1272_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_flatten", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1271, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1272_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1274_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_flatten", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1271, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1274_else:
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for level at position 4
	# :nil
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1276_else
	# then: [:assign, :"#level", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L1277_endif
	# else: [:assign, :"#level", :level]
.L1276_else:
	# [:arg, 2, :ecx]
	movl	16(%ebp), %ecx
	pushl	%ecx
	popl	%eax
	movl	%eax, -8(%ebp)
.L1277_endif:
	# METHOD BODY:
	.stabn  68,0,568,.LM763	
.LM763:
	subl	$16, %esp
	addl	$4, %ebx
	subl	$20, %esp
	movl	$16, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-16(%ebp), %eax
	movl	%eax, %edx
	addl	$12, %edx
	popl	%eax
	movl	%eax, (%edx)
	.stabn  68,0,570,.LM764	
.LM764:
	# callm :Array.:[]
	subl	$24, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm Array.[] END
	pushl	%eax
	movl	-16(%ebp), %eax
	movl	%eax, %edi
	addl	$8, %edi
	popl	%eax
	movl	%eax, (%edi)
	# [:lvar, 0, :ecx]
	movl	-8(%ebp), %ecx
	pushl	%ecx
	movl	-16(%ebp), %eax
	movl	%eax, %edx
	addl	$4, %edx
	popl	%eax
	movl	%eax, (%edx)
	.stabn  68,0,571,.LM765	
.LM765:
	# callm :self.:each
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	.stabn  68,0,572,.LM766	
.LM766:
	# Stack frame
	pushl	%ebp
	movl	-16(%ebp), %eax
	movl	%eax, %edi
	popl	%eax
	movl	%eax, (%edi)
	movl	$__lambda_L81, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	subl	$32, %esp
	movl	-20(%ebp), %eax
	movl	%eax, (%esp)
	movl	-16(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%esi, 8(%esp)
	movl	$1, 12(%esp)
	movl	$4, %ebx
	call	__new_proc
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__each(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.each END
	movl	-16(%ebp), %eax
	movl	%eax, %edx
	addl	$8, %edx
	movl	(%edx), %eax
	addl	$16, %esp
	addl	$4, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_flatten, .-__method_Array_flatten
.Lscope126:
	.stabs  "",36,0,0,.Lscope126-.LFBB126	
		
	########################################################################	
		
		
		
		
		
		
		
	###################### __method_Array_flatten__X #######################	
		
	.stabs  "__method_Array_flatten__X:F(0,0)",36,0,0,__method_Array_flatten__X	
.globl __method_Array_flatten__X
	.type	__method_Array_flatten__X, @function
__method_Array_flatten__X:
.LFBB127:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1280_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_flatten__X", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1279, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1280_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1282_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_flatten__X", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1279, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1282_else:
	# METHOD BODY:
	.stabn  68,0,593,.LM767	
.LM767:
	.stabn  68,0,594,.LM768	
.LM768:
	subl	$20, %esp
	movl	$.L1284, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	puts
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_flatten__X, .-__method_Array_flatten__X
.Lscope127:
	.stabs  "",36,0,0,.Lscope127-.LFBB127	
		
	########################################################################	
		
		
		
		
		
		
		
	####################### __method_Array_frozen__Q #######################	
		
	.stabs  "__method_Array_frozen__Q:F(0,0)",36,0,0,__method_Array_frozen__Q	
.globl __method_Array_frozen__Q
	.type	__method_Array_frozen__Q, @function
__method_Array_frozen__Q:
.LFBB128:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1286_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_frozen__Q", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1285, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1286_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1288_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_frozen__Q", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1285, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1288_else:
	# METHOD BODY:
	.stabn  68,0,599,.LM769	
.LM769:
	.stabn  68,0,600,.LM770	
.LM770:
	subl	$20, %esp
	movl	$.L1290, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	puts
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_frozen__Q, .-__method_Array_frozen__Q
.Lscope128:
	.stabs  "",36,0,0,.Lscope128-.LFBB128	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Array_hash ##########################	
		
	.stabs  "__method_Array_hash:F(0,0)",36,0,0,__method_Array_hash	
.globl __method_Array_hash
	.type	__method_Array_hash, @function
__method_Array_hash:
.LFBB129:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1292_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_hash", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1291, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1292_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1294_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_hash", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1291, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1294_else:
	# METHOD BODY:
	.stabn  68,0,608,.LM771	
.LM771:
	subl	$16, %esp
	addl	$4, %ebx
	subl	$20, %esp
	movl	$12, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	addl	$8, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	.stabn  68,0,609,.LM772	
.LM772:
	movl	__I5381, %eax
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %edi
	addl	$4, %edi
	popl	%eax
	movl	%eax, (%edi)
	# callm [:callm, [:index, :__env__, 1], :*, [[:sexp, :__I33]]].:+
	subl	$28, %esp
	# callm [:index, :__env__, 1].:*
	subl	$28, %esp
	movl	-12(%ebp), %eax
	movl	%eax, %edx
	addl	$4, %edx
	movl	(%edx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I33, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____mul(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].* END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :self.:length
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__length(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.length END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:index, :__env__, 1], :*, [[:sexp, :__I33]]].+ END
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	.stabn  68,0,610,.LM773	
.LM773:
	# callm :self.:each
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	.stabn  68,0,611,.LM774	
.LM774:
	# Stack frame
	pushl	%ebp
	movl	-12(%ebp), %eax
	movl	%eax, %edi
	popl	%eax
	movl	%eax, (%edi)
	movl	$__lambda_L82, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	subl	$32, %esp
	movl	-16(%ebp), %eax
	movl	%eax, (%esp)
	movl	-12(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%esi, 8(%esp)
	movl	$1, 12(%esp)
	movl	$4, %ebx
	call	__new_proc
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__each(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.each END
	movl	-12(%ebp), %eax
	movl	%eax, %edx
	addl	$4, %edx
	movl	(%edx), %eax
	addl	$16, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_hash, .-__method_Array_hash
.Lscope129:
	.stabs  "",36,0,0,.Lscope129-.LFBB129	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Array_index #########################	
		
	.stabs  "__method_Array_index:F(0,0)",36,0,0,__method_Array_index	
.globl __method_Array_index
	.type	__method_Array_index, @function
__method_Array_index:
.LFBB130:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1298_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_index", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1297, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1298_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1300_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_index", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1297, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1300_else:
	# METHOD BODY:
	.stabn  68,0,620,.LM775	
.LM775:
	subl	$16, %esp
	addl	$4, %ebx
	.stabn  68,0,621,.LM776	
.LM776:
	movl	__I0, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# callm :self.:length
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__length(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.length END
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	.stabn  68,0,622,.LM777	
.LM777:
.L1303:
	# callm :i.:<
	subl	$28, %esp
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 2, :edi]
	movl	-16(%ebp), %edi
	movl	%edi, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm i.< END
	cmpl	%eax, nil
	je	.L1302
	cmpl	%eax, false
	je	.L1302
	.stabn  68,0,623,.LM778	
.LM778:
	# if: [:callm, [:callm, :self, :[], [:i]], :==, [:obj]]
	# callm [:callm, :self, :[], [:i]].:==
	subl	$28, %esp
	# callm :self.:[]
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 1, :edx]
	movl	-12(%ebp), %edx
	movl	%edx, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.[] END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# [:arg, 2, :ecx]
	movl	16(%ebp), %ecx
	movl	%ecx, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :self, :[], [:i]].== END
	cmpl	%eax, nil
	je	.L1304_else
	cmpl	%eax, false
	je	.L1304_else
	# then: [:do, [:return, :i]]
	.stabn  68,0,625,.LM779	
.LM779:
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L1304_else:
	.stabn  68,0,626,.LM780	
.LM780:
	# callm :i.:+
	subl	$28, %esp
	# [:lvar, 1, :edx]
	movl	-12(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm i.+ END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	jmp	.L1303
.L1302:
	movl	nil, %eax
	.stabn  68,0,628,.LM781	
.LM781:
	movl	nil, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	addl	$16, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_index, .-__method_Array_index
.Lscope130:
	.stabs  "",36,0,0,.Lscope130-.LFBB130	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Array_replace ########################	
		
	.stabs  "__method_Array_replace:F(0,0)",36,0,0,__method_Array_replace	
.globl __method_Array_replace
	.type	__method_Array_replace, @function
__method_Array_replace:
.LFBB131:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1307_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_replace", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1306, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1307_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1309_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_replace", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1306, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1309_else:
	# METHOD BODY:
	.stabn  68,0,642,.LM782	
.LM782:
	subl	$16, %esp
	addl	$4, %ebx
	subl	$20, %esp
	movl	$8, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	.stabn  68,0,646,.LM783	
.LM783:
	pushl	$0
	popl	%edi
	movl	%edi, 4(%esi)
	# callm :other_array.:each
	subl	$24, %esp
	# [:arg, 2, :edx]
	movl	16(%ebp), %edx
	movl	%edx, (%esp)
	.stabn  68,0,649,.LM784	
.LM784:
	# Stack frame
	pushl	%ebp
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	movl	$__lambda_L83, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	subl	$32, %esp
	movl	-16(%ebp), %eax
	movl	%eax, (%esp)
	movl	-12(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%esi, 8(%esp)
	movl	$1, 12(%esp)
	movl	$4, %ebx
	call	__new_proc
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__each(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm other_array.each END
	addl	$16, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_replace, .-__method_Array_replace
.Lscope131:
	.stabs  "",36,0,0,.Lscope131-.LFBB131	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Array_insert #########################	
		
	.stabs  "__method_Array_insert:F(0,0)",36,0,0,__method_Array_insert	
.globl __method_Array_insert
	.type	__method_Array_insert, @function
__method_Array_insert:
.LFBB132:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$4, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1313_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_insert", 2, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1312, %eax
	movl	%eax, 4(%esp)
	movl	$2, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1313_else:
	# if: [:gt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$4, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1315_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_insert", 2, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1312, %eax
	movl	%eax, 4(%esp)
	movl	$2, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1315_else:
	# METHOD BODY:
	.stabn  68,0,655,.LM785	
.LM785:
	subl	$16, %esp
	addl	$4, %ebx
	.stabn  68,0,656,.LM786	
.LM786:
	# if: [:callm, :idx, :<, [[:sexp, :__I0]]]
	# callm :idx.:<
	subl	$28, %esp
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	__I0, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm idx.< END
	cmpl	%eax, nil
	je	.L1317_else
	cmpl	%eax, false
	je	.L1317_else
	# then: [:do, [:if, [:callm, [:callm, [:sexp, :__I0], :-, [:idx]], :>, [:length]], [:do, [:callm, :STDERR, :puts, [[:callm, [:callm, [:callm, [:callm, [:sexp, [:call, :__get_string, :".L11"]], :to_s], :concat, [[:callm, :idx, :to_s]]], :concat, [[:callm, [:sexp, [:call, :__get_string, :".L12"]], :to_s]]], :concat, [[:callm, [:callm, :length, :-], :to_s]]]]], [:call, :exit, [[:sexp, :__I1]]]]], [:assign, :idx, [:callm, [:callm, :length, :+, [[:sexp, :__I1]]], :+, [:idx]]]]
	.stabn  68,0,658,.LM787	
.LM787:
	# if: [:callm, [:callm, [:sexp, :__I0], :-, [:idx]], :>, [:length]]
	# callm [:callm, [:sexp, :__I0], :-, [:idx]].:>
	subl	$28, %esp
	# callm [:sexp, :__I0].:-
	subl	$28, %esp
	movl	__I0, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# [:arg, 2, :ecx]
	movl	16(%ebp), %ecx
	movl	%ecx, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____minus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:sexp, :__I0].- END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :self.:length
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__length(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.length END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____gt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:sexp, :__I0], :-, [:idx]].> END
	cmpl	%eax, nil
	je	.L1318_else
	cmpl	%eax, false
	je	.L1318_else
	# then: [:do, [:callm, :STDERR, :puts, [[:callm, [:callm, [:callm, [:callm, [:sexp, [:call, :__get_string, :".L11"]], :to_s], :concat, [[:callm, :idx, :to_s]]], :concat, [[:callm, [:sexp, [:call, :__get_string, :".L12"]], :to_s]]], :concat, [[:callm, [:callm, :length, :-], :to_s]]]]], [:call, :exit, [[:sexp, :__I1]]]]
	.stabn  68,0,659,.LM788	
.LM788:
	# callm :STDERR.:puts
	subl	$28, %esp
	movl	STDERR, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm [:callm, [:callm, [:callm, [:sexp, [:call, :__get_string, :".L11"]], :to_s], :concat, [[:callm, :idx, :to_s]]], :concat, [[:callm, [:sexp, [:call, :__get_string, :".L12"]], :to_s]]].:concat
	subl	$28, %esp
	# callm [:callm, [:callm, [:sexp, [:call, :__get_string, :".L11"]], :to_s], :concat, [[:callm, :idx, :to_s]]].:concat
	subl	$28, %esp
	# callm [:callm, [:sexp, [:call, :__get_string, :".L11"]], :to_s].:concat
	subl	$28, %esp
	# callm [:sexp, [:call, :__get_string, :".L11"]].:to_s
	subl	$24, %esp
	subl	$20, %esp
	movl	$.L11, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:sexp, [:call, :__get_string, :".L11"]].to_s END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :idx.:to_s
	subl	$24, %esp
	# [:arg, 2, :edx]
	movl	16(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm idx.to_s END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__concat(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:sexp, [:call, :__get_string, :".L11"]], :to_s].concat END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm [:sexp, [:call, :__get_string, :".L12"]].:to_s
	subl	$24, %esp
	subl	$20, %esp
	movl	$.L12, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:sexp, [:call, :__get_string, :".L12"]].to_s END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__concat(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:callm, [:sexp, [:call, :__get_string, :".L11"]], :to_s], :concat, [[:callm, :idx, :to_s]]].concat END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm [:callm, :length, :-].:to_s
	subl	$24, %esp
	# callm :length.:-
	subl	$24, %esp
	# callm :self.:length
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__length(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.length END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____minus(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm length.- END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :length, :-].to_s END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__concat(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:callm, [:callm, [:sexp, [:call, :__get_string, :".L11"]], :to_s], :concat, [[:callm, :idx, :to_s]]], :concat, [[:callm, [:sexp, [:call, :__get_string, :".L12"]], :to_s]]].concat END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__puts(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm STDERR.puts END
	# callm :self.:exit
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__exit(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.exit END
	# else: nil
.L1318_else:
	.stabn  68,0,661,.LM789	
.LM789:
	# callm [:callm, :length, :+, [[:sexp, :__I1]]].:+
	subl	$28, %esp
	# callm :length.:+
	subl	$28, %esp
	# callm :self.:length
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__length(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.length END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm length.+ END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	movl	%edi, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :length, :+, [[:sexp, :__I1]]].+ END
	pushl	%eax
	popl	%eax
	movl	%eax, 16(%ebp)
	# else: nil
.L1317_else:
	.stabn  68,0,663,.LM790	
.LM790:
	# callm :self.:length
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__length(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.length END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	.stabn  68,0,665,.LM791	
.LM791:
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	.stabn  68,0,668,.LM792	
.LM792:
.L1322:
	# callm :pos.:>
	subl	$28, %esp
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	# [:arg, 2, :edx]
	movl	16(%ebp), %edx
	movl	%edx, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____gt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm pos.> END
	cmpl	%eax, nil
	je	.L1321
	cmpl	%eax, false
	je	.L1321
	.stabn  68,0,669,.LM793	
.LM793:
	# callm :pos.:-
	subl	$28, %esp
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____minus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm pos.- END
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	.stabn  68,0,671,.LM794	
.LM794:
	# callm :self.:[]=
	subl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 1, :edx]
	movl	-12(%ebp), %edx
	movl	%edx, 8(%esp)
	# callm :self.:[]
	subl	$28, %esp
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 2, :ecx]
	movl	-16(%ebp), %ecx
	movl	%ecx, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.[] END
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	# Reload self?
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX__3d(%eax)
	# Evicting self
	# Static adj: 32
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.[]= END
	.stabn  68,0,672,.LM795	
.LM795:
	# callm :pos.:-
	subl	$28, %esp
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____minus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm pos.- END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	jmp	.L1322
.L1321:
	movl	nil, %eax
	.stabn  68,0,674,.LM796	
.LM796:
	# callm :self.:[]=
	subl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	# [:arg, 2, :edx]
	movl	16(%ebp), %edx
	movl	%edx, 8(%esp)
	# [:arg, 3, :ecx]
	movl	20(%ebp), %ecx
	movl	%ecx, 12(%esp)
	movl	$4, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____NDX__3d(%eax)
	# Evicting self
	# Static adj: 32
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.[]= END
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, %eax
	addl	$16, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_insert, .-__method_Array_insert
.Lscope132:
	.stabs  "",36,0,0,.Lscope132-.LFBB132	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Array_inspect ########################	
		
	.stabs  "__method_Array_inspect:F(0,0)",36,0,0,__method_Array_inspect	
.globl __method_Array_inspect
	.type	__method_Array_inspect, @function
__method_Array_inspect:
.LFBB133:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1324_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_inspect", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1323, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1324_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1326_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_inspect", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1323, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1326_else:
	# METHOD BODY:
	.stabn  68,0,683,.LM797	
.LM797:
	subl	$16, %esp
	addl	$4, %ebx
	subl	$20, %esp
	movl	$16, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	addl	$12, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	.stabn  68,0,684,.LM798	
.LM798:
	subl	$20, %esp
	movl	$.L13, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %edi
	addl	$8, %edi
	popl	%eax
	movl	%eax, (%edi)
	movl	true, %eax
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %edx
	addl	$4, %edx
	popl	%eax
	movl	%eax, (%edx)
	.stabn  68,0,685,.LM799	
.LM799:
	# callm :self.:each
	subl	$24, %esp
	movl	%esi, (%esp)
	.stabn  68,0,686,.LM800	
.LM800:
	# Stack frame
	pushl	%ebp
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	movl	$__lambda_L84, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	subl	$32, %esp
	movl	-16(%ebp), %eax
	movl	%eax, (%esp)
	movl	-12(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%esi, 8(%esp)
	movl	$1, 12(%esp)
	movl	$4, %ebx
	call	__new_proc
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__each(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.each END
	.stabn  68,0,693,.LM801	
.LM801:
	# callm [:index, :__env__, 2].:<<
	subl	$28, %esp
	movl	-12(%ebp), %eax
	movl	%eax, %edi
	addl	$8, %edi
	movl	(%edi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	subl	$20, %esp
	movl	$.L15, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt__lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 2].<< END
	movl	-12(%ebp), %eax
	movl	%eax, %edx
	addl	$8, %edx
	movl	(%edx), %eax
	addl	$16, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_inspect, .-__method_Array_inspect
.Lscope133:
	.stabs  "",36,0,0,.Lscope133-.LFBB133	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Array_join ##########################	
		
	.stabs  "__method_Array_join:F(0,0)",36,0,0,__method_Array_join	
.globl __method_Array_join
	.type	__method_Array_join, @function
__method_Array_join:
.LFBB134:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1330_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_join", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1329, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1330_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1332_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_join", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1329, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1332_else:
	# METHOD BODY:
	.stabn  68,0,701,.LM802	
.LM802:
	subl	$20, %esp
	addl	$5, %ebx
	subl	$20, %esp
	movl	$16, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	# [:arg, 2, :ecx]
	movl	16(%ebp), %ecx
	pushl	%ecx
	movl	-16(%ebp), %eax
	movl	%eax, %edi
	addl	$8, %edi
	popl	%eax
	movl	%eax, (%edi)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-16(%ebp), %eax
	movl	%eax, %edx
	addl	$12, %edx
	popl	%eax
	movl	%eax, (%edx)
	.stabn  68,0,702,.LM803	
.LM803:
	subl	$20, %esp
	movl	$.L0, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	movl	-16(%ebp), %eax
	movl	%eax, %edi
	addl	$4, %edi
	popl	%eax
	movl	%eax, (%edi)
	# callm :self.:size
	subl	$24, %esp
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__size(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.size END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	.stabn  68,0,703,.LM804	
.LM804:
	# callm [:index, :__env__, 2].:to_s
	subl	$24, %esp
	movl	-16(%ebp), %eax
	movl	%eax, %edx
	addl	$8, %edx
	movl	(%edx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 2].to_s END
	pushl	%eax
	movl	-16(%ebp), %eax
	movl	%eax, %ecx
	addl	$8, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	.stabn  68,0,704,.LM805	
.LM805:
	# callm :self.:each
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	.stabn  68,0,705,.LM806	
.LM806:
	# Stack frame
	pushl	%ebp
	movl	-16(%ebp), %eax
	movl	%eax, %edi
	popl	%eax
	movl	%eax, (%edi)
	movl	$__lambda_L85, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	subl	$32, %esp
	movl	-20(%ebp), %eax
	movl	%eax, (%esp)
	movl	-16(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%esi, 8(%esp)
	movl	$1, 12(%esp)
	movl	$4, %ebx
	call	__new_proc
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__each(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.each END
	movl	-16(%ebp), %eax
	movl	%eax, %edx
	addl	$4, %edx
	movl	(%edx), %eax
	addl	$20, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_join, .-__method_Array_join
.Lscope134:
	.stabs  "",36,0,0,.Lscope134-.LFBB134	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Array_last ##########################	
		
	.stabs  "__method_Array_last:F(0,0)",36,0,0,__method_Array_last	
.globl __method_Array_last
	.type	__method_Array_last, @function
__method_Array_last:
.LFBB135:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1336_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_last", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1335, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1336_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1338_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_last", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1335, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1338_else:
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for n at position 4
	# :nil
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1340_else
	# then: [:assign, :"#n", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L1341_endif
	# else: [:assign, :"#n", :n]
.L1340_else:
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	pushl	%edi
	popl	%eax
	movl	%eax, -8(%ebp)
.L1341_endif:
	# METHOD BODY:
	.stabn  68,0,717,.LM807	
.LM807:
	subl	$16, %esp
	addl	$4, %ebx
	subl	$20, %esp
	movl	$16, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-16(%ebp), %eax
	movl	%eax, %edx
	addl	$12, %edx
	popl	%eax
	movl	%eax, (%edx)
	.stabn  68,0,718,.LM808	
.LM808:
	# if: :n
	# [:lvar, 0, :ecx]
	movl	-8(%ebp), %ecx
	movl	%ecx, %eax
	cmpl	%eax, nil
	je	.L1342_else
	cmpl	%eax, false
	je	.L1342_else
	# then: [:do, [:if, [:callm, :n, :>=, [[:callm, :self, :size]]], [:do, [:return, [:callm, :Array, :new, [:self]]]]], [:assign, [:index, :__env__, 1], [:callm, :Array, :new]], [:assign, [:index, :__env__, 2], [:callm, [:callm, :self, :size], :-, [:n]]], [:callm, :n, :times, [], [:do, [:assign, [:index, :__env__, 0], [:stackframe]], [:assign, :__tmp_proc, [:defun, "__lambda_L86", [:self, :__closure__, :__env__, [:i, :default, :nil]], [:let, [], [:callm, [:index, :__env__, 1], :<<, [[:callm, :self, :[], [[:callm, :i, :+, [[:index, :__env__, 2]]]]]]]]]], [:sexp, [:call, :__new_proc, [:__tmp_proc, :__env__, :self, 1]]]]], [:return, [:index, :__env__, 1]]]
	.stabn  68,0,719,.LM809	
.LM809:
	# if: [:callm, :n, :>=, [[:callm, :self, :size]]]
	# callm :n.:>=
	subl	$28, %esp
	# [:lvar, 0, :edi]
	movl	-8(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	# callm :self.:size
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__size(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.size END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____ge(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm n.>= END
	cmpl	%eax, nil
	je	.L1343_else
	cmpl	%eax, false
	je	.L1343_else
	# then: [:do, [:return, [:callm, :Array, :new, [:self]]]]
	.stabn  68,0,720,.LM810	
.LM810:
	# callm :Array.:new
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__new(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm Array.new END
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L1343_else:
	.stabn  68,0,721,.LM811	
.LM811:
	# callm :Array.:new
	subl	$24, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__new(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm Array.new END
	pushl	%eax
	movl	-16(%ebp), %eax
	movl	%eax, %edx
	addl	$4, %edx
	popl	%eax
	movl	%eax, (%edx)
	.stabn  68,0,723,.LM812	
.LM812:
	# callm [:callm, :self, :size].:-
	subl	$28, %esp
	# callm :self.:size
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__size(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.size END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 0, :ecx]
	movl	-8(%ebp), %ecx
	movl	%ecx, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____minus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :self, :size].- END
	pushl	%eax
	movl	-16(%ebp), %eax
	movl	%eax, %edi
	addl	$8, %edi
	popl	%eax
	movl	%eax, (%edi)
	.stabn  68,0,724,.LM813	
.LM813:
	# callm :n.:times
	subl	$24, %esp
	# [:lvar, 0, :edx]
	movl	-8(%ebp), %edx
	movl	%edx, (%esp)
	.stabn  68,0,725,.LM814	
.LM814:
	# Stack frame
	pushl	%ebp
	movl	-16(%ebp), %eax
	movl	%eax, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	movl	$__lambda_L86, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	subl	$32, %esp
	movl	-20(%ebp), %eax
	movl	%eax, (%esp)
	movl	-16(%ebp), %eax
	movl	%eax, 4(%esp)
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, 8(%esp)
	movl	$1, 12(%esp)
	movl	$4, %ebx
	call	__new_proc
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__times(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm n.times END
	.stabn  68,0,727,.LM815	
.LM815:
	movl	-16(%ebp), %eax
	movl	%eax, %edi
	addl	$4, %edi
	movl	(%edi), %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L1342_else:
	.stabn  68,0,729,.LM816	
.LM816:
	# if: [:callm, :self, :empty?]
	# callm :self.:empty?
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__empty__Q(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.empty? END
	cmpl	%eax, nil
	je	.L1347_else
	cmpl	%eax, false
	je	.L1347_else
	# then: [:do, [:return, :nil]]
	.stabn  68,0,732,.LM817	
.LM817:
	movl	nil, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	jmp	.L1348_endif
	# else: [:do, [:return, [:callm, :self, :[], [[:sexp, :__Ineg1]]]]]
.L1347_else:
	.stabn  68,0,734,.LM818	
.LM818:
	# callm :self.:[]
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	__Ineg1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.[] END
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
.L1348_endif:
	addl	$16, %esp
	addl	$4, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_last, .-__method_Array_last
.Lscope135:
	.stabs  "",36,0,0,.Lscope135-.LFBB135	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Array_length #########################	
		
	.stabs  "__method_Array_length:F(0,0)",36,0,0,__method_Array_length	
.globl __method_Array_length
	.type	__method_Array_length, @function
__method_Array_length:
.LFBB136:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1350_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_length", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1349, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1350_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1352_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_length", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1349, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1352_else:
	# METHOD BODY:
	.stabn  68,0,740,.LM819	
.LM819:
	.stabn  68,0,741,.LM820	
.LM820:
	subl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__int
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_length, .-__method_Array_length
.Lscope136:
	.stabs  "",36,0,0,.Lscope136-.LFBB136	
		
	########################################################################	
		
		
		
		
		
		
		
	##################### __method_Array_collect__X__1 #####################	
		
	.stabs  "__method_Array_collect__X__1:F(0,0)",36,0,0,__method_Array_collect__X__1	
.globl __method_Array_collect__X__1
	.type	__method_Array_collect__X__1, @function
__method_Array_collect__X__1:
.LFBB137:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1355_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_collect__X__1", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1354, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1355_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1357_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_collect__X__1", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1354, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1357_else:
	# METHOD BODY:
	.stabn  68,0,748,.LM821	
.LM821:
	.stabn  68,0,749,.LM822	
.LM822:
	subl	$20, %esp
	movl	$.L1359, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	puts
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_collect__X__1, .-__method_Array_collect__X__1
.Lscope137:
	.stabs  "",36,0,0,.Lscope137-.LFBB137	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Array_map__X #########################	
		
	.stabs  "__method_Array_map__X:F(0,0)",36,0,0,__method_Array_map__X	
.globl __method_Array_map__X
	.type	__method_Array_map__X, @function
__method_Array_map__X:
.LFBB138:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1361_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_map__X", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1360, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1361_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1363_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_map__X", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1360, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1363_else:
	# METHOD BODY:
	.stabn  68,0,756,.LM823	
.LM823:
	.stabn  68,0,757,.LM824	
.LM824:
	subl	$20, %esp
	movl	$.L1365, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	puts
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_map__X, .-__method_Array_map__X
.Lscope138:
	.stabs  "",36,0,0,.Lscope138-.LFBB138	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Array_nitems #########################	
		
	.stabs  "__method_Array_nitems:F(0,0)",36,0,0,__method_Array_nitems	
.globl __method_Array_nitems
	.type	__method_Array_nitems, @function
__method_Array_nitems:
.LFBB139:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1367_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_nitems", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1366, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1367_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1369_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_nitems", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1366, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1369_else:
	# METHOD BODY:
	.stabn  68,0,762,.LM825	
.LM825:
	subl	$16, %esp
	addl	$4, %ebx
	subl	$20, %esp
	movl	$8, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %edi
	addl	$4, %edi
	popl	%eax
	movl	%eax, (%edi)
	.stabn  68,0,763,.LM826	
.LM826:
	# callm [:callm, :self, :select, [], [:do, [:assign, [:index, :__env__, 0], [:stackframe]], [:assign, :__tmp_proc, [:defun, "__lambda_L87", [:self, :__closure__, :__env__, [:item, :default, :nil]], [:let, [], [:callm, :item, :!=, [:nil]]]]], [:sexp, [:call, :__new_proc, [:__tmp_proc, :__env__, :self, 1]]]]].:size
	subl	$24, %esp
	# callm :self.:select
	subl	$28, %esp
	movl	%esi, (%esp)
	# Stack frame
	pushl	%ebp
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	movl	$__lambda_L87, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	subl	$32, %esp
	movl	-16(%ebp), %eax
	movl	%eax, (%esp)
	movl	-12(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%esi, 8(%esp)
	movl	$1, 12(%esp)
	movl	$4, %ebx
	call	__new_proc
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 4(%esp)
	subl	$20, %esp
	movl	$.L1372, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*28(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.select END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__size(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :self, :select, [], [:do, [:assign, [:index, :__env__, 0], [:stackframe]], [:assign, :__tmp_proc, [:defun, "__lambda_L87", [:self, :__closure__, :__env__, [:item, :default, :nil]], [:let, [], [:callm, :item, :!=, [:nil]]]]], [:sexp, [:call, :__new_proc, [:__tmp_proc, :__env__, :self, 1]]]]].size END
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	addl	$16, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_nitems, .-__method_Array_nitems
.Lscope139:
	.stabs  "",36,0,0,.Lscope139-.LFBB139	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Array_pack ##########################	
		
	.stabs  "__method_Array_pack:F(0,0)",36,0,0,__method_Array_pack	
.globl __method_Array_pack
	.type	__method_Array_pack, @function
__method_Array_pack:
.LFBB140:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1374_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_pack", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1373, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1374_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1376_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_pack", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1373, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1376_else:
	# METHOD BODY:
	.stabn  68,0,767,.LM827	
.LM827:
	.stabn  68,0,768,.LM828	
.LM828:
	subl	$20, %esp
	movl	$.L1378, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	puts
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_pack, .-__method_Array_pack
.Lscope140:
	.stabs  "",36,0,0,.Lscope140-.LFBB140	
		
	########################################################################	
		
		
		
		
		
		
		
	########################## __method_Array_pop ##########################	
		
	.stabs  "__method_Array_pop:F(0,0)",36,0,0,__method_Array_pop	
.globl __method_Array_pop
	.type	__method_Array_pop, @function
__method_Array_pop:
.LFBB141:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1380_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_pop", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1379, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1380_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1382_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_pop", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1379, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1382_else:
	# METHOD BODY:
	.stabn  68,0,774,.LM829	
.LM829:
	subl	$12, %esp
	addl	$3, %ebx
	.stabn  68,0,775,.LM830	
.LM830:
	# if: [:callm, :self, :empty?]
	# callm :self.:empty?
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__empty__Q(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.empty? END
	cmpl	%eax, nil
	je	.L1384_else
	cmpl	%eax, false
	je	.L1384_else
	# then: [:do, [:return, :nil]]
	.stabn  68,0,776,.LM831	
.LM831:
	movl	nil, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	jmp	.L1385_endif
	# else: [:do, [:assign, :last_element, [:callm, :self, :last]], [:sexp, [:assign, :@len, [:sub, :@len, 1]]], [:return, :last_element]]
.L1384_else:
	.stabn  68,0,778,.LM832	
.LM832:
	# callm :self.:last
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__last(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.last END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	movl	%eax, %ecx
	movl	$1, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	pushl	%eax
	popl	%eax
	pushl	%eax
	popl	%edi
	movl	%edi, 4(%esi)
	.stabn  68,0,779,.LM833	
.LM833:
	# [:lvar, 1, :edx]
	movl	-12(%ebp), %edx
	movl	%edx, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
.L1385_endif:
	addl	$12, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_pop, .-__method_Array_pop
.Lscope141:
	.stabs  "",36,0,0,.Lscope141-.LFBB141	
		
	########################################################################	
		
		
		
		
		
		
		
	##################### __method_Array_pretty_print ######################	
		
	.stabs  "__method_Array_pretty_print:F(0,0)",36,0,0,__method_Array_pretty_print	
.globl __method_Array_pretty_print
	.type	__method_Array_pretty_print, @function
__method_Array_pretty_print:
.LFBB142:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1387_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_pretty_print", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1386, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1387_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1389_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_pretty_print", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1386, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1389_else:
	# METHOD BODY:
	.stabn  68,0,785,.LM834	
.LM834:
	.stabn  68,0,786,.LM835	
.LM835:
	subl	$20, %esp
	movl	$.L1391, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	puts
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_pretty_print, .-__method_Array_pretty_print
.Lscope142:
	.stabs  "",36,0,0,.Lscope142-.LFBB142	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Array_push ##########################	
		
	.stabs  "__method_Array_push:F(0,0)",36,0,0,__method_Array_push	
.globl __method_Array_push
	.type	__method_Array_push, @function
__method_Array_push:
.LFBB143:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1393_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_push", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1392, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1393_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1395_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_push", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1392, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1395_else:
	# METHOD BODY:
	.stabn  68,0,793,.LM836	
.LM836:
	.stabn  68,0,794,.LM837	
.LM837:
	# callm :self.:<<
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____lt__lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.<< END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_push, .-__method_Array_push
.Lscope143:
	.stabs  "",36,0,0,.Lscope143-.LFBB143	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Array_quote #########################	
		
	.stabs  "__method_Array_quote:F(0,0)",36,0,0,__method_Array_quote	
.globl __method_Array_quote
	.type	__method_Array_quote, @function
__method_Array_quote:
.LFBB144:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1398_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_quote", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1397, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1398_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1400_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_quote", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1397, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1400_else:
	# METHOD BODY:
	.stabn  68,0,798,.LM838	
.LM838:
	.stabn  68,0,799,.LM839	
.LM839:
	subl	$20, %esp
	movl	$.L1402, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	puts
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_quote, .-__method_Array_quote
.Lscope144:
	.stabs  "",36,0,0,.Lscope144-.LFBB144	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Array_rassoc #########################	
		
	.stabs  "__method_Array_rassoc:F(0,0)",36,0,0,__method_Array_rassoc	
.globl __method_Array_rassoc
	.type	__method_Array_rassoc, @function
__method_Array_rassoc:
.LFBB145:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1404_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_rassoc", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1403, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1404_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1406_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_rassoc", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1403, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1406_else:
	# METHOD BODY:
	.stabn  68,0,806,.LM840	
.LM840:
	subl	$16, %esp
	addl	$4, %ebx
	subl	$20, %esp
	movl	$12, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# [:arg, 2, :ecx]
	movl	16(%ebp), %ecx
	pushl	%ecx
	movl	-12(%ebp), %eax
	movl	%eax, %edi
	addl	$4, %edi
	popl	%eax
	movl	%eax, (%edi)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %edx
	addl	$8, %edx
	popl	%eax
	movl	%eax, (%edx)
	.stabn  68,0,807,.LM841	
.LM841:
	# callm :self.:each
	subl	$24, %esp
	movl	%esi, (%esp)
	# Stack frame
	pushl	%ebp
	movl	-12(%ebp), %eax
	movl	%eax, %edi
	popl	%eax
	movl	%eax, (%edi)
	movl	$__lambda_L88, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	subl	$32, %esp
	movl	-16(%ebp), %eax
	movl	%eax, (%esp)
	movl	-12(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%esi, 8(%esp)
	movl	$1, 12(%esp)
	movl	$4, %ebx
	call	__new_proc
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__each(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.each END
	.stabn  68,0,813,.LM842	
.LM842:
	movl	nil, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	addl	$16, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_rassoc, .-__method_Array_rassoc
.Lscope145:
	.stabs  "",36,0,0,.Lscope145-.LFBB145	
		
	########################################################################	
		
		
		
		
		
		
		
	####################### __method_Array_reject__X #######################	
		
	.stabs  "__method_Array_reject__X:F(0,0)",36,0,0,__method_Array_reject__X	
.globl __method_Array_reject__X
	.type	__method_Array_reject__X, @function
__method_Array_reject__X:
.LFBB146:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1410_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_reject__X", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1409, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1410_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1412_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_reject__X", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1409, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1412_else:
	# METHOD BODY:
	.stabn  68,0,822,.LM843	
.LM843:
	.stabn  68,0,823,.LM844	
.LM844:
	subl	$20, %esp
	movl	$.L1414, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	puts
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_reject__X, .-__method_Array_reject__X
.Lscope146:
	.stabs  "",36,0,0,.Lscope146-.LFBB146	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Array_reverse ########################	
		
	.stabs  "__method_Array_reverse:F(0,0)",36,0,0,__method_Array_reverse	
.globl __method_Array_reverse
	.type	__method_Array_reverse, @function
__method_Array_reverse:
.LFBB147:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1416_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_reverse", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1415, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1416_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1418_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_reverse", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1415, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1418_else:
	# METHOD BODY:
	.stabn  68,0,828,.LM845	
.LM845:
	.stabn  68,0,829,.LM846	
.LM846:
	# callm [:callm, :self, :dup].:reverse!
	subl	$24, %esp
	# callm :self.:dup
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__dup(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.dup END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__reverse__X(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :self, :dup].reverse! END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_reverse, .-__method_Array_reverse
.Lscope147:
	.stabs  "",36,0,0,.Lscope147-.LFBB147	
		
	########################################################################	
		
		
		
		
		
		
		
	###################### __method_Array_reverse__X #######################	
		
	.stabs  "__method_Array_reverse__X:F(0,0)",36,0,0,__method_Array_reverse__X	
.globl __method_Array_reverse__X
	.type	__method_Array_reverse__X, @function
__method_Array_reverse__X:
.LFBB148:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1421_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_reverse__X", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1420, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1421_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1423_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_reverse__X", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1420, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1423_else:
	# METHOD BODY:
	.stabn  68,0,834,.LM847	
.LM847:
	subl	$20, %esp
	addl	$5, %ebx
	.stabn  68,0,835,.LM848	
.LM848:
	movl	__I0, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# callm :length.:-
	subl	$28, %esp
	# callm :self.:length
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__length(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.length END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____minus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm length.- END
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	.stabn  68,0,836,.LM849	
.LM849:
.L1426:
	# callm :i.:<
	subl	$28, %esp
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 2, :ecx]
	movl	-16(%ebp), %ecx
	movl	%ecx, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm i.< END
	cmpl	%eax, nil
	je	.L1425
	cmpl	%eax, false
	je	.L1425
	.stabn  68,0,838,.LM850	
.LM850:
	# callm :self.:[]
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 1, :edx]
	movl	-12(%ebp), %edx
	movl	%edx, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.[] END
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	.stabn  68,0,839,.LM851	
.LM851:
	# callm :self.:[]=
	subl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, 8(%esp)
	# callm :self.:[]
	subl	$28, %esp
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 2, :edi]
	movl	-16(%ebp), %edi
	movl	%edi, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.[] END
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	# Reload self?
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX__3d(%eax)
	# Evicting self
	# Static adj: 32
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.[]= END
	.stabn  68,0,840,.LM852	
.LM852:
	# callm :self.:[]=
	subl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 2, :edx]
	movl	-16(%ebp), %edx
	movl	%edx, 8(%esp)
	# [:lvar, 3, :ecx]
	movl	-20(%ebp), %ecx
	movl	%ecx, 12(%esp)
	movl	$4, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____NDX__3d(%eax)
	# Evicting self
	# Static adj: 32
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.[]= END
	.stabn  68,0,841,.LM853	
.LM853:
	# callm :i.:+
	subl	$28, %esp
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm i.+ END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	.stabn  68,0,842,.LM854	
.LM854:
	# callm :j.:-
	subl	$28, %esp
	# [:lvar, 2, :edx]
	movl	-16(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____minus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm j.- END
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	jmp	.L1426
.L1425:
	movl	nil, %eax
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, %eax
	addl	$20, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_reverse__X, .-__method_Array_reverse__X
.Lscope148:
	.stabs  "",36,0,0,.Lscope148-.LFBB148	
		
	########################################################################	
		
		
		
		
		
		
		
	##################### __method_Array_reverse_each ######################	
		
	.stabs  "__method_Array_reverse_each:F(0,0)",36,0,0,__method_Array_reverse_each	
.globl __method_Array_reverse_each
	.type	__method_Array_reverse_each, @function
__method_Array_reverse_each:
.LFBB149:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1428_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_reverse_each", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1427, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1428_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1430_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_reverse_each", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1427, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1430_else:
	# METHOD BODY:
	.stabn  68,0,850,.LM855	
.LM855:
	.stabn  68,0,851,.LM856	
.LM856:
	# callm [:callm, :self, :reverse].:each
	subl	$24, %esp
	# callm :self.:reverse
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__reverse(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.reverse END
	movl	%eax, (%esp)
	movl	12(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__each(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :self, :reverse].each END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_reverse_each, .-__method_Array_reverse_each
.Lscope149:
	.stabs  "",36,0,0,.Lscope149-.LFBB149	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Array_rindex #########################	
		
	.stabs  "__method_Array_rindex:F(0,0)",36,0,0,__method_Array_rindex	
.globl __method_Array_rindex
	.type	__method_Array_rindex, @function
__method_Array_rindex:
.LFBB150:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1433_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_rindex", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1432, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1433_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1435_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_rindex", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1432, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1435_else:
	# METHOD BODY:
	.stabn  68,0,856,.LM857	
.LM857:
	subl	$16, %esp
	addl	$4, %ebx
	subl	$20, %esp
	movl	$16, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# [:arg, 2, :ecx]
	movl	16(%ebp), %ecx
	pushl	%ecx
	movl	-12(%ebp), %eax
	movl	%eax, %edi
	addl	$4, %edi
	popl	%eax
	movl	%eax, (%edi)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %edx
	addl	$12, %edx
	popl	%eax
	movl	%eax, (%edx)
	.stabn  68,0,858,.LM858	
.LM858:
	movl	nil, %eax
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %edi
	addl	$8, %edi
	popl	%eax
	movl	%eax, (%edi)
	# callm :self.:each_with_index
	subl	$24, %esp
	movl	%esi, (%esp)
	.stabn  68,0,859,.LM859	
.LM859:
	# Stack frame
	pushl	%ebp
	movl	-12(%ebp), %eax
	movl	%eax, %edx
	popl	%eax
	movl	%eax, (%edx)
	movl	$__lambda_L89, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	subl	$32, %esp
	movl	-16(%ebp), %eax
	movl	%eax, (%esp)
	movl	-12(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%esi, 8(%esp)
	movl	$2, 12(%esp)
	movl	$4, %ebx
	call	__new_proc
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__each_with_index(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.each_with_index END
	.stabn  68,0,863,.LM860	
.LM860:
	movl	-12(%ebp), %eax
	movl	%eax, %edi
	addl	$8, %edi
	movl	(%edi), %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	addl	$16, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_rindex, .-__method_Array_rindex
.Lscope150:
	.stabs  "",36,0,0,.Lscope150-.LFBB150	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Array_shift #########################	
		
	.stabs  "__method_Array_shift:F(0,0)",36,0,0,__method_Array_shift	
.globl __method_Array_shift
	.type	__method_Array_shift, @function
__method_Array_shift:
.LFBB151:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1439_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_shift", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1438, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1439_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1441_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_shift", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1438, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1441_else:
	# METHOD BODY:
	.stabn  68,0,870,.LM861	
.LM861:
	subl	$12, %esp
	addl	$3, %ebx
	.stabn  68,0,871,.LM862	
.LM862:
	# if: [:callm, :self, :empty?]
	# callm :self.:empty?
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__empty__Q(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.empty? END
	cmpl	%eax, nil
	je	.L1443_else
	cmpl	%eax, false
	je	.L1443_else
	# then: [:do, [:return, :nil]]
	.stabn  68,0,872,.LM863	
.LM863:
	movl	nil, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	jmp	.L1444_endif
	# else: [:do, [:assign, :first_element, [:callm, :self, :first]], [:callm, :self, :delete_at, [[:sexp, :__I0]]], [:return, :first_element]]
.L1443_else:
	.stabn  68,0,874,.LM864	
.LM864:
	# callm :self.:first
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__first(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.first END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# callm :self.:delete_at
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	__I0, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__delete_at(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.delete_at END
	.stabn  68,0,875,.LM865	
.LM865:
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
.L1444_endif:
	addl	$12, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_shift, .-__method_Array_shift
.Lscope151:
	.stabs  "",36,0,0,.Lscope151-.LFBB151	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Array_size ##########################	
		
	.stabs  "__method_Array_size:F(0,0)",36,0,0,__method_Array_size	
.globl __method_Array_size
	.type	__method_Array_size, @function
__method_Array_size:
.LFBB152:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1446_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_size", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1445, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1446_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1448_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_size", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1445, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1448_else:
	# METHOD BODY:
	.stabn  68,0,882,.LM866	
.LM866:
	.stabn  68,0,883,.LM867	
.LM867:
	# callm :self.:length
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__length(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.length END
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_size, .-__method_Array_size
.Lscope152:
	.stabs  "",36,0,0,.Lscope152-.LFBB152	
		
	########################################################################	
		
		
		
		
		
		
		
	####################### __method_Array_partition #######################	
		
	.stabs  "__method_Array_partition:F(0,0)",36,0,0,__method_Array_partition	
.globl __method_Array_partition
	.type	__method_Array_partition, @function
__method_Array_partition:
.LFBB153:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1451_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_partition", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1450, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1451_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1453_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_partition", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1450, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1453_else:
	# METHOD BODY:
	.stabn  68,0,887,.LM868	
.LM868:
	subl	$16, %esp
	addl	$4, %ebx
	subl	$20, %esp
	movl	$20, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# [:arg, 1, :edi]
	movl	12(%ebp), %edi
	pushl	%edi
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %edx
	addl	$16, %edx
	popl	%eax
	movl	%eax, (%edx)
	.stabn  68,0,888,.LM869	
.LM869:
	# callm :Array.:[]
	subl	$24, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm Array.[] END
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	addl	$8, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	# callm :Array.:[]
	subl	$24, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm Array.[] END
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %edx
	addl	$12, %edx
	popl	%eax
	movl	%eax, (%edx)
	.stabn  68,0,889,.LM870	
.LM870:
	# callm :self.:each
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	.stabn  68,0,891,.LM871	
.LM871:
	# Stack frame
	pushl	%ebp
	movl	-12(%ebp), %eax
	movl	%eax, %edi
	popl	%eax
	movl	%eax, (%edi)
	movl	$__lambda_L90, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	subl	$32, %esp
	movl	-16(%ebp), %eax
	movl	%eax, (%esp)
	movl	-12(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%esi, 8(%esp)
	movl	$1, 12(%esp)
	movl	$4, %ebx
	call	__new_proc
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__each(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.each END
	.stabn  68,0,897,.LM872	
.LM872:
	# callm :Array.:[]
	subl	$32, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	addl	$8, %ecx
	movl	(%ecx), %eax
	movl	%eax, 8(%esp)
	movl	-12(%ebp), %eax
	movl	%eax, %edx
	addl	$12, %edx
	movl	(%edx), %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 32
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm Array.[] END
	addl	$16, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_partition, .-__method_Array_partition
.Lscope153:
	.stabs  "",36,0,0,.Lscope153-.LFBB153	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Array_sort_by ########################	
		
	.stabs  "__method_Array_sort_by:F(0,0)",36,0,0,__method_Array_sort_by	
.globl __method_Array_sort_by
	.type	__method_Array_sort_by, @function
__method_Array_sort_by:
.LFBB154:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1457_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_sort_by", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1456, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1457_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1459_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_sort_by", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1456, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1459_else:
	# METHOD BODY:
	.stabn  68,0,912,.LM873	
.LM873:
	subl	$32, %esp
	addl	$8, %ebx
	subl	$20, %esp
	movl	$16, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -28(%ebp)
	# [:arg, 1, :edi]
	movl	12(%ebp), %edi
	pushl	%edi
	movl	-28(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-28(%ebp), %eax
	movl	%eax, %edx
	addl	$12, %edx
	popl	%eax
	movl	%eax, (%edx)
	.stabn  68,0,913,.LM874	
.LM874:
	# if: [:callm, :length, :<=, [[:sexp, :__I1]]]
	# callm :length.:<=
	subl	$28, %esp
	# callm :self.:length
	subl	$24, %esp
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__length(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.length END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____le(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm length.<= END
	cmpl	%eax, nil
	je	.L1461_else
	cmpl	%eax, false
	je	.L1461_else
	# then: [:return, :self]
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L1461_else:
	# callm :self.:[]
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	__I0, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.[] END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	.stabn  68,0,914,.LM875	
.LM875:
	# callm [:index, :__env__, 1].:call
	subl	$28, %esp
	movl	-28(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	movl	(%ecx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 1, :edx]
	movl	-12(%ebp), %edx
	movl	%edx, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__call(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].call END
	pushl	%eax
	movl	-28(%ebp), %eax
	movl	%eax, %edi
	addl	$8, %edi
	popl	%eax
	movl	%eax, (%edi)
	.stabn  68,0,915,.LM876	
.LM876:
	# callm [:callm, :self, :[], [[:callm, :Range, :new, [[:sexp, :__I1], [:sexp, :__Ineg1]]]]].:partition
	subl	$24, %esp
	# callm :self.:[]
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	# callm :Range.:new
	subl	$32, %esp
	movl	Range, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	__Ineg1, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__new(%eax)
	# Evicting self
	# Static adj: 32
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm Range.new END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.[] END
	movl	%eax, (%esp)
	.stabn  68,0,916,.LM877	
.LM877:
	# Stack frame
	pushl	%ebp
	movl	-28(%ebp), %eax
	movl	%eax, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	movl	$__lambda_L91, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -32(%ebp)
	subl	$32, %esp
	movl	-32(%ebp), %eax
	movl	%eax, (%esp)
	movl	-28(%ebp), %eax
	movl	%eax, 4(%esp)
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, 8(%esp)
	movl	$1, 12(%esp)
	movl	$4, %ebx
	call	__new_proc
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__partition(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :self, :[], [[:callm, :Range, :new, [[:sexp, :__I1], [:sexp, :__Ineg1]]]]].partition END
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	# callm [:callm, :part, :[], [[:sexp, :__I0]]].:sort_by
	subl	$24, %esp
	# callm :part.:[]
	subl	$28, %esp
	# [:lvar, 2, :edx]
	movl	-16(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	__I0, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm part.[] END
	movl	%eax, (%esp)
	movl	-28(%ebp), %eax
	movl	%eax, %edi
	addl	$4, %edi
	movl	(%edi), %eax
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__sort_by(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :part, :[], [[:sexp, :__I0]]].sort_by END
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	.stabn  68,0,918,.LM878	
.LM878:
	# callm [:callm, :part, :[], [[:sexp, :__I1]]].:sort_by
	subl	$24, %esp
	# callm :part.:[]
	subl	$28, %esp
	# [:lvar, 2, :ecx]
	movl	-16(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm part.[] END
	movl	%eax, (%esp)
	movl	-28(%ebp), %eax
	movl	%eax, %edx
	addl	$4, %edx
	movl	(%edx), %eax
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__sort_by(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :part, :[], [[:sexp, :__I1]]].sort_by END
	pushl	%eax
	popl	%eax
	movl	%eax, -24(%ebp)
	.stabn  68,0,919,.LM879	
.LM879:
	# callm [:callm, :left, :+, [[:array, :pivot_el]]].:+
	subl	$28, %esp
	# callm :left.:+
	subl	$28, %esp
	# [:lvar, 3, :edi]
	movl	-20(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	# callm :Array.:[]
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm Array.[] END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm left.+ END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 4, :edx]
	movl	-24(%ebp), %edx
	movl	%edx, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :left, :+, [[:array, :pivot_el]]].+ END
	addl	$32, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_sort_by, .-__method_Array_sort_by
.Lscope154:
	.stabs  "",36,0,0,.Lscope154-.LFBB154	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Array_sort ##########################	
		
	.stabs  "__method_Array_sort:F(0,0)",36,0,0,__method_Array_sort	
.globl __method_Array_sort
	.type	__method_Array_sort, @function
__method_Array_sort:
.LFBB155:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1465_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_sort", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1464, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1465_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1467_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_sort", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1464, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1467_else:
	# METHOD BODY:
	.stabn  68,0,931,.LM880	
.LM880:
	subl	$28, %esp
	addl	$7, %ebx
	subl	$20, %esp
	movl	$12, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -24(%ebp)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-24(%ebp), %eax
	movl	%eax, %edi
	addl	$8, %edi
	popl	%eax
	movl	%eax, (%edi)
	.stabn  68,0,932,.LM881	
.LM881:
	# if: [:callm, :length, :<=, [[:sexp, :__I1]]]
	# callm :length.:<=
	subl	$28, %esp
	# callm :self.:length
	subl	$24, %esp
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__length(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.length END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____le(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm length.<= END
	cmpl	%eax, nil
	je	.L1469_else
	cmpl	%eax, false
	je	.L1469_else
	# then: [:return, :self]
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L1469_else:
	# callm :self.:[]
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	__I0, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.[] END
	pushl	%eax
	movl	-24(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	.stabn  68,0,934,.LM882	
.LM882:
	# callm [:callm, :self, :[], [[:callm, :Range, :new, [[:sexp, :__I1], [:sexp, :__Ineg1]]]]].:partition
	subl	$24, %esp
	# callm :self.:[]
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	# callm :Range.:new
	subl	$32, %esp
	movl	Range, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	__Ineg1, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__new(%eax)
	# Evicting self
	# Static adj: 32
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm Range.new END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.[] END
	movl	%eax, (%esp)
	.stabn  68,0,936,.LM883	
.LM883:
	# Stack frame
	pushl	%ebp
	movl	-24(%ebp), %eax
	movl	%eax, %edx
	popl	%eax
	movl	%eax, (%edx)
	movl	$__lambda_L92, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -28(%ebp)
	subl	$32, %esp
	movl	-28(%ebp), %eax
	movl	%eax, (%esp)
	movl	-24(%ebp), %eax
	movl	%eax, 4(%esp)
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, 8(%esp)
	movl	$1, 12(%esp)
	movl	$4, %ebx
	call	__new_proc
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__partition(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :self, :[], [[:callm, :Range, :new, [[:sexp, :__I1], [:sexp, :__Ineg1]]]]].partition END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	.stabn  68,0,940,.LM884	
.LM884:
	# callm [:callm, :part, :[], [[:sexp, :__I0]]].:sort
	subl	$24, %esp
	# callm :part.:[]
	subl	$28, %esp
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	__I0, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm part.[] END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__sort(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :part, :[], [[:sexp, :__I0]]].sort END
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	.stabn  68,0,942,.LM885	
.LM885:
	# callm [:callm, :part, :[], [[:sexp, :__I1]]].:sort
	subl	$24, %esp
	# callm :part.:[]
	subl	$28, %esp
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm part.[] END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__sort(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :part, :[], [[:sexp, :__I1]]].sort END
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	.stabn  68,0,943,.LM886	
.LM886:
	# callm [:callm, :left, :+, [[:array, [:index, :__env__, 1]]]].:+
	subl	$28, %esp
	# callm :left.:+
	subl	$28, %esp
	# [:lvar, 2, :edx]
	movl	-16(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	# callm :Array.:[]
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	-24(%ebp), %eax
	movl	%eax, %edi
	addl	$4, %edi
	movl	(%edi), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm Array.[] END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm left.+ END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 3, :ecx]
	movl	-20(%ebp), %ecx
	movl	%ecx, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :left, :+, [[:array, [:index, :__env__, 1]]]].+ END
	addl	$28, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_sort, .-__method_Array_sort
.Lscope155:
	.stabs  "",36,0,0,.Lscope155-.LFBB155	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Array_sort__X ########################	
		
	.stabs  "__method_Array_sort__X:F(0,0)",36,0,0,__method_Array_sort__X	
.globl __method_Array_sort__X
	.type	__method_Array_sort__X, @function
__method_Array_sort__X:
.LFBB156:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1473_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_sort__X", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1472, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1473_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1475_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_sort__X", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1472, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1475_else:
	# METHOD BODY:
	.stabn  68,0,953,.LM887	
.LM887:
	.stabn  68,0,954,.LM888	
.LM888:
	subl	$20, %esp
	movl	$.L1477, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	puts
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, %eax
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_sort__X, .-__method_Array_sort__X
.Lscope156:
	.stabs  "",36,0,0,.Lscope156-.LFBB156	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Array_to_a__1 ########################	
		
	.stabs  "__method_Array_to_a__1:F(0,0)",36,0,0,__method_Array_to_a__1	
.globl __method_Array_to_a__1
	.type	__method_Array_to_a__1, @function
__method_Array_to_a__1:
.LFBB157:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1479_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_to_a__1", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1478, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1479_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1481_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_to_a__1", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1478, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1481_else:
	# METHOD BODY:
	.stabn  68,0,961,.LM889	
.LM889:
	.stabn  68,0,962,.LM890	
.LM890:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_to_a__1, .-__method_Array_to_a__1
.Lscope157:
	.stabs  "",36,0,0,.Lscope157-.LFBB157	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Array_to_ary #########################	
		
	.stabs  "__method_Array_to_ary:F(0,0)",36,0,0,__method_Array_to_ary	
.globl __method_Array_to_ary
	.type	__method_Array_to_ary, @function
__method_Array_to_ary:
.LFBB158:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1484_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_to_ary", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1483, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1484_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1486_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_to_ary", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1483, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1486_else:
	# METHOD BODY:
	.stabn  68,0,967,.LM891	
.LM891:
	.stabn  68,0,968,.LM892	
.LM892:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_to_ary, .-__method_Array_to_ary
.Lscope158:
	.stabs  "",36,0,0,.Lscope158-.LFBB158	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Array_to_yaml ########################	
		
	.stabs  "__method_Array_to_yaml:F(0,0)",36,0,0,__method_Array_to_yaml	
.globl __method_Array_to_yaml
	.type	__method_Array_to_yaml, @function
__method_Array_to_yaml:
.LFBB159:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1489_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_to_yaml", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1488, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1489_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1491_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_to_yaml", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1488, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1491_else:
	# METHOD BODY:
	.stabn  68,0,971,.LM893	
.LM893:
	.stabn  68,0,972,.LM894	
.LM894:
	subl	$20, %esp
	movl	$.L1493, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	puts
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_to_yaml, .-__method_Array_to_yaml
.Lscope159:
	.stabs  "",36,0,0,.Lscope159-.LFBB159	
		
	########################################################################	
		
		
		
		
		
		
		
	####################### __method_Array_transpose #######################	
		
	.stabs  "__method_Array_transpose:F(0,0)",36,0,0,__method_Array_transpose	
.globl __method_Array_transpose
	.type	__method_Array_transpose, @function
__method_Array_transpose:
.LFBB160:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1495_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_transpose", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1494, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1495_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1497_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_transpose", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1494, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1497_else:
	# METHOD BODY:
	.stabn  68,0,977,.LM895	
.LM895:
	.stabn  68,0,978,.LM896	
.LM896:
	subl	$20, %esp
	movl	$.L1499, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	puts
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_transpose, .-__method_Array_transpose
.Lscope160:
	.stabs  "",36,0,0,.Lscope160-.LFBB160	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Array_uniq ##########################	
		
	.stabs  "__method_Array_uniq:F(0,0)",36,0,0,__method_Array_uniq	
.globl __method_Array_uniq
	.type	__method_Array_uniq, @function
__method_Array_uniq:
.LFBB161:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1501_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_uniq", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1500, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1501_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1503_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_uniq", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1500, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1503_else:
	# METHOD BODY:
	.stabn  68,0,982,.LM897	
.LM897:
	subl	$16, %esp
	addl	$4, %ebx
	subl	$20, %esp
	movl	$12, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	addl	$8, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	.stabn  68,0,983,.LM898	
.LM898:
	# callm :Array.:new
	subl	$24, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__new(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm Array.new END
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %edi
	addl	$4, %edi
	popl	%eax
	movl	%eax, (%edi)
	# callm :self.:each
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	.stabn  68,0,984,.LM899	
.LM899:
	# Stack frame
	pushl	%ebp
	movl	-12(%ebp), %eax
	movl	%eax, %edx
	popl	%eax
	movl	%eax, (%edx)
	movl	$__lambda_L93, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	subl	$32, %esp
	movl	-16(%ebp), %eax
	movl	%eax, (%esp)
	movl	-12(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%esi, 8(%esp)
	movl	$1, 12(%esp)
	movl	$4, %ebx
	call	__new_proc
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__each(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.each END
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	movl	(%ecx), %eax
	addl	$16, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_uniq, .-__method_Array_uniq
.Lscope161:
	.stabs  "",36,0,0,.Lscope161-.LFBB161	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Array_uniq__X ########################	
		
	.stabs  "__method_Array_uniq__X:F(0,0)",36,0,0,__method_Array_uniq__X	
.globl __method_Array_uniq__X
	.type	__method_Array_uniq__X, @function
__method_Array_uniq__X:
.LFBB162:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1507_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_uniq__X", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1506, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1507_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1509_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_uniq__X", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1506, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1509_else:
	# METHOD BODY:
	.stabn  68,0,995,.LM900	
.LM900:
	subl	$16, %esp
	addl	$4, %ebx
	.stabn  68,0,996,.LM901	
.LM901:
	# callm :self.:uniq
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__uniq(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.uniq END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# callm [:callm, :uniq_arr, :size].:!=
	subl	$28, %esp
	# callm :uniq_arr.:size
	subl	$24, %esp
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__size(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm uniq_arr.size END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :self.:size
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__size(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.size END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____X__3d(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :uniq_arr, :size].!= END
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	.stabn  68,0,997,.LM902	
.LM902:
	# callm :self.:uniq
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__uniq(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.uniq END
	pushl	%eax
	popl	%eax
	movl	%eax, 8(%ebp)
	.stabn  68,0,998,.LM903	
.LM903:
	# if: :changes_made
	# [:lvar, 2, :edi]
	movl	-16(%ebp), %edi
	movl	%edi, %eax
	cmpl	%eax, nil
	je	.L1511_else
	cmpl	%eax, false
	je	.L1511_else
	# then: [:do, [:return, :self]]
	.stabn  68,0,1001,.LM904	
.LM904:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	jmp	.L1512_endif
	# else: [:do, [:return, :nil]]
.L1511_else:
	.stabn  68,0,1003,.LM905	
.LM905:
	movl	nil, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
.L1512_endif:
	addl	$16, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_uniq__X, .-__method_Array_uniq__X
.Lscope162:
	.stabs  "",36,0,0,.Lscope162-.LFBB162	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Array_unshift ########################	
		
	.stabs  "__method_Array_unshift:F(0,0)",36,0,0,__method_Array_unshift	
.globl __method_Array_unshift
	.type	__method_Array_unshift, @function
__method_Array_unshift:
.LFBB163:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1514_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_unshift", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1513, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1514_else:
	# METHOD BODY:
	.stabn  68,0,1009,.LM906	
.LM906:
	subl	$12, %esp
	addl	$3, %ebx
	subl	$24, %esp
	leal	16(%ebp), %eax
	movl	%eax, (%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$0, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	call	__splat_to_Array
	addl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	.stabn  68,0,1010,.LM907	
.LM907:
	subl	$20, %esp
	movl	$.L1516, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	puts
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	addl	$12, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_unshift, .-__method_Array_unshift
.Lscope163:
	.stabs  "",36,0,0,.Lscope163-.LFBB163	
		
	########################################################################	
		
		
		
		
		
		
		
	####################### __method_Array_values_at #######################	
		
	.stabs  "__method_Array_values_at:F(0,0)",36,0,0,__method_Array_values_at	
.globl __method_Array_values_at
	.type	__method_Array_values_at, @function
__method_Array_values_at:
.LFBB164:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1518_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_values_at", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1517, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1518_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1520_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_values_at", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1517, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1520_else:
	# METHOD BODY:
	.stabn  68,0,1017,.LM908	
.LM908:
	.stabn  68,0,1018,.LM909	
.LM909:
	subl	$20, %esp
	movl	$.L1522, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	puts
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_values_at, .-__method_Array_values_at
.Lscope164:
	.stabs  "",36,0,0,.Lscope164-.LFBB164	
		
	########################################################################	
		
		
		
		
		
		
		
	#################### __method_Array_yaml_initialize ####################	
		
	.stabs  "__method_Array_yaml_initialize:F(0,0)",36,0,0,__method_Array_yaml_initialize	
.globl __method_Array_yaml_initialize
	.type	__method_Array_yaml_initialize, @function
__method_Array_yaml_initialize:
.LFBB165:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1524_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_yaml_initialize", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1523, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1524_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1526_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Array_yaml_initialize", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1523, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1526_else:
	# METHOD BODY:
	.stabn  68,0,1022,.LM910	
.LM910:
	.stabn  68,0,1023,.LM911	
.LM911:
	subl	$20, %esp
	movl	$.L1528, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	puts
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_yaml_initialize, .-__method_Array_yaml_initialize
.Lscope165:
	.stabs  "",36,0,0,.Lscope165-.LFBB165	
		
	########################################################################	
		
		
		
		
		
		
		
	########################## __method_Array_zip ##########################	
		
	.stabs  "__method_Array_zip:F(0,0)",36,0,0,__method_Array_zip	
.globl __method_Array_zip
	.type	__method_Array_zip, @function
__method_Array_zip:
.LFBB166:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1530_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Array_zip", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1529, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1530_else:
	# METHOD BODY:
	.stabn  68,0,1032,.LM912	
.LM912:
	subl	$20, %esp
	addl	$5, %ebx
	subl	$24, %esp
	leal	16(%ebp), %eax
	movl	%eax, (%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$0, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	call	__splat_to_Array
	addl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -24(%ebp)
	subl	$20, %esp
	movl	$16, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-16(%ebp), %eax
	movl	%eax, %ecx
	addl	$12, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	.stabn  68,0,1041,.LM913	
.LM913:
	# callm :args.:collect
	subl	$24, %esp
	# [:lvar, 4, :edx]
	movl	-24(%ebp), %edx
	movl	%edx, (%esp)
	# Stack frame
	pushl	%ebp
	movl	-16(%ebp), %eax
	movl	%eax, %edi
	popl	%eax
	movl	%eax, (%edi)
	movl	$__lambda_L94, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	subl	$32, %esp
	movl	-20(%ebp), %eax
	movl	%eax, (%esp)
	movl	-16(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%esi, 8(%esp)
	movl	$1, 12(%esp)
	movl	$4, %ebx
	call	__new_proc
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__collect(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm args.collect END
	pushl	%eax
	movl	-16(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	# callm :self.:collect
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	.stabn  68,0,1043,.LM914	
.LM914:
	# Stack frame
	pushl	%ebp
	movl	-16(%ebp), %eax
	movl	%eax, %edi
	popl	%eax
	movl	%eax, (%edi)
	movl	$__lambda_L95, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	subl	$32, %esp
	movl	-20(%ebp), %eax
	movl	%eax, (%esp)
	movl	-16(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%esi, 8(%esp)
	movl	$1, 12(%esp)
	movl	$4, %ebx
	call	__new_proc
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__collect(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.collect END
	addl	$20, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Array_zip, .-__method_Array_zip
.Lscope166:
	.stabs  "",36,0,0,.Lscope166-.LFBB166	
		
	########################################################################	
		
		
		
		
		
		
		
	###################### __method_String_initialize ######################	
		
	.stabs  "__method_String_initialize:F(0,0)",36,0,0,__method_String_initialize	
.globl __method_String_initialize
	.type	__method_String_initialize, @function
__method_String_initialize:
.LFBB167:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	# [:lvar, -1, :edx]
	movl	-4(%ebp), %edx
	# Locked register edx
	movl	$2, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	# Unlocked register edx
	testl	%eax, %eax
	je	.L1535_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_String_initialize", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1534, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	# [:lvar, -1, :ecx]
	movl	-4(%ebp), %ecx
	# Locked register ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	# Unlocked register ecx
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1535_else:
	# METHOD BODY:
	.stabn  68,0,18,.LM915	
.LM915:
	subl	$20, %esp
	addl	$5, %ebx
	subl	$24, %esp
	leal	16(%ebp), %eax
	movl	%eax, (%esp)
	# [:lvar, -1, :ecx]
	movl	-4(%ebp), %ecx
	# Locked register ecx
	movl	$0, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	# Unlocked register ecx
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	call	__splat_to_Array
	addl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -24(%ebp)
	.stabn  68,0,27,.LM916	
.LM916:
	# if: [:lt, :numargs, 3]
	# [:lvar, -1, :edi]
	movl	-4(%ebp), %edi
	# Locked register edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	# Unlocked register edi
	testl	%eax, %eax
	je	.L1537_else
	# then: [:assign, :@buffer, ""]
	movl	$.L0, %eax
	pushl	%eax
	popl	%eax
	pushl	%eax
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%edx
	movl	%edx, 4(%esi)
	jmp	.L1538_endif
	# else: [:do, [:assign, :first, [:callm, :str, :[], [:__I0]]], [:assign, :len, [:callm, :first, :length]], [:callm, :self, :__copy_raw, [[:callm, :first, :__get_raw], :len]]]
.L1537_else:
	# callm :str.:[]
	subl	$28, %esp
	# [:lvar, 4, :ecx]
	movl	-24(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	__I0, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm str.[] END
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	# callm :first.:length
	subl	$24, %esp
	# [:lvar, 2, :edi]
	movl	-16(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__length(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm first.length END
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	# callm :self.:__copy_raw
	subl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	# callm :first.:__get_raw
	subl	$24, %esp
	# [:lvar, 2, :edx]
	movl	-16(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____get_raw(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm first.__get_raw END
	movl	%eax, 8(%esp)
	# [:lvar, 3, :ecx]
	movl	-20(%ebp), %ecx
	movl	%ecx, 12(%esp)
	movl	$4, %ebx
	# Reload self?
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	(%esi), %eax
	call	*__voff____copy_raw(%eax)
	# Evicting self
	# Static adj: 32
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.__copy_raw END
.L1538_endif:
	addl	$20, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_String_initialize, .-__method_String_initialize
.Lscope167:
	.stabs  "",36,0,0,.Lscope167-.LFBB167	
		
	########################################################################	
		
		
		
		
		
		
		
	####################### __method_String_inspect ########################	
		
	.stabs  "__method_String_inspect:F(0,0)",36,0,0,__method_String_inspect	
.globl __method_String_inspect
	.type	__method_String_inspect, @function
__method_String_inspect:
.LFBB168:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1540_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_String_inspect", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1539, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1540_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1542_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_String_inspect", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1539, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1542_else:
	# METHOD BODY:
	.stabn  68,0,37,.LM917	
.LM917:
	subl	$16, %esp
	addl	$4, %ebx
	subl	$20, %esp
	movl	$16, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	addl	$12, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	.stabn  68,0,38,.LM918	
.LM918:
	# callm [:sexp, :__I34].:chr
	subl	$24, %esp
	movl	__I34, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__chr(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:sexp, :__I34].chr END
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %edi
	addl	$4, %edi
	popl	%eax
	movl	%eax, (%edi)
	# callm [:sexp, :__I92].:chr
	subl	$24, %esp
	movl	__I92, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__chr(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:sexp, :__I92].chr END
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %edx
	addl	$8, %edx
	popl	%eax
	movl	%eax, (%edx)
	.stabn  68,0,39,.LM919	
.LM919:
	# callm :self.:each_byte
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	.stabn  68,0,40,.LM920	
.LM920:
	# Stack frame
	pushl	%ebp
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	movl	$__lambda_L97, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	subl	$32, %esp
	movl	-16(%ebp), %eax
	movl	%eax, (%esp)
	movl	-12(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%esi, 8(%esp)
	movl	$1, 12(%esp)
	movl	$4, %ebx
	call	__new_proc
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__each_byte(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.each_byte END
	.stabn  68,0,52,.LM921	
.LM921:
	# callm [:index, :__env__, 1].:<<
	subl	$28, %esp
	movl	-12(%ebp), %eax
	movl	%eax, %edi
	addl	$4, %edi
	movl	(%edi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm [:sexp, :__I34].:chr
	subl	$24, %esp
	movl	__I34, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__chr(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:sexp, :__I34].chr END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt__lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].<< END
	movl	-12(%ebp), %eax
	movl	%eax, %edx
	addl	$4, %edx
	movl	(%edx), %eax
	addl	$16, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_String_inspect, .-__method_String_inspect
.Lscope168:
	.stabs  "",36,0,0,.Lscope168-.LFBB168	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_String_hash #########################	
		
	.stabs  "__method_String_hash:F(0,0)",36,0,0,__method_String_hash	
.globl __method_String_hash
	.type	__method_String_hash, @function
__method_String_hash:
.LFBB169:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1546_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_String_hash", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1545, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1546_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1548_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_String_hash", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1545, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1548_else:
	# METHOD BODY:
	.stabn  68,0,58,.LM922	
.LM922:
	subl	$16, %esp
	addl	$4, %ebx
	subl	$20, %esp
	movl	$12, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	addl	$8, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	.stabn  68,0,59,.LM923	
.LM923:
	movl	__I5381, %eax
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %edi
	addl	$4, %edi
	popl	%eax
	movl	%eax, (%edi)
	# callm :self.:each_byte
	subl	$24, %esp
	movl	%esi, (%esp)
	.stabn  68,0,60,.LM924	
.LM924:
	# Stack frame
	pushl	%ebp
	movl	-12(%ebp), %eax
	movl	%eax, %edx
	popl	%eax
	movl	%eax, (%edx)
	movl	$__lambda_L98, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	subl	$32, %esp
	movl	-16(%ebp), %eax
	movl	%eax, (%esp)
	movl	-12(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%esi, 8(%esp)
	movl	$1, 12(%esp)
	movl	$4, %ebx
	call	__new_proc
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__each_byte(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.each_byte END
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	movl	(%ecx), %eax
	addl	$16, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_String_hash, .-__method_String_hash
.Lscope169:
	.stabs  "",36,0,0,.Lscope169-.LFBB169	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_String___X ##########################	
		
	.stabs  "__method_String___X:F(0,0)",36,0,0,__method_String___X	
.globl __method_String___X
	.type	__method_String___X, @function
__method_String___X:
.LFBB170:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1552_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_String___X", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1551, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1552_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1554_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_String___X", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1551, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1554_else:
	# METHOD BODY:
	.stabn  68,0,66,.LM925	
.LM925:
	movl	false, %eax
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_String___X, .-__method_String___X
.Lscope170:
	.stabs  "",36,0,0,.Lscope170-.LFBB170	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_String_nil__Q ########################	
		
	.stabs  "__method_String_nil__Q:F(0,0)",36,0,0,__method_String_nil__Q	
.globl __method_String_nil__Q
	.type	__method_String_nil__Q, @function
__method_String_nil__Q:
.LFBB171:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1557_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_String_nil__Q", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1556, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1557_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1559_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_String_nil__Q", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1556, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1559_else:
	# METHOD BODY:
	.stabn  68,0,70,.LM926	
.LM926:
	movl	false, %eax
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_String_nil__Q, .-__method_String_nil__Q
.Lscope171:
	.stabs  "",36,0,0,.Lscope171-.LFBB171	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_String___NDX #########################	
		
	.stabs  "__method_String___NDX:F(0,0)",36,0,0,__method_String___NDX	
.globl __method_String___NDX
	.type	__method_String___NDX, @function
__method_String___NDX:
.LFBB172:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1562_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_String___NDX", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1561, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1562_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1564_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_String___NDX", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1561, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1564_else:
	# METHOD BODY:
	.stabn  68,0,75,.LM927	
.LM927:
	subl	$32, %esp
	addl	$8, %ebx
	.stabn  68,0,76,.LM928	
.LM928:
	# callm :self.:length
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__length(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.length END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# if: [:callm, :index, :is_a?, [:Range]]
	# callm :index.:is_a?
	subl	$28, %esp
	# [:arg, 2, :ecx]
	movl	16(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	Range, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__is_a__Q(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm index.is_a? END
	cmpl	%eax, nil
	je	.L1566_else
	cmpl	%eax, false
	je	.L1566_else
	# then: [:do, [:assign, :b, [:callm, :index, :first]], [:assign, :e, [:callm, :index, :last]], [:if, [:callm, :b, :<, [[:sexp, :__I0]]], [:do, [:assign, :b, [:callm, :l, :+, [:b]]], [:if, [:callm, :b, :<, [[:sexp, :__I0]]], [:do, [:return, :nil]]]]], [:if, [:callm, :e, :<, [[:sexp, :__I0]]], [:do, [:assign, :e, [:callm, [:callm, :l, :+, [:e]], :+, [[:sexp, :__I1]]]], [:if, [:callm, :e, :<, [[:sexp, :__I0]]], [:do, [:assign, :e, [:sexp, :__I0]]]]]], [:if, [:callm, :e, :>, [:l]], [:do, [:assign, :e, :l]]], [:assign, :e, [:callm, [:callm, :e, :-, [:b]], :+, [[:sexp, :__I1]]]], [:assign, :a, [:callm, :String, :new]], [:sexp, [:assign, :src, [:add, :@buffer, [:callm, :b, :__get_raw]]]], [:callm, :a, :__copy_raw, [:src, :e]], [:return, :a]]
	.stabn  68,0,79,.LM929	
.LM929:
	# callm :index.:first
	subl	$24, %esp
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__first(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm index.first END
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	# callm :index.:last
	subl	$24, %esp
	# [:arg, 2, :edx]
	movl	16(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__last(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm index.last END
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	.stabn  68,0,80,.LM930	
.LM930:
	# if: [:callm, :b, :<, [[:sexp, :__I0]]]
	# callm :b.:<
	subl	$28, %esp
	# [:lvar, 2, :ecx]
	movl	-16(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	__I0, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm b.< END
	cmpl	%eax, nil
	je	.L1567_else
	cmpl	%eax, false
	je	.L1567_else
	# then: [:do, [:assign, :b, [:callm, :l, :+, [:b]]], [:if, [:callm, :b, :<, [[:sexp, :__I0]]], [:do, [:return, :nil]]]]
	.stabn  68,0,83,.LM931	
.LM931:
	# callm :l.:+
	subl	$28, %esp
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 2, :edx]
	movl	-16(%ebp), %edx
	movl	%edx, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm l.+ END
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	# if: [:callm, :b, :<, [[:sexp, :__I0]]]
	# callm :b.:<
	subl	$28, %esp
	# [:lvar, 2, :ecx]
	movl	-16(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	__I0, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm b.< END
	cmpl	%eax, nil
	je	.L1568_else
	cmpl	%eax, false
	je	.L1568_else
	# then: [:do, [:return, :nil]]
	.stabn  68,0,85,.LM932	
.LM932:
	movl	nil, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L1568_else:
	# else: nil
.L1567_else:
	.stabn  68,0,87,.LM933	
.LM933:
	# if: [:callm, :e, :<, [[:sexp, :__I0]]]
	# callm :e.:<
	subl	$28, %esp
	# [:lvar, 3, :edx]
	movl	-20(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	__I0, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm e.< END
	cmpl	%eax, nil
	je	.L1571_else
	cmpl	%eax, false
	je	.L1571_else
	# then: [:do, [:assign, :e, [:callm, [:callm, :l, :+, [:e]], :+, [[:sexp, :__I1]]]], [:if, [:callm, :e, :<, [[:sexp, :__I0]]], [:do, [:assign, :e, [:sexp, :__I0]]]]]
	.stabn  68,0,90,.LM934	
.LM934:
	# callm [:callm, :l, :+, [:e]].:+
	subl	$28, %esp
	# callm :l.:+
	subl	$28, %esp
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 3, :ecx]
	movl	-20(%ebp), %ecx
	movl	%ecx, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm l.+ END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :l, :+, [:e]].+ END
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	# if: [:callm, :e, :<, [[:sexp, :__I0]]]
	# callm :e.:<
	subl	$28, %esp
	# [:lvar, 3, :edx]
	movl	-20(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	__I0, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm e.< END
	cmpl	%eax, nil
	je	.L1572_else
	cmpl	%eax, false
	je	.L1572_else
	# then: [:do, [:assign, :e, [:sexp, :__I0]]]
	.stabn  68,0,92,.LM935	
.LM935:
	movl	__I0, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	# else: nil
.L1572_else:
	# else: nil
.L1571_else:
	.stabn  68,0,94,.LM936	
.LM936:
	# if: [:callm, :e, :>, [:l]]
	# callm :e.:>
	subl	$28, %esp
	# [:lvar, 3, :ecx]
	movl	-20(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____gt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm e.> END
	cmpl	%eax, nil
	je	.L1575_else
	cmpl	%eax, false
	je	.L1575_else
	# then: [:do, [:assign, :e, :l]]
	.stabn  68,0,97,.LM937	
.LM937:
	# [:lvar, 1, :edx]
	movl	-12(%ebp), %edx
	pushl	%edx
	popl	%eax
	movl	%eax, -20(%ebp)
	# else: nil
.L1575_else:
	.stabn  68,0,98,.LM938	
.LM938:
	# callm [:callm, :e, :-, [:b]].:+
	subl	$28, %esp
	# callm :e.:-
	subl	$28, %esp
	# [:lvar, 3, :ecx]
	movl	-20(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 2, :edi]
	movl	-16(%ebp), %edi
	movl	%edi, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____minus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm e.- END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :e, :-, [:b]].+ END
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	.stabn  68,0,99,.LM939	
.LM939:
	# callm :String.:new
	subl	$24, %esp
	movl	String, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__new(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm String.new END
	pushl	%eax
	popl	%eax
	movl	%eax, -24(%ebp)
	.stabn  68,0,101,.LM940	
.LM940:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	movl	%eax, %edx
	# callm :b.:__get_raw
	pushl	%edx
	subl	$24, %esp
	# [:lvar, 2, :ecx]
	movl	-16(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____get_raw(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	popl	%edx
	# callm b.__get_raw END
	addl	%edx, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -28(%ebp)
	.stabn  68,0,102,.LM941	
.LM941:
	# callm :a.:__copy_raw
	subl	$32, %esp
	# [:lvar, 4, :edi]
	movl	-24(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 5, :ecx]
	movl	-28(%ebp), %ecx
	movl	%ecx, 8(%esp)
	# [:lvar, 3, :edx]
	movl	-20(%ebp), %edx
	movl	%edx, 12(%esp)
	movl	$4, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____copy_raw(%eax)
	# Evicting self
	# Static adj: 32
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm a.__copy_raw END
	.stabn  68,0,103,.LM942	
.LM942:
	# [:lvar, 4, :edx]
	movl	-24(%ebp), %edx
	movl	%edx, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L1566_else:
	.stabn  68,0,105,.LM943	
.LM943:
	# if: [:callm, :index, :<, [[:sexp, :__I0]]]
	# callm :index.:<
	subl	$28, %esp
	# [:arg, 2, :ecx]
	movl	16(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	__I0, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm index.< END
	cmpl	%eax, nil
	je	.L1578_else
	cmpl	%eax, false
	je	.L1578_else
	# then: [:do, [:assign, :index, [:callm, :l, :+, [:index]]], [:if, [:callm, :index, :<, [[:sexp, :__I0]]], [:do, [:return, :nil]]]]
	.stabn  68,0,108,.LM944	
.LM944:
	# callm :l.:+
	subl	$28, %esp
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	# [:arg, 2, :edx]
	movl	16(%ebp), %edx
	movl	%edx, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm l.+ END
	pushl	%eax
	popl	%eax
	movl	%eax, 16(%ebp)
	# if: [:callm, :index, :<, [[:sexp, :__I0]]]
	# callm :index.:<
	subl	$28, %esp
	# [:arg, 2, :ecx]
	movl	16(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	__I0, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm index.< END
	cmpl	%eax, nil
	je	.L1579_else
	cmpl	%eax, false
	je	.L1579_else
	# then: [:do, [:return, :nil]]
	.stabn  68,0,110,.LM945	
.LM945:
	movl	nil, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L1579_else:
	# else: nil
.L1578_else:
	.stabn  68,0,112,.LM946	
.LM946:
	# if: [:callm, :index, :>=, [:l]]
	# callm :index.:>=
	subl	$28, %esp
	# [:arg, 2, :edx]
	movl	16(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____ge(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm index.>= END
	cmpl	%eax, nil
	je	.L1582_else
	cmpl	%eax, false
	je	.L1582_else
	# then: [:do, [:return, :nil]]
	.stabn  68,0,115,.LM947	
.LM947:
	movl	nil, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L1582_else:
	.stabn  68,0,116,.LM948	
.LM948:
	# callm :index.:__get_raw
	subl	$24, %esp
	# [:arg, 2, :ecx]
	movl	16(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____get_raw(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm index.__get_raw END
	pushl	%eax
	popl	%eax
	movl	%eax, 16(%ebp)
	.stabn  68,0,117,.LM949	
.LM949:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	pushl	%eax
	# [:arg, 2, :edx]
	movl	16(%ebp), %edx
	popl	%edi
	movl	%edx, %eax
	addl	%eax, %edi
	movzbl	(%edi), %eax
	movzbl	%al, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -32(%ebp)
	.stabn  68,0,118,.LM950	
.LM950:
	subl	$20, %esp
	# [:lvar, 6, :ecx]
	movl	-32(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$1, %ebx
	call	__int
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	addl	$32, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_String___NDX, .-__method_String___NDX
.Lscope172:
	.stabs  "",36,0,0,.Lscope172-.LFBB172	
		
	########################################################################	
		
		
		
		
		
		
		
	###################### __method_String___NDX__3d #######################	
		
	.stabs  "__method_String___NDX__3d:F(0,0)",36,0,0,__method_String___NDX__3d	
.globl __method_String___NDX__3d
	.type	__method_String___NDX__3d, @function
__method_String___NDX__3d:
.LFBB173:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$4, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1585_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_String___NDX__3d", 2, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1584, %eax
	movl	%eax, 4(%esp)
	movl	$2, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1585_else:
	# if: [:gt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$4, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1587_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_String___NDX__3d", 2, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1584, %eax
	movl	%eax, 4(%esp)
	movl	$2, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1587_else:
	# METHOD BODY:
	.stabn  68,0,122,.LM951	
.LM951:
	.stabn  68,0,123,.LM952	
.LM952:
	# callm :STDERR.:puts
	subl	$28, %esp
	movl	STDERR, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm [:callm, [:callm, [:callm, [:callm, [:sexp, [:call, :__get_string, :".L18"]], :to_s], :concat, [[:callm, :pos, :to_s]]], :concat, [[:callm, [:sexp, [:call, :__get_string, :".L19"]], :to_s]]], :concat, [[:callm, :str, :to_s]]].:concat
	subl	$28, %esp
	# callm [:callm, [:callm, [:callm, [:sexp, [:call, :__get_string, :".L18"]], :to_s], :concat, [[:callm, :pos, :to_s]]], :concat, [[:callm, [:sexp, [:call, :__get_string, :".L19"]], :to_s]]].:concat
	subl	$28, %esp
	# callm [:callm, [:callm, [:sexp, [:call, :__get_string, :".L18"]], :to_s], :concat, [[:callm, :pos, :to_s]]].:concat
	subl	$28, %esp
	# callm [:callm, [:sexp, [:call, :__get_string, :".L18"]], :to_s].:concat
	subl	$28, %esp
	# callm [:sexp, [:call, :__get_string, :".L18"]].:to_s
	subl	$24, %esp
	subl	$20, %esp
	movl	$.L18, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:sexp, [:call, :__get_string, :".L18"]].to_s END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :pos.:to_s
	subl	$24, %esp
	movl	16(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm pos.to_s END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__concat(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:sexp, [:call, :__get_string, :".L18"]], :to_s].concat END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm [:sexp, [:call, :__get_string, :".L19"]].:to_s
	subl	$24, %esp
	subl	$20, %esp
	movl	$.L19, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:sexp, [:call, :__get_string, :".L19"]].to_s END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__concat(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:callm, [:sexp, [:call, :__get_string, :".L18"]], :to_s], :concat, [[:callm, :pos, :to_s]]].concat END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :str.:to_s
	subl	$24, %esp
	movl	20(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm str.to_s END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__concat(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:callm, [:callm, [:sexp, [:call, :__get_string, :".L18"]], :to_s], :concat, [[:callm, :pos, :to_s]]], :concat, [[:callm, [:sexp, [:call, :__get_string, :".L19"]], :to_s]]].concat END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm [:sexp, [:call, :__get_string, :".L20"]].:to_s
	subl	$24, %esp
	subl	$20, %esp
	movl	$.L20, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:sexp, [:call, :__get_string, :".L20"]].to_s END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__concat(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:callm, [:callm, [:callm, [:sexp, [:call, :__get_string, :".L18"]], :to_s], :concat, [[:callm, :pos, :to_s]]], :concat, [[:callm, [:sexp, [:call, :__get_string, :".L19"]], :to_s]]], :concat, [[:callm, :str, :to_s]]].concat END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__puts(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm STDERR.puts END
	# callm [:sexp, :__I0].:/
	subl	$28, %esp
	movl	__I0, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I0, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____div(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:sexp, :__I0]./ END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_String___NDX__3d, .-__method_String___NDX__3d
.Lscope173:
	.stabs  "",36,0,0,.Lscope173-.LFBB173	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_String___eq #########################	
		
	.stabs  "__method_String___eq:F(0,0)",36,0,0,__method_String___eq	
.globl __method_String___eq
	.type	__method_String___eq, @function
__method_String___eq:
.LFBB174:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1590_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_String___eq", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1589, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1590_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1592_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_String___eq", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1589, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1592_else:
	# METHOD BODY:
	.stabn  68,0,127,.LM953	
.LM953:
	subl	$16, %esp
	addl	$4, %ebx
	.stabn  68,0,128,.LM954	
.LM954:
	# callm :other.:is_a?
	subl	$28, %esp
	# [:arg, 2, :ecx]
	movl	16(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	String, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__is_a__Q(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm other.is_a? END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# if: [:callm, :s, :!]
	# callm :s.:!
	subl	$24, %esp
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____X(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm s.! END
	cmpl	%eax, nil
	je	.L1594_else
	cmpl	%eax, false
	je	.L1594_else
	# then: [:return, :false]
	movl	false, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L1594_else:
	.stabn  68,0,129,.LM955	
.LM955:
	# if: [:strcmp, :@buffer, [:callm, :other, :__get_raw]]
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	movl	%eax, (%esp)
	# callm :other.:__get_raw
	subl	$24, %esp
	# [:arg, 2, :edx]
	movl	16(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____get_raw(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm other.__get_raw END
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	call	strcmp
	addl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	testl	%eax, %eax
	je	.L1596_else
	# then: :false
	movl	false, %eax
	jmp	.L1597_endif
	# else: :true
.L1596_else:
	movl	true, %eax
.L1597_endif:
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	.stabn  68,0,130,.LM956	
.LM956:
	# [:lvar, 2, :ecx]
	movl	-16(%ebp), %ecx
	movl	%ecx, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	addl	$16, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_String___eq, .-__method_String___eq
.Lscope174:
	.stabs  "",36,0,0,.Lscope174-.LFBB174	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_String_eql__Q ########################	
		
	.stabs  "__method_String_eql__Q:F(0,0)",36,0,0,__method_String_eql__Q	
.globl __method_String_eql__Q
	.type	__method_String_eql__Q, @function
__method_String_eql__Q:
.LFBB175:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1599_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_String_eql__Q", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1598, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1599_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1601_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_String_eql__Q", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1598, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1601_else:
	# METHOD BODY:
	.stabn  68,0,134,.LM957	
.LM957:
	.stabn  68,0,135,.LM958	
.LM958:
	# callm :self.:==
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.== END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_String_eql__Q, .-__method_String_eql__Q
.Lscope175:
	.stabs  "",36,0,0,.Lscope175-.LFBB175	
		
	########################################################################	
		
		
		
		
		
		
		
	###################### __method_String___copy_raw ######################	
		
	.stabs  "__method_String___copy_raw:F(0,0)",36,0,0,__method_String___copy_raw	
.globl __method_String___copy_raw
	.type	__method_String___copy_raw, @function
__method_String___copy_raw:
.LFBB176:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$4, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1604_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_String___copy_raw", 2, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1603, %eax
	movl	%eax, 4(%esp)
	movl	$2, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1604_else:
	# if: [:gt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$4, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1606_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_String___copy_raw", 2, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1603, %eax
	movl	%eax, 4(%esp)
	movl	$2, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1606_else:
	# METHOD BODY:
	.stabn  68,0,138,.LM959	
.LM959:
	subl	$12, %esp
	addl	$3, %ebx
	.stabn  68,0,139,.LM960	
.LM960:
	# callm :len.:__get_raw
	subl	$24, %esp
	# [:arg, 3, :ecx]
	movl	20(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____get_raw(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm len.__get_raw END
	movl	%eax, %edi
	movl	$1, %eax
	addl	%edi, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, 20(%ebp)
	subl	$20, %esp
	# [:arg, 3, :edx]
	movl	20(%ebp), %edx
	movl	%edx, (%esp)
	movl	$1, %ebx
	call	__alloc_leaf
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	pushl	%eax
	popl	%ecx
	movl	%ecx, 4(%esi)
	.stabn  68,0,140,.LM961	
.LM961:
	subl	$28, %esp
	movl	4(%esi), %eax
	movl	%eax, (%esp)
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	movl	%edi, 4(%esp)
	# [:arg, 3, :edx]
	movl	20(%ebp), %edx
	movl	%edx, 8(%esp)
	movl	$3, %ebx
	call	memmove
	addl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	.stabn  68,0,141,.LM962	
.LM962:
	movl	4(%esi), %eax
	pushl	%eax
	# [:arg, 3, :ecx]
	movl	20(%ebp), %ecx
	# Locked register ecx
	movl	$1, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	# Unlocked register ecx
	popl	%edx
	addl	%eax, %edx
	movb	$0, (%edx)
	movl	nil, %eax
	addl	$12, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_String___copy_raw, .-__method_String___copy_raw
.Lscope176:
	.stabs  "",36,0,0,.Lscope176-.LFBB176	
		
	########################################################################	
		
		
		
		
		
		
		
	###################### __method_String___set_raw #######################	
		
	.stabs  "__method_String___set_raw:F(0,0)",36,0,0,__method_String___set_raw	
.globl __method_String___set_raw
	.type	__method_String___set_raw, @function
__method_String___set_raw:
.LFBB177:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1609_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_String___set_raw", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1608, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1609_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1611_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_String___set_raw", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1608, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1611_else:
	# METHOD BODY:
	.stabn  68,0,146,.LM963	
.LM963:
	.stabn  68,0,147,.LM964	
.LM964:
	movl	16(%ebp), %eax
	pushl	%eax
	popl	%eax
	pushl	%eax
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ecx
	movl	%ecx, 4(%esi)
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_String___set_raw, .-__method_String___set_raw
.Lscope177:
	.stabs  "",36,0,0,.Lscope177-.LFBB177	
		
	########################################################################	
		
		
		
		
		
		
		
	###################### __method_String___get_raw #######################	
		
	.stabs  "__method_String___get_raw:F(0,0)",36,0,0,__method_String___get_raw	
.globl __method_String___get_raw
	.type	__method_String___get_raw, @function
__method_String___get_raw:
.LFBB178:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1614_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_String___get_raw", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1613, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1614_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1616_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_String___get_raw", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1613, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1616_else:
	# METHOD BODY:
	.stabn  68,0,150,.LM965	
.LM965:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_String___get_raw, .-__method_String___get_raw
.Lscope178:
	.stabs  "",36,0,0,.Lscope178-.LFBB178	
		
	########################################################################	
		
		
		
		
		
		
		
	####################### __method_String_empty__Q #######################	
		
	.stabs  "__method_String_empty__Q:F(0,0)",36,0,0,__method_String_empty__Q	
.globl __method_String_empty__Q
	.type	__method_String_empty__Q, @function
__method_String_empty__Q:
.LFBB179:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1619_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_String_empty__Q", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1618, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1619_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1621_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_String_empty__Q", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1618, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1621_else:
	# METHOD BODY:
	.stabn  68,0,154,.LM966	
.LM966:
	.stabn  68,0,156,.LM967	
.LM967:
	# callm :length.:==
	subl	$28, %esp
	# callm :self.:length
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__length(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.length END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I0, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm length.== END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_String_empty__Q, .-__method_String_empty__Q
.Lscope179:
	.stabs  "",36,0,0,.Lscope179-.LFBB179	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_String_chr ##########################	
		
	.stabs  "__method_String_chr:F(0,0)",36,0,0,__method_String_chr	
.globl __method_String_chr
	.type	__method_String_chr, @function
__method_String_chr:
.LFBB180:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1624_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_String_chr", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1623, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1624_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1626_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_String_chr", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1623, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1626_else:
	# METHOD BODY:
	.stabn  68,0,160,.LM968	
.LM968:
	.stabn  68,0,161,.LM969	
.LM969:
	# callm :self.:[]
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	__I0, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.[] END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_String_chr, .-__method_String_chr
.Lscope180:
	.stabs  "",36,0,0,.Lscope180-.LFBB180	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_String_ord ##########################	
		
	.stabs  "__method_String_ord:F(0,0)",36,0,0,__method_String_ord	
.globl __method_String_ord
	.type	__method_String_ord, @function
__method_String_ord:
.LFBB181:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1629_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_String_ord", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1628, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1629_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1631_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_String_ord", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1628, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1631_else:
	# METHOD BODY:
	.stabn  68,0,164,.LM970	
.LM970:
	.stabn  68,0,169,.LM971	
.LM971:
	# callm :self.:[]
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	__I0, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.[] END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_String_ord, .-__method_String_ord
.Lscope181:
	.stabs  "",36,0,0,.Lscope181-.LFBB181	
		
	########################################################################	
		
		
		
		
		
		
		
	###################### __method_String_each_byte #######################	
		
	.stabs  "__method_String_each_byte:F(0,0)",36,0,0,__method_String_each_byte	
.globl __method_String_each_byte
	.type	__method_String_each_byte, @function
__method_String_each_byte:
.LFBB182:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1634_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_String_each_byte", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1633, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1634_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1636_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_String_each_byte", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1633, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1636_else:
	# METHOD BODY:
	.stabn  68,0,172,.LM972	
.LM972:
	subl	$24, %esp
	addl	$6, %ebx
	subl	$20, %esp
	movl	$8, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-20(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	.stabn  68,0,173,.LM973	
.LM973:
	movl	__I0, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# callm :self.:length
	subl	$24, %esp
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__length(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.length END
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	.stabn  68,0,174,.LM974	
.LM974:
.L1639:
	# callm :i.:<
	subl	$28, %esp
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 2, :edx]
	movl	-16(%ebp), %edx
	movl	%edx, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm i.< END
	cmpl	%eax, nil
	je	.L1638
	cmpl	%eax, false
	je	.L1638
	.stabn  68,0,175,.LM975	
.LM975:
	# callm [:index, :__env__, 1].:call
	subl	$28, %esp
	movl	-20(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	movl	(%ecx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :self.:[]
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 1, :edx]
	movl	-12(%ebp), %edx
	movl	%edx, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.[] END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__call(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].call END
	.stabn  68,0,176,.LM976	
.LM976:
	# callm :i.:+
	subl	$28, %esp
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm i.+ END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	jmp	.L1639
.L1638:
	movl	nil, %eax
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, %eax
	addl	$24, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_String_each_byte, .-__method_String_each_byte
.Lscope182:
	.stabs  "",36,0,0,.Lscope182-.LFBB182	
		
	########################################################################	
		
		
		
		
		
		
		
	####################### __method_String___le__gt #######################	
		
	.stabs  "__method_String___le__gt:F(0,0)",36,0,0,__method_String___le__gt	
.globl __method_String___le__gt
	.type	__method_String___le__gt, @function
__method_String___le__gt:
.LFBB183:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1641_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_String___le__gt", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1640, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1641_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1643_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_String___le__gt", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1640, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1643_else:
	# METHOD BODY:
	.stabn  68,0,191,.LM977	
.LM977:
	subl	$16, %esp
	addl	$4, %ebx
	.stabn  68,0,192,.LM978	
.LM978:
	# if: [:callm, [:callm, :other, :kind_of?, [:String]], :!]
	# callm [:callm, :other, :kind_of?, [:String]].:!
	subl	$24, %esp
	# callm :other.:kind_of?
	subl	$28, %esp
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	String, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__kind_of__Q(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm other.kind_of? END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____X(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :other, :kind_of?, [:String]].! END
	cmpl	%eax, nil
	je	.L1645_else
	cmpl	%eax, false
	je	.L1645_else
	# then: [:return, :nil]
	movl	nil, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L1645_else:
	movl	__I0, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	.stabn  68,0,194,.LM979	
.LM979:
	# if: [:callm, :length, :>, [[:callm, :other, :length]]]
	# callm :length.:>
	subl	$28, %esp
	# callm :self.:length
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__length(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.length END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :other.:length
	subl	$24, %esp
	# [:arg, 2, :ecx]
	movl	16(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__length(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm other.length END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____gt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm length.> END
	cmpl	%eax, nil
	je	.L1647_else
	cmpl	%eax, false
	je	.L1647_else
	# then: [:callm, :other, :length]
	# callm :other.:length
	subl	$24, %esp
	# [:arg, 2, :edx]
	movl	16(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__length(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm other.length END
	jmp	.L1648_endif
	# else: :length
.L1647_else:
	# callm :self.:length
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__length(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.length END
.L1648_endif:
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	.stabn  68,0,195,.LM980	
.LM980:
.L1650:
	# callm :i.:<
	subl	$28, %esp
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 2, :ecx]
	movl	-16(%ebp), %ecx
	movl	%ecx, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm i.< END
	cmpl	%eax, nil
	je	.L1649
	cmpl	%eax, false
	je	.L1649
	.stabn  68,0,197,.LM981	
.LM981:
	# if: [:callm, [:callm, :self, :[], [:i]], :<, [[:callm, :other, :[], [:i]]]]
	# callm [:callm, :self, :[], [:i]].:<
	subl	$28, %esp
	# callm :self.:[]
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 1, :edx]
	movl	-12(%ebp), %edx
	movl	%edx, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.[] END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :other.:[]
	subl	$28, %esp
	# [:arg, 2, :ecx]
	movl	16(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm other.[] END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :self, :[], [:i]].< END
	cmpl	%eax, nil
	je	.L1651_else
	cmpl	%eax, false
	je	.L1651_else
	# then: [:return, [:sexp, :__Ineg1]]
	movl	__Ineg1, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L1651_else:
	.stabn  68,0,198,.LM982	
.LM982:
	# if: [:callm, [:callm, :self, :[], [:i]], :>, [[:callm, :other, :[], [:i]]]]
	# callm [:callm, :self, :[], [:i]].:>
	subl	$28, %esp
	# callm :self.:[]
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 1, :edx]
	movl	-12(%ebp), %edx
	movl	%edx, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.[] END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :other.:[]
	subl	$28, %esp
	# [:arg, 2, :ecx]
	movl	16(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm other.[] END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____gt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :self, :[], [:i]].> END
	cmpl	%eax, nil
	je	.L1653_else
	cmpl	%eax, false
	je	.L1653_else
	# then: [:return, [:sexp, :__I1]]
	movl	__I1, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L1653_else:
	.stabn  68,0,199,.LM983	
.LM983:
	# callm :i.:+
	subl	$28, %esp
	# [:lvar, 1, :edx]
	movl	-12(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm i.+ END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	jmp	.L1650
.L1649:
	movl	nil, %eax
	.stabn  68,0,201,.LM984	
.LM984:
	# if: [:callm, :i, :<, [[:callm, :other, :length]]]
	# callm :i.:<
	subl	$28, %esp
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	# callm :other.:length
	subl	$24, %esp
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__length(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm other.length END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm i.< END
	cmpl	%eax, nil
	je	.L1655_else
	cmpl	%eax, false
	je	.L1655_else
	# then: [:return, [:sexp, :__Ineg1]]
	movl	__Ineg1, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L1655_else:
	.stabn  68,0,203,.LM985	
.LM985:
	# if: [:callm, :length, :>, [[:callm, :other, :length]]]
	# callm :length.:>
	subl	$28, %esp
	# callm :self.:length
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__length(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.length END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :other.:length
	subl	$24, %esp
	# [:arg, 2, :edx]
	movl	16(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__length(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm other.length END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____gt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm length.> END
	cmpl	%eax, nil
	je	.L1657_else
	cmpl	%eax, false
	je	.L1657_else
	# then: [:return, [:sexp, :__I1]]
	movl	__I1, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L1657_else:
	.stabn  68,0,204,.LM986	
.LM986:
	movl	__I0, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	addl	$16, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_String___le__gt, .-__method_String___le__gt
.Lscope183:
	.stabs  "",36,0,0,.Lscope183-.LFBB183	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_String_uniq #########################	
		
	.stabs  "__method_String_uniq:F(0,0)",36,0,0,__method_String_uniq	
.globl __method_String_uniq
	.type	__method_String_uniq, @function
__method_String_uniq:
.LFBB184:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1660_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_String_uniq", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1659, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1660_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1662_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_String_uniq", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1659, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1662_else:
	# METHOD BODY:
	.stabn  68,0,210,.LM987	
.LM987:
	movl	nil, %eax
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_String_uniq, .-__method_String_uniq
.Lscope184:
	.stabs  "",36,0,0,.Lscope184-.LFBB184	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_String_to_s #########################	
		
	.stabs  "__method_String_to_s:F(0,0)",36,0,0,__method_String_to_s	
.globl __method_String_to_s
	.type	__method_String_to_s, @function
__method_String_to_s:
.LFBB185:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1665_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_String_to_s", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1664, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1665_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1667_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_String_to_s", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1664, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1667_else:
	# METHOD BODY:
	.stabn  68,0,213,.LM988	
.LM988:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, %eax
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_String_to_s, .-__method_String_to_s
.Lscope185:
	.stabs  "",36,0,0,.Lscope185-.LFBB185	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_String_to_sym ########################	
		
	.stabs  "__method_String_to_sym:F(0,0)",36,0,0,__method_String_to_sym	
.globl __method_String_to_sym
	.type	__method_String_to_sym, @function
__method_String_to_sym:
.LFBB186:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1670_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_String_to_sym", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1669, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1670_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1672_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_String_to_sym", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1669, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1672_else:
	# METHOD BODY:
	.stabn  68,0,217,.LM989	
.LM989:
	subl	$12, %esp
	addl	$3, %ebx
	.stabn  68,0,218,.LM990	
.LM990:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	subl	$20, %esp
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	addl	$12, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_String_to_sym, .-__method_String_to_sym
.Lscope186:
	.stabs  "",36,0,0,.Lscope186-.LFBB186	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_String_to_i #########################	
		
	.stabs  "__method_String_to_i:F(0,0)",36,0,0,__method_String_to_i	
.globl __method_String_to_i
	.type	__method_String_to_i, @function
__method_String_to_i:
.LFBB187:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1675_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_String_to_i", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1674, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1675_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1677_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_String_to_i", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1674, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1677_else:
	# METHOD BODY:
	.stabn  68,0,222,.LM991	
.LM991:
	subl	$28, %esp
	addl	$7, %ebx
	.stabn  68,0,223,.LM992	
.LM992:
	movl	__I0, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	movl	__I0, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	.stabn  68,0,224,.LM993	
.LM993:
	# callm :self.:length
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__length(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.length END
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	.stabn  68,0,225,.LM994	
.LM994:
	movl	false, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -24(%ebp)
	.stabn  68,0,226,.LM995	
.LM995:
	# if: [:callm, [:callm, :self, :[], [[:sexp, :__I0]]], :==, [[:sexp, :__I45]]]
	# callm [:callm, :self, :[], [[:sexp, :__I0]]].:==
	subl	$28, %esp
	# callm :self.:[]
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	__I0, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.[] END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I45, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :self, :[], [[:sexp, :__I0]]].== END
	cmpl	%eax, nil
	je	.L1679_else
	cmpl	%eax, false
	je	.L1679_else
	# then: [:do, [:assign, :neg, :true], [:assign, :i, [:callm, :i, :+, [[:sexp, :__I1]]]]]
	.stabn  68,0,228,.LM996	
.LM996:
	movl	true, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -24(%ebp)
	# callm :i.:+
	subl	$28, %esp
	# [:lvar, 2, :ecx]
	movl	-16(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm i.+ END
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	# else: nil
.L1679_else:
	.stabn  68,0,230,.LM997	
.LM997:
.L1682:
	# callm :i.:<
	subl	$28, %esp
	# [:lvar, 2, :edi]
	movl	-16(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 3, :edx]
	movl	-20(%ebp), %edx
	movl	%edx, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm i.< END
	cmpl	%eax, nil
	je	.L1681
	cmpl	%eax, false
	je	.L1681
	.stabn  68,0,231,.LM998	
.LM998:
	# callm :self.:[]
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 2, :ecx]
	movl	-16(%ebp), %ecx
	movl	%ecx, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.[] END
	pushl	%eax
	popl	%eax
	movl	%eax, -28(%ebp)
	.stabn  68,0,232,.LM999	
.LM999:
	# if: [:callm, [:callm, [:callm, :Range, :new, [[:sexp, :__I48], [:sexp, :__I57]]], :member?, [:s]], :!]
	# callm [:callm, [:callm, :Range, :new, [[:sexp, :__I48], [:sexp, :__I57]]], :member?, [:s]].:!
	subl	$24, %esp
	# callm [:callm, :Range, :new, [[:sexp, :__I48], [:sexp, :__I57]]].:member?
	subl	$28, %esp
	# callm :Range.:new
	subl	$32, %esp
	movl	Range, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I48, %eax
	movl	%eax, 8(%esp)
	movl	__I57, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__new(%eax)
	# Evicting self
	# Static adj: 32
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm Range.new END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 5, :edx]
	movl	-28(%ebp), %edx
	movl	%edx, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__member__Q(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :Range, :new, [[:sexp, :__I48], [:sexp, :__I57]]].member? END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____X(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:callm, :Range, :new, [[:sexp, :__I48], [:sexp, :__I57]]], :member?, [:s]].! END
	cmpl	%eax, nil
	je	.L1683_else
	cmpl	%eax, false
	je	.L1683_else
	# then: [:break]
	# BREAK
	jmp	.L1681
	# else: nil
.L1683_else:
	.stabn  68,0,233,.LM1000	
.LM1000:
	# callm [:callm, [:callm, :num, :*, [[:sexp, :__I10]]], :+, [:s]].:-
	subl	$28, %esp
	# callm [:callm, :num, :*, [[:sexp, :__I10]]].:+
	subl	$28, %esp
	# callm :num.:*
	subl	$28, %esp
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	__I10, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____mul(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm num.* END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 5, :ecx]
	movl	-28(%ebp), %ecx
	movl	%ecx, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :num, :*, [[:sexp, :__I10]]].+ END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I48, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____minus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:callm, :num, :*, [[:sexp, :__I10]]], :+, [:s]].- END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	.stabn  68,0,234,.LM1001	
.LM1001:
	# callm :i.:+
	subl	$28, %esp
	# [:lvar, 2, :edx]
	movl	-16(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm i.+ END
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	jmp	.L1682
.L1681:
	movl	nil, %eax
	.stabn  68,0,236,.LM1002	
.LM1002:
	# if: :neg
	# [:lvar, 4, :edi]
	movl	-24(%ebp), %edi
	movl	%edi, %eax
	cmpl	%eax, nil
	je	.L1685_else
	cmpl	%eax, false
	je	.L1685_else
	# then: [:do, [:return, [:callm, :num, :*, [[:sexp, :__Ineg1]]]]]
	.stabn  68,0,238,.LM1003	
.LM1003:
	# callm :num.:*
	subl	$28, %esp
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	__Ineg1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____mul(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm num.* END
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L1685_else:
	.stabn  68,0,239,.LM1004	
.LM1004:
	# [:lvar, 1, :edx]
	movl	-12(%ebp), %edx
	movl	%edx, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	addl	$28, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_String_to_i, .-__method_String_to_i
.Lscope187:
	.stabs  "",36,0,0,.Lscope187-.LFBB187	
		
	########################################################################	
		
		
		
		
		
		
		
	####################### __method_String_slice__X #######################	
		
	.stabs  "__method_String_slice__X:F(0,0)",36,0,0,__method_String_slice__X	
.globl __method_String_slice__X
	.type	__method_String_slice__X, @function
__method_String_slice__X:
.LFBB188:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$4, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1688_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_String_slice__X", 2, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1687, %eax
	movl	%eax, 4(%esp)
	movl	$2, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1688_else:
	# if: [:gt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$4, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1690_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_String_slice__X", 2, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1687, %eax
	movl	%eax, 4(%esp)
	movl	$2, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1690_else:
	# METHOD BODY:
	.stabn  68,0,243,.LM1005	
.LM1005:
	subl	$28, %esp
	addl	$7, %ebx
	.stabn  68,0,245,.LM1006	
.LM1006:
	# callm :self.:length
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__length(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.length END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# if: [:callm, :b, :<, [[:sexp, :__I0]]]
	# callm :b.:<
	subl	$28, %esp
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	__I0, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm b.< END
	cmpl	%eax, nil
	je	.L1692_else
	cmpl	%eax, false
	je	.L1692_else
	# then: [:do, [:assign, :b, [:callm, :l, :+, [:b]]]]
	.stabn  68,0,248,.LM1007	
.LM1007:
	# callm :l.:+
	subl	$28, %esp
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	# [:arg, 2, :edx]
	movl	16(%ebp), %edx
	movl	%edx, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm l.+ END
	pushl	%eax
	popl	%eax
	movl	%eax, 16(%ebp)
	# else: nil
.L1692_else:
	.stabn  68,0,249,.LM1008	
.LM1008:
	# if: [:callm, :b, :<, [[:sexp, :__I0]]]
	# callm :b.:<
	subl	$28, %esp
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	__I0, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm b.< END
	cmpl	%eax, nil
	je	.L1694_else
	cmpl	%eax, false
	je	.L1694_else
	# then: [:do, [:return, :nil]]
	.stabn  68,0,252,.LM1009	
.LM1009:
	movl	nil, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L1694_else:
	.stabn  68,0,253,.LM1010	
.LM1010:
	# callm :b.:+
	subl	$28, %esp
	# [:arg, 2, :edx]
	movl	16(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	# [:arg, 3, :ecx]
	movl	20(%ebp), %ecx
	movl	%ecx, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm b.+ END
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	.stabn  68,0,255,.LM1011	
.LM1011:
	# if: [:callm, :endp, :>, [:l]]
	# callm :endp.:>
	subl	$28, %esp
	# [:lvar, 2, :edi]
	movl	-16(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 1, :edx]
	movl	-12(%ebp), %edx
	movl	%edx, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____gt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm endp.> END
	cmpl	%eax, nil
	je	.L1696_else
	cmpl	%eax, false
	je	.L1696_else
	# then: [:do, [:assign, :e, [:callm, :l, :-, [:b]]]]
	.stabn  68,0,257,.LM1012	
.LM1012:
	# callm :l.:-
	subl	$28, %esp
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	# [:arg, 2, :edx]
	movl	16(%ebp), %edx
	movl	%edx, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____minus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm l.- END
	pushl	%eax
	popl	%eax
	movl	%eax, 20(%ebp)
	# else: nil
.L1696_else:
	.stabn  68,0,258,.LM1013	
.LM1013:
	# callm :String.:new
	subl	$24, %esp
	movl	String, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__new(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm String.new END
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	.stabn  68,0,260,.LM1014	
.LM1014:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	movl	%eax, %edi
	# callm :b.:__get_raw
	pushl	%edi
	subl	$24, %esp
	# [:arg, 2, :edx]
	movl	16(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____get_raw(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	popl	%edi
	# callm b.__get_raw END
	addl	%edi, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -24(%ebp)
	.stabn  68,0,261,.LM1015	
.LM1015:
	# callm :n.:__copy_raw
	subl	$32, %esp
	# [:lvar, 3, :ecx]
	movl	-20(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 4, :edx]
	movl	-24(%ebp), %edx
	movl	%edx, 8(%esp)
	# [:arg, 3, :edi]
	movl	20(%ebp), %edi
	movl	%edi, 12(%esp)
	movl	$4, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____copy_raw(%eax)
	# Evicting self
	# Static adj: 32
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm n.__copy_raw END
	.stabn  68,0,262,.LM1016	
.LM1016:
	# callm :b.:+
	subl	$28, %esp
	# [:arg, 2, :edx]
	movl	16(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	# [:arg, 3, :ecx]
	movl	20(%ebp), %ecx
	movl	%ecx, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm b.+ END
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	.stabn  68,0,264,.LM1017	
.LM1017:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	movl	%eax, %edi
	# callm :b.:__get_raw
	pushl	%edi
	subl	$24, %esp
	# [:arg, 2, :edx]
	movl	16(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____get_raw(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	popl	%edi
	# callm b.__get_raw END
	addl	%edi, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -28(%ebp)
	.stabn  68,0,265,.LM1018	
.LM1018:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	movl	%eax, %ecx
	# callm :endp.:__get_raw
	pushl	%ecx
	subl	$24, %esp
	# [:lvar, 2, :edx]
	movl	-16(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____get_raw(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	popl	%ecx
	# callm endp.__get_raw END
	addl	%ecx, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -24(%ebp)
	.stabn  68,0,266,.LM1019	
.LM1019:
	subl	$28, %esp
	# [:lvar, 5, :edi]
	movl	-28(%ebp), %edi
	movl	%edi, (%esp)
	# [:lvar, 4, :edx]
	movl	-24(%ebp), %edx
	movl	%edx, 4(%esp)
	# callm :e.:__get_raw
	subl	$24, %esp
	# [:arg, 3, :ecx]
	movl	20(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____get_raw(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm e.__get_raw END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	call	memmove
	addl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	# [:lvar, 3, :edx]
	movl	-20(%ebp), %edx
	movl	%edx, %eax
	addl	$28, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_String_slice__X, .-__method_String_slice__X
.Lscope188:
	.stabs  "",36,0,0,.Lscope188-.LFBB188	
		
	########################################################################	
		
		
		
		
		
		
		
	####################### __method_String_reverse ########################	
		
	.stabs  "__method_String_reverse:F(0,0)",36,0,0,__method_String_reverse	
.globl __method_String_reverse
	.type	__method_String_reverse, @function
__method_String_reverse:
.LFBB189:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1699_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_String_reverse", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1698, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1699_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1701_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_String_reverse", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1698, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1701_else:
	# METHOD BODY:
	.stabn  68,0,273,.LM1020	
.LM1020:
	subl	$16, %esp
	addl	$4, %ebx
	.stabn  68,0,274,.LM1021	
.LM1021:
	subl	$20, %esp
	movl	$.L0, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# callm :self.:length
	subl	$24, %esp
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__length(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.length END
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	.stabn  68,0,275,.LM1022	
.LM1022:
	# if: [:callm, :l, :==, [[:sexp, :__I0]]]
	# callm :l.:==
	subl	$28, %esp
	# [:lvar, 2, :edi]
	movl	-16(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	__I0, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm l.== END
	cmpl	%eax, nil
	je	.L1703_else
	cmpl	%eax, false
	je	.L1703_else
	# then: [:do, [:return]]
	.stabn  68,0,277,.LM1023	
.LM1023:
	movl	nil, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L1703_else:
	.stabn  68,0,278,.LM1024	
.LM1024:
.L1706:
	# callm :l.:>
	subl	$28, %esp
	# [:lvar, 2, :ecx]
	movl	-16(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	__I0, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____gt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm l.> END
	cmpl	%eax, nil
	je	.L1705
	cmpl	%eax, false
	je	.L1705
	.stabn  68,0,279,.LM1025	
.LM1025:
	# callm :l.:-
	subl	$28, %esp
	# [:lvar, 2, :edx]
	movl	-16(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____minus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm l.- END
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	.stabn  68,0,280,.LM1026	
.LM1026:
	# callm :buf.:<<
	subl	$28, %esp
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	# callm [:callm, :self, :[], [:l]].:chr
	subl	$24, %esp
	# callm :self.:[]
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 2, :ecx]
	movl	-16(%ebp), %ecx
	movl	%ecx, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.[] END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__chr(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :self, :[], [:l]].chr END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt__lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm buf.<< END
	jmp	.L1706
.L1705:
	movl	nil, %eax
	# [:lvar, 1, :edx]
	movl	-12(%ebp), %edx
	movl	%edx, %eax
	addl	$16, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_String_reverse, .-__method_String_reverse
.Lscope189:
	.stabs  "",36,0,0,.Lscope189-.LFBB189	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_String_length ########################	
		
	.stabs  "__method_String_length:F(0,0)",36,0,0,__method_String_length	
.globl __method_String_length
	.type	__method_String_length, @function
__method_String_length:
.LFBB190:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1708_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_String_length", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1707, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1708_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1710_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_String_length", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1707, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1710_else:
	# METHOD BODY:
	.stabn  68,0,286,.LM1027	
.LM1027:
	subl	$12, %esp
	addl	$3, %ebx
	.stabn  68,0,289,.LM1028	
.LM1028:
	subl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	strlen
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	subl	$20, %esp
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, (%esp)
	movl	$1, %ebx
	call	__int
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	addl	$12, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_String_length, .-__method_String_length
.Lscope190:
	.stabs  "",36,0,0,.Lscope190-.LFBB190	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_String_size #########################	
		
	.stabs  "__method_String_size:F(0,0)",36,0,0,__method_String_size	
.globl __method_String_size
	.type	__method_String_size, @function
__method_String_size:
.LFBB191:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1713_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_String_size", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1712, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1713_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1715_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_String_size", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1712, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1715_else:
	# METHOD BODY:
	.stabn  68,0,293,.LM1029	
.LM1029:
	# callm :self.:length
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__length(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.length END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_String_size, .-__method_String_size
.Lscope191:
	.stabs  "",36,0,0,.Lscope191-.LFBB191	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_String_count #########################	
		
	.stabs  "__method_String_count:F(0,0)",36,0,0,__method_String_count	
.globl __method_String_count
	.type	__method_String_count, @function
__method_String_count:
.LFBB192:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1718_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_String_count", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1717, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1718_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1720_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_String_count", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1717, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1720_else:
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for c at position 4
	# :nil
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1722_else
	# then: [:assign, :"#c", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L1723_endif
	# else: [:assign, :"#c", :c]
.L1722_else:
	# [:arg, 2, :ecx]
	movl	16(%ebp), %ecx
	pushl	%ecx
	popl	%eax
	movl	%eax, -8(%ebp)
.L1723_endif:
	# METHOD BODY:
	.stabn  68,0,297,.LM1030	
.LM1030:
	subl	$16, %esp
	addl	$4, %ebx
	subl	$20, %esp
	movl	$16, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	# [:lvar, 0, :edx]
	movl	-8(%ebp), %edx
	pushl	%edx
	movl	-16(%ebp), %eax
	movl	%eax, %edi
	addl	$4, %edi
	popl	%eax
	movl	%eax, (%edi)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-16(%ebp), %eax
	movl	%eax, %ecx
	addl	$12, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	.stabn  68,0,298,.LM1031	
.LM1031:
	# if: [:callm, [:index, :__env__, 1], :!]
	# callm [:index, :__env__, 1].:!
	subl	$24, %esp
	movl	-16(%ebp), %eax
	movl	%eax, %edi
	addl	$4, %edi
	movl	(%edi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____X(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].! END
	cmpl	%eax, nil
	je	.L1724_else
	cmpl	%eax, false
	je	.L1724_else
	# then: [:return, :length]
	# callm :self.:length
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__length(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.length END
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L1724_else:
	movl	__I0, %eax
	pushl	%eax
	movl	-16(%ebp), %eax
	movl	%eax, %ecx
	addl	$8, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	.stabn  68,0,299,.LM1032	
.LM1032:
	# callm [:index, :__env__, 1].:ord
	subl	$24, %esp
	movl	-16(%ebp), %eax
	movl	%eax, %edx
	addl	$4, %edx
	movl	(%edx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__ord(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].ord END
	pushl	%eax
	movl	-16(%ebp), %eax
	movl	%eax, %edi
	addl	$4, %edi
	popl	%eax
	movl	%eax, (%edi)
	.stabn  68,0,300,.LM1033	
.LM1033:
	# callm :self.:each_byte
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	.stabn  68,0,301,.LM1034	
.LM1034:
	# Stack frame
	pushl	%ebp
	movl	-16(%ebp), %eax
	movl	%eax, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	movl	$__lambda_L99, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	subl	$32, %esp
	movl	-20(%ebp), %eax
	movl	%eax, (%esp)
	movl	-16(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%esi, 8(%esp)
	movl	$1, 12(%esp)
	movl	$4, %ebx
	call	__new_proc
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__each_byte(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.each_byte END
	movl	-16(%ebp), %eax
	movl	%eax, %edx
	addl	$8, %edx
	movl	(%edx), %eax
	addl	$16, %esp
	addl	$4, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_String_count, .-__method_String_count
.Lscope192:
	.stabs  "",36,0,0,.Lscope192-.LFBB192	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_String_concat ########################	
		
	.stabs  "__method_String_concat:F(0,0)",36,0,0,__method_String_concat	
.globl __method_String_concat
	.type	__method_String_concat, @function
__method_String_concat:
.LFBB193:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1728_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_String_concat", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1727, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1728_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1730_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_String_concat", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1727, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1730_else:
	# METHOD BODY:
	.stabn  68,0,311,.LM1035	
.LM1035:
	subl	$28, %esp
	addl	$7, %ebx
	.stabn  68,0,312,.LM1036	
.LM1036:
	# if: [:callm, :other, :is_a?, [:Fixnum]]
	# callm :other.:is_a?
	subl	$28, %esp
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	Fixnum, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__is_a__Q(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm other.is_a? END
	cmpl	%eax, nil
	je	.L1732_else
	cmpl	%eax, false
	je	.L1732_else
	# then: [:do, [:assign, :other, [:callm, :other, :chr]]]
	.stabn  68,0,313,.LM1037	
.LM1037:
	# callm :other.:chr
	subl	$24, %esp
	# [:arg, 2, :ecx]
	movl	16(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__chr(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm other.chr END
	pushl	%eax
	popl	%eax
	movl	%eax, 16(%ebp)
	jmp	.L1733_endif
	# else: [:do, [:assign, :other, [:callm, :other, :to_s]]]
.L1732_else:
	.stabn  68,0,315,.LM1038	
.LM1038:
	# callm :other.:to_s
	subl	$24, %esp
	# [:arg, 2, :edx]
	movl	16(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm other.to_s END
	pushl	%eax
	popl	%eax
	movl	%eax, 16(%ebp)
.L1733_endif:
	.stabn  68,0,316,.LM1039	
.LM1039:
	# callm :other.:__get_raw
	subl	$24, %esp
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____get_raw(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm other.__get_raw END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	subl	$20, %esp
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$1, %ebx
	call	strlen
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	subl	$20, %esp
	movl	4(%esi), %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	strlen
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	# [:lvar, 3, :edx]
	movl	-20(%ebp), %edx
	# Locked register edx
	# [:lvar, 2, :edi]
	movl	-16(%ebp), %edi
	movl	%edi, %eax
	addl	%edx, %eax
	# Unlocked register edx
	pushl	%eax
	popl	%eax
	movl	%eax, -24(%ebp)
	# [:lvar, 4, :ecx]
	movl	-24(%ebp), %ecx
	# Locked register ecx
	movl	$1, %eax
	addl	%ecx, %eax
	# Unlocked register ecx
	pushl	%eax
	# Marked ecx dirty (lvar,4)
	popl	%eax
	movl	%eax, %ecx
	# Saving ecx to lvar,4
	movl	%ecx, -24(%ebp)
	subl	$20, %esp
	# [:lvar, 4, :edx]
	movl	-24(%ebp), %edx
	movl	%edx, (%esp)
	movl	$1, %ebx
	call	__alloc_leaf
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -28(%ebp)
	subl	$24, %esp
	# [:lvar, 5, :ecx]
	movl	-28(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	4(%esi), %eax
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	call	strcpy
	addl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	subl	$24, %esp
	# [:lvar, 5, :edi]
	movl	-28(%ebp), %edi
	movl	%edi, (%esp)
	# [:lvar, 1, :edx]
	movl	-12(%ebp), %edx
	movl	%edx, 4(%esp)
	movl	$2, %ebx
	call	strcat
	addl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	# [:lvar, 5, :ecx]
	movl	-28(%ebp), %ecx
	pushl	%ecx
	popl	%ecx
	pushl	%ecx
	popl	%edx
	movl	%edx, 4(%esi)
	movl	%esi, %eax
	addl	$28, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_String_concat, .-__method_String_concat
.Lscope193:
	.stabs  "",36,0,0,.Lscope193-.LFBB193	
		
	########################################################################	
		
		
		
		
		
		
		
	####################### __method_String___lt__lt #######################	
		
	.stabs  "__method_String___lt__lt:F(0,0)",36,0,0,__method_String___lt__lt	
.globl __method_String___lt__lt
	.type	__method_String___lt__lt, @function
__method_String___lt__lt:
.LFBB194:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1735_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_String___lt__lt", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1734, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1735_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1737_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_String___lt__lt", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1734, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1737_else:
	# METHOD BODY:
	.stabn  68,0,331,.LM1040	
.LM1040:
	.stabn  68,0,332,.LM1041	
.LM1041:
	# callm :self.:concat
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__concat(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.concat END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_String___lt__lt, .-__method_String___lt__lt
.Lscope194:
	.stabs  "",36,0,0,.Lscope194-.LFBB194	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_String_dup ##########################	
		
	.stabs  "__method_String_dup:F(0,0)",36,0,0,__method_String_dup	
.globl __method_String_dup
	.type	__method_String_dup, @function
__method_String_dup:
.LFBB195:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1740_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_String_dup", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1739, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1740_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1742_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_String_dup", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1739, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1742_else:
	# METHOD BODY:
	.stabn  68,0,335,.LM1042	
.LM1042:
	.stabn  68,0,336,.LM1043	
.LM1043:
	# callm :String.:new
	subl	$28, %esp
	movl	String, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__new(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm String.new END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_String_dup, .-__method_String_dup
.Lscope195:
	.stabs  "",36,0,0,.Lscope195-.LFBB195	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_String___plus ########################	
		
	.stabs  "__method_String___plus:F(0,0)",36,0,0,__method_String___plus	
.globl __method_String___plus
	.type	__method_String___plus, @function
__method_String___plus:
.LFBB196:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1745_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_String___plus", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1744, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1745_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1747_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_String___plus", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1744, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1747_else:
	# METHOD BODY:
	.stabn  68,0,340,.LM1044	
.LM1044:
	.stabn  68,0,341,.LM1045	
.LM1045:
	# callm :dup.:concat
	subl	$28, %esp
	# callm :self.:dup
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__dup(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.dup END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__concat(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm dup.concat END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_String___plus, .-__method_String___plus
.Lscope196:
	.stabs  "",36,0,0,.Lscope196-.LFBB196	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_String___mul #########################	
		
	.stabs  "__method_String___mul:F(0,0)",36,0,0,__method_String___mul	
.globl __method_String___mul
	.type	__method_String___mul, @function
__method_String___mul:
.LFBB197:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1750_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_String___mul", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1749, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1750_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1752_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_String___mul", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1749, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1752_else:
	# METHOD BODY:
	.stabn  68,0,345,.LM1046	
.LM1046:
	subl	$16, %esp
	addl	$4, %ebx
	subl	$20, %esp
	movl	$12, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	addl	$8, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	.stabn  68,0,346,.LM1047	
.LM1047:
	subl	$20, %esp
	movl	$.L0, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %edi
	addl	$4, %edi
	popl	%eax
	movl	%eax, (%edi)
	# callm :cnt.:times
	subl	$24, %esp
	# [:arg, 2, :edx]
	movl	16(%ebp), %edx
	movl	%edx, (%esp)
	.stabn  68,0,347,.LM1048	
.LM1048:
	# Stack frame
	pushl	%ebp
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	movl	$__lambda_L100, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	subl	$32, %esp
	movl	-16(%ebp), %eax
	movl	%eax, (%esp)
	movl	-12(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%esi, 8(%esp)
	movl	$0, 12(%esp)
	movl	$4, %ebx
	call	__new_proc
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__times(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm cnt.times END
	movl	-12(%ebp), %eax
	movl	%eax, %edi
	addl	$4, %edi
	movl	(%edi), %eax
	addl	$16, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_String___mul, .-__method_String___mul
.Lscope197:
	.stabs  "",36,0,0,.Lscope197-.LFBB197	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_String_rindex ########################	
		
	.stabs  "__method_String_rindex:F(0,0)",36,0,0,__method_String_rindex	
.globl __method_String_rindex
	.type	__method_String_rindex, @function
__method_String_rindex:
.LFBB198:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1756_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_String_rindex", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1755, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1756_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1758_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_String_rindex", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1755, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1758_else:
	# METHOD BODY:
	.stabn  68,0,354,.LM1049	
.LM1049:
	subl	$12, %esp
	addl	$3, %ebx
	.stabn  68,0,355,.LM1050	
.LM1050:
	# callm :self.:length
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__length(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.length END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# callm :ch.:ord
	subl	$24, %esp
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__ord(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm ch.ord END
	pushl	%eax
	popl	%eax
	movl	%eax, 16(%ebp)
	.stabn  68,0,356,.LM1051	
.LM1051:
.L1761:
	# callm :l.:>
	subl	$28, %esp
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	__I0, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____gt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm l.> END
	cmpl	%eax, nil
	je	.L1760
	cmpl	%eax, false
	je	.L1760
	.stabn  68,0,357,.LM1052	
.LM1052:
	# callm :l.:-
	subl	$28, %esp
	# [:lvar, 1, :edx]
	movl	-12(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____minus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm l.- END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	.stabn  68,0,358,.LM1053	
.LM1053:
	# if: [:callm, [:callm, [:callm, :self, :[], [:l]], :ord], :==, [[:callm, :ch, :ord]]]
	# callm [:callm, [:callm, :self, :[], [:l]], :ord].:==
	subl	$28, %esp
	# callm [:callm, :self, :[], [:l]].:ord
	subl	$24, %esp
	# callm :self.:[]
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.[] END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__ord(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :self, :[], [:l]].ord END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :ch.:ord
	subl	$24, %esp
	# [:arg, 2, :ecx]
	movl	16(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__ord(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm ch.ord END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:callm, :self, :[], [:l]], :ord].== END
	cmpl	%eax, nil
	je	.L1762_else
	cmpl	%eax, false
	je	.L1762_else
	# then: [:do, [:return, :l]]
	.stabn  68,0,360,.LM1054	
.LM1054:
	# [:lvar, 1, :edx]
	movl	-12(%ebp), %edx
	movl	%edx, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L1762_else:
	jmp	.L1761
.L1760:
	movl	nil, %eax
	.stabn  68,0,362,.LM1055	
.LM1055:
	movl	nil, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	addl	$12, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_String_rindex, .-__method_String_rindex
.Lscope198:
	.stabs  "",36,0,0,.Lscope198-.LFBB198	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_String_gsub #########################	
		
	.stabs  "__method_String_gsub:F(0,0)",36,0,0,__method_String_gsub	
.globl __method_String_gsub
	.type	__method_String_gsub, @function
__method_String_gsub:
.LFBB199:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$4, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1765_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_String_gsub", 2, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1764, %eax
	movl	%eax, 4(%esp)
	movl	$2, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1765_else:
	# if: [:gt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$4, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1767_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_String_gsub", 2, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1764, %eax
	movl	%eax, 4(%esp)
	movl	$2, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1767_else:
	# METHOD BODY:
	.stabn  68,0,369,.LM1056	
.LM1056:
	subl	$16, %esp
	addl	$4, %ebx
	subl	$20, %esp
	movl	$20, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# [:arg, 3, :edi]
	movl	20(%ebp), %edi
	pushl	%edi
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	addl	$12, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %edx
	addl	$16, %edx
	popl	%eax
	movl	%eax, (%edx)
	.stabn  68,0,370,.LM1057	
.LM1057:
	# if: [:callm, [:callm, :pattern, :length], :>, [[:sexp, :__I1]]]
	# callm [:callm, :pattern, :length].:>
	subl	$28, %esp
	# callm :pattern.:length
	subl	$24, %esp
	# [:arg, 2, :ecx]
	movl	16(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__length(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm pattern.length END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____gt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :pattern, :length].> END
	cmpl	%eax, nil
	je	.L1769_else
	cmpl	%eax, false
	je	.L1769_else
	# then: [:do, [:callm, :STDERR, :puts, [[:sexp, [:call, :__get_string, :".L21"]]]], [:call, :exit, [[:callm, [:sexp, :__I1], :/, [[:sexp, :__I1]]]]]]
	.stabn  68,0,371,.LM1058	
.LM1058:
	# callm :STDERR.:puts
	subl	$28, %esp
	movl	STDERR, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	subl	$20, %esp
	movl	$.L21, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__puts(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm STDERR.puts END
	# callm :self.:exit
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	# callm [:sexp, :__I1].:/
	subl	$28, %esp
	movl	__I1, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____div(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:sexp, :__I1]./ END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	(%esi), %eax
	call	*__voff__exit(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.exit END
	# else: nil
.L1769_else:
	.stabn  68,0,373,.LM1059	
.LM1059:
	subl	$20, %esp
	movl	$.L0, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %edx
	addl	$8, %edx
	popl	%eax
	movl	%eax, (%edx)
	.stabn  68,0,375,.LM1060	
.LM1060:
	# callm [:callm, :pattern, :[], [[:sexp, :__I0]]].:ord
	subl	$24, %esp
	# callm :pattern.:[]
	subl	$28, %esp
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	__I0, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm pattern.[] END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__ord(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :pattern, :[], [[:sexp, :__I0]]].ord END
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	.stabn  68,0,376,.LM1061	
.LM1061:
	# callm :self.:each_byte
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	.stabn  68,0,377,.LM1062	
.LM1062:
	# Stack frame
	pushl	%ebp
	movl	-12(%ebp), %eax
	movl	%eax, %edx
	popl	%eax
	movl	%eax, (%edx)
	movl	$__lambda_L101, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	subl	$32, %esp
	movl	-16(%ebp), %eax
	movl	%eax, (%esp)
	movl	-12(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%esi, 8(%esp)
	movl	$1, 12(%esp)
	movl	$4, %ebx
	call	__new_proc
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__each_byte(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.each_byte END
	movl	-12(%ebp), %eax
	movl	%eax, %edi
	addl	$8, %edi
	movl	(%edi), %eax
	addl	$16, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_String_gsub, .-__method_String_gsub
.Lscope199:
	.stabs  "",36,0,0,.Lscope199-.LFBB199	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_String_split #########################	
		
	.stabs  "__method_String_split:F(0,0)",36,0,0,__method_String_split	
.globl __method_String_split
	.type	__method_String_split, @function
__method_String_split:
.LFBB200:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1773_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_String_split", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1772, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1773_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1775_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_String_split", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1772, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1775_else:
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for pat at position 4
	# [:sexp, [:call, :__get_string, :".L22"]]
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1777_else
	# then: [:assign, :"#pat", [:sexp, [:call, :__get_string, :".L22"]]]
	subl	$20, %esp
	movl	$.L22, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L1778_endif
	# else: [:assign, :"#pat", :pat]
.L1777_else:
	# [:arg, 2, :ecx]
	movl	16(%ebp), %ecx
	pushl	%ecx
	popl	%eax
	movl	%eax, -8(%ebp)
.L1778_endif:
	# METHOD BODY:
	.stabn  68,0,390,.LM1063	
.LM1063:
	subl	$16, %esp
	addl	$4, %ebx
	subl	$20, %esp
	movl	$20, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	# [:lvar, 0, :edx]
	movl	-8(%ebp), %edx
	pushl	%edx
	movl	-16(%ebp), %eax
	movl	%eax, %edi
	addl	$4, %edi
	popl	%eax
	movl	%eax, (%edi)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-16(%ebp), %eax
	movl	%eax, %ecx
	addl	$16, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	.stabn  68,0,391,.LM1064	
.LM1064:
	# callm :Array.:[]
	subl	$24, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm Array.[] END
	pushl	%eax
	movl	-16(%ebp), %eax
	movl	%eax, %edi
	addl	$8, %edi
	popl	%eax
	movl	%eax, (%edi)
	subl	$20, %esp
	movl	$.L0, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	movl	-16(%ebp), %eax
	movl	%eax, %ecx
	addl	$12, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	.stabn  68,0,392,.LM1065	
.LM1065:
	# callm :self.:each_byte
	subl	$24, %esp
	movl	%esi, (%esp)
	.stabn  68,0,393,.LM1066	
.LM1066:
	# Stack frame
	pushl	%ebp
	movl	-16(%ebp), %eax
	movl	%eax, %edx
	popl	%eax
	movl	%eax, (%edx)
	movl	$__lambda_L102, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	subl	$32, %esp
	movl	-20(%ebp), %eax
	movl	%eax, (%esp)
	movl	-16(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%esi, 8(%esp)
	movl	$1, 12(%esp)
	movl	$4, %ebx
	call	__new_proc
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__each_byte(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.each_byte END
	.stabn  68,0,403,.LM1067	
.LM1067:
	# if: [:callm, [:index, :__env__, 3], :!=, [[:sexp, [:call, :__get_string, :".L0"]]]]
	# callm [:index, :__env__, 3].:!=
	subl	$28, %esp
	movl	-16(%ebp), %eax
	movl	%eax, %edi
	addl	$12, %edi
	movl	(%edi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	subl	$20, %esp
	movl	$.L0, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____X__3d(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 3].!= END
	cmpl	%eax, nil
	je	.L1780_else
	cmpl	%eax, false
	je	.L1780_else
	# then: [:callm, [:index, :__env__, 2], :<<, [[:index, :__env__, 3]]]
	# callm [:index, :__env__, 2].:<<
	subl	$28, %esp
	movl	-16(%ebp), %eax
	movl	%eax, %ecx
	addl	$8, %ecx
	movl	(%ecx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	-16(%ebp), %eax
	movl	%eax, %edx
	addl	$12, %edx
	movl	(%edx), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt__lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 2].<< END
	# else: nil
.L1780_else:
	movl	-16(%ebp), %eax
	movl	%eax, %edi
	addl	$8, %edi
	movl	(%edi), %eax
	addl	$16, %esp
	addl	$4, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_String_split, .-__method_String_split
.Lscope200:
	.stabs  "",36,0,0,.Lscope200-.LFBB200	
		
	########################################################################	
		
		
		
		
		
		
		
	############################# __get_string #############################	
		
	.stabs  "__get_string:F(0,0)",36,0,0,__get_string	
.globl __get_string
	.type	__get_string, @function
__get_string:
.LFBB201:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# METHOD BODY:
	subl	$12, %esp
	addl	$3, %ebx
	# callm :String.:new
	subl	$24, %esp
	movl	String, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__new(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm String.new END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# callm :s.:__set_raw
	subl	$28, %esp
	movl	-12(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	8(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____set_raw(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm s.__set_raw END
	movl	-12(%ebp), %eax
	addl	$12, %esp
	# Reloading self if evicted:
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	leave	
	ret	
	.size	__get_string, .-__get_string
.Lscope201:
	.stabs  "",36,0,0,.Lscope201-.LFBB201	
		
	########################################################################	
		
		
		
		
		
		
		
	########################### __method__eql__Q ###########################	
		
	.stabs  "__method__eql__Q:F(0,0)",36,0,0,__method__eql__Q	
.globl __method__eql__Q
	.type	__method__eql__Q, @function
__method__eql__Q:
.LFBB202:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1784_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method__eql__Q", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1783, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1784_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1786_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method__eql__Q", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1783, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1786_else:
	# METHOD BODY:
	.stabn  68,0,5,.LM1068	
.LM1068:
	movl	false, %eax
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method__eql__Q, .-__method__eql__Q
.Lscope202:
	.stabs  "",36,0,0,.Lscope202-.LFBB202	
		
	########################################################################	
		
		
		
		
		
		
		
	####################### __method_Hash_initialize #######################	
		
	.stabs  "__method_Hash_initialize:F(0,0)",36,0,0,__method_Hash_initialize	
.globl __method_Hash_initialize
	.type	__method_Hash_initialize, @function
__method_Hash_initialize:
.LFBB203:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1789_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Hash_initialize", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1788, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1789_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1791_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Hash_initialize", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1788, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1791_else:
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for defval at position 4
	# :nil
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1793_else
	# then: [:assign, :"#defval", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L1794_endif
	# else: [:assign, :"#defval", :defval]
.L1793_else:
	movl	16(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L1794_endif:
	# METHOD BODY:
	.stabn  68,0,10,.LM1069	
.LM1069:
	.stabn  68,0,11,.LM1070	
.LM1070:
	movl	__I0, %eax
	pushl	%eax
	popl	%eax
	pushl	%eax
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ecx
	movl	%ecx, 4(%esi)
	movl	__I4, %eax
	pushl	%eax
	popl	%eax
	pushl	%eax
	popl	%edx
	movl	%edx, 8(%esi)
	# callm :self.:_alloc_data
	subl	$24, %esp
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff___alloc_data(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self._alloc_data END
	.stabn  68,0,13,.LM1071	
.LM1071:
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	pushl	%eax
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%edi
	movl	%edi, 12(%esi)
	.stabn  68,0,14,.LM1072	
.LM1072:
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	pushl	%eax
	popl	%ecx
	movl	%ecx, 16(%esi)
	.stabn  68,0,15,.LM1073	
.LM1073:
	movl	-8(%ebp), %eax
	pushl	%eax
	popl	%eax
	pushl	%eax
	popl	%edx
	movl	%edx, 20(%esi)
	addl	$4, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Hash_initialize, .-__method_Hash_initialize
.Lscope203:
	.stabs  "",36,0,0,.Lscope203-.LFBB203	
		
	########################################################################	
		
		
		
		
		
		
		
	########################## __method____NDX__1 ##########################	
		
	.stabs  "__method____NDX__1:F(0,0)",36,0,0,__method____NDX__1	
.globl __method____NDX__1
	.type	__method____NDX__1, @function
__method____NDX__1:
.LFBB204:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1796_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method____NDX__1", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1795, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1796_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1798_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method____NDX__1", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1795, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1798_else:
	# METHOD BODY:
	.stabn  68,0,22,.LM1074	
.LM1074:
	.stabn  68,0,23,.LM1075	
.LM1075:
	# callm :Hash.:new
	subl	$24, %esp
	movl	Hash, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__new(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm Hash.new END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method____NDX__1, .-__method____NDX__1
.Lscope204:
	.stabs  "",36,0,0,.Lscope204-.LFBB204	
		
	########################################################################	
		
		
		
		
		
		
		
	###################### __method_Hash__alloc_data #######################	
		
	.stabs  "__method_Hash__alloc_data:F(0,0)",36,0,0,__method_Hash__alloc_data	
.globl __method_Hash__alloc_data
	.type	__method_Hash__alloc_data, @function
__method_Hash__alloc_data:
.LFBB205:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1801_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Hash__alloc_data", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1800, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1801_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1803_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Hash__alloc_data", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1800, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1803_else:
	# METHOD BODY:
	.stabn  68,0,26,.LM1076	
.LM1076:
	.stabn  68,0,28,.LM1077	
.LM1077:
	# callm :Array.:new
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :@capacity.:*
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	8(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I4, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____mul(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @capacity.* END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__new(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm Array.new END
	pushl	%eax
	popl	%eax
	pushl	%eax
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%edi
	movl	%edi, 24(%esi)
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Hash__alloc_data, .-__method_Hash__alloc_data
.Lscope205:
	.stabs  "",36,0,0,.Lscope205-.LFBB205	
		
	########################################################################	
		
		
		
		
		
		
		
	###################### __method_Hash__bulkinsert #######################	
		
	.stabs  "__method_Hash__bulkinsert:F(0,0)",36,0,0,__method_Hash__bulkinsert	
.globl __method_Hash__bulkinsert
	.type	__method_Hash__bulkinsert, @function
__method_Hash__bulkinsert:
.LFBB206:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$4, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1806_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Hash__bulkinsert", 2, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1805, %eax
	movl	%eax, 4(%esp)
	movl	$2, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1806_else:
	# if: [:gt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$4, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1808_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Hash__bulkinsert", 2, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1805, %eax
	movl	%eax, 4(%esp)
	movl	$2, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1808_else:
	# METHOD BODY:
	.stabn  68,0,32,.LM1078	
.LM1078:
	subl	$20, %esp
	addl	$5, %ebx
	.stabn  68,0,33,.LM1079	
.LM1079:
	movl	__I0, %eax
	pushl	%eax
	popl	%eax
	pushl	%eax
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%edi
	movl	%edi, 4(%esi)
	# [:arg, 3, :ecx]
	movl	20(%ebp), %ecx
	pushl	%ecx
	popl	%eax
	movl	%eax, -12(%ebp)
	.stabn  68,0,34,.LM1080	
.LM1080:
.L1811:
	# [:lvar, 1, :edx]
	movl	-12(%ebp), %edx
	movl	%edx, %eax
	cmpl	%eax, nil
	je	.L1810
	cmpl	%eax, false
	je	.L1810
	.stabn  68,0,35,.LM1081	
.LM1081:
	# callm :data.:[]
	subl	$28, %esp
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm data.[] END
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	.stabn  68,0,36,.LM1082	
.LM1082:
	# if: :k
	# [:lvar, 2, :edx]
	movl	-16(%ebp), %edx
	movl	%edx, %eax
	cmpl	%eax, nil
	je	.L1812_else
	cmpl	%eax, false
	je	.L1812_else
	# then: [:do, [:assign, :v, [:callm, :data, :[], [[:callm, :cur, :+, [[:sexp, :__I1]]]]]], [:callm, :self, :[]=, [:k, :v]]]
	.stabn  68,0,39,.LM1083	
.LM1083:
	# callm :data.:[]
	subl	$28, %esp
	# [:arg, 2, :ecx]
	movl	16(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	# callm :cur.:+
	subl	$28, %esp
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm cur.+ END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm data.[] END
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	# callm :self.:[]=
	subl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 2, :edx]
	movl	-16(%ebp), %edx
	movl	%edx, 8(%esp)
	# [:lvar, 3, :ecx]
	movl	-20(%ebp), %ecx
	movl	%ecx, 12(%esp)
	movl	$4, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____NDX__3d(%eax)
	# Evicting self
	# Static adj: 32
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.[]= END
	# else: nil
.L1812_else:
	.stabn  68,0,41,.LM1084	
.LM1084:
	# callm :data.:[]
	subl	$28, %esp
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	# callm :cur.:+
	subl	$28, %esp
	# [:lvar, 1, :edx]
	movl	-12(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	__I2, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm cur.+ END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm data.[] END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	jmp	.L1811
.L1810:
	movl	nil, %eax
	movl	nil, %eax
	addl	$20, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Hash__bulkinsert, .-__method_Hash__bulkinsert
.Lscope206:
	.stabs  "",36,0,0,.Lscope206-.LFBB206	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Hash__grow ##########################	
		
	.stabs  "__method_Hash__grow:F(0,0)",36,0,0,__method_Hash__grow	
.globl __method_Hash__grow
	.type	__method_Hash__grow, @function
__method_Hash__grow:
.LFBB207:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1815_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Hash__grow", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1814, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1815_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1817_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Hash__grow", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1814, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1817_else:
	# METHOD BODY:
	.stabn  68,0,47,.LM1085	
.LM1085:
	subl	$20, %esp
	addl	$5, %ebx
	.stabn  68,0,50,.LM1086	
.LM1086:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	8(%esi), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	movl	24(%esi), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	.stabn  68,0,51,.LM1087	
.LM1087:
	movl	12(%esi), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	.stabn  68,0,52,.LM1088	
.LM1088:
	# callm :@capacity.:*
	subl	$28, %esp
	movl	8(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I2, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____mul(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @capacity.* END
	pushl	%eax
	popl	%eax
	pushl	%eax
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ecx
	movl	%ecx, 8(%esi)
	# callm :self.:_alloc_data
	subl	$24, %esp
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff___alloc_data(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self._alloc_data END
	.stabn  68,0,56,.LM1089	
.LM1089:
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	pushl	%eax
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%edi
	movl	%edi, 12(%esi)
	.stabn  68,0,59,.LM1090	
.LM1090:
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	pushl	%eax
	popl	%edx
	movl	%edx, 16(%esi)
	.stabn  68,0,60,.LM1091	
.LM1091:
	# callm :self.:_bulkinsert
	subl	$32, %esp
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 2, :ecx]
	movl	-16(%ebp), %ecx
	movl	%ecx, 8(%esp)
	# [:lvar, 3, :edi]
	movl	-20(%ebp), %edi
	movl	%edi, 12(%esp)
	movl	$4, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff___bulkinsert(%eax)
	# Evicting self
	# Static adj: 32
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self._bulkinsert END
	addl	$20, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Hash__grow, .-__method_Hash__grow
.Lscope207:
	.stabs  "",36,0,0,.Lscope207-.LFBB207	
		
	########################################################################	
		
		
		
		
		
		
		
	####################### __method_Hash__find_slot #######################	
		
	.stabs  "__method_Hash__find_slot:F(0,0)",36,0,0,__method_Hash__find_slot	
.globl __method_Hash__find_slot
	.type	__method_Hash__find_slot, @function
__method_Hash__find_slot:
.LFBB208:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$3, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1820_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Hash__find_slot", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1819, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1820_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1822_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Hash__find_slot", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1819, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1822_else:
	# METHOD BODY:
	.stabn  68,0,68,.LM1092	
.LM1092:
	subl	$20, %esp
	addl	$5, %ebx
	.stabn  68,0,69,.LM1093	
.LM1093:
	# callm [:callm, [:callm, :key, :hash], :%, [:@capacity]].:*
	subl	$28, %esp
	# callm [:callm, :key, :hash].:%
	subl	$28, %esp
	# callm :key.:hash
	subl	$24, %esp
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__hash(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm key.hash END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	8(%esi), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____25(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :key, :hash].% END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I4, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____mul(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:callm, :key, :hash], :%, [:@capacity]].* END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# callm :@capacity.:*
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	8(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I4, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____mul(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @capacity.* END
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	.stabn  68,0,70,.LM1094	
.LM1094:
.L1825:
	# if: [:assign, :d, [:callm, :@data, :[], [:pos]]]
	# callm :@data.:[]
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	24(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @data.[] END
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	cmpl	%eax, nil
	je	.L1826_else
	cmpl	%eax, false
	je	.L1826_else
	# then: [:callm, [:callm, :key, :eql?, [:d]], :!]
	# callm [:callm, :key, :eql?, [:d]].:!
	subl	$24, %esp
	# callm :key.:eql?
	subl	$28, %esp
	# [:arg, 2, :edx]
	movl	16(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 3, :edi]
	movl	-20(%ebp), %edi
	movl	%edi, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__eql__Q(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm key.eql? END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____X(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :key, :eql?, [:d]].! END
	# else: nil
.L1826_else:
	cmpl	%eax, nil
	je	.L1824
	cmpl	%eax, false
	je	.L1824
	.stabn  68,0,77,.LM1095	
.LM1095:
	# callm :pos.:+
	subl	$28, %esp
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	# callm [:sexp, :__I4].:%
	subl	$28, %esp
	movl	__I4, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 2, :edx]
	movl	-16(%ebp), %edx
	movl	%edx, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____25(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:sexp, :__I4].% END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm pos.+ END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	jmp	.L1825
.L1824:
	movl	nil, %eax
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, %eax
	addl	$20, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Hash__find_slot, .-__method_Hash__find_slot
.Lscope208:
	.stabs  "",36,0,0,.Lscope208-.LFBB208	
		
	########################################################################	
		
		
		
		
		
		
		
	####################### __method_Hash_member__Q ########################	
		
	.stabs  "__method_Hash_member__Q:F(0,0)",36,0,0,__method_Hash_member__Q	
.globl __method_Hash_member__Q
	.type	__method_Hash_member__Q, @function
__method_Hash_member__Q:
.LFBB209:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1829_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Hash_member__Q", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1828, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1829_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1831_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Hash_member__Q", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1828, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1831_else:
	# METHOD BODY:
	.stabn  68,0,83,.LM1096	
.LM1096:
	subl	$12, %esp
	addl	$3, %ebx
	.stabn  68,0,84,.LM1097	
.LM1097:
	# callm :self.:_find_slot
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	movl	%edi, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff___find_slot(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self._find_slot END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# if: [:callm, :@data, :[], [:pos]]
	# callm :@data.:[]
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	24(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @data.[] END
	cmpl	%eax, nil
	je	.L1833_else
	cmpl	%eax, false
	je	.L1833_else
	# then: :true
	movl	true, %eax
	jmp	.L1834_endif
	# else: :false
.L1833_else:
	movl	false, %eax
.L1834_endif:
	addl	$12, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Hash_member__Q, .-__method_Hash_member__Q
.Lscope209:
	.stabs  "",36,0,0,.Lscope209-.LFBB209	
		
	########################################################################	
		
		
		
		
		
		
		
	####################### __method_Hash_include__Q #######################	
		
	.stabs  "__method_Hash_include__Q:F(0,0)",36,0,0,__method_Hash_include__Q	
.globl __method_Hash_include__Q
	.type	__method_Hash_include__Q, @function
__method_Hash_include__Q:
.LFBB210:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$3, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1836_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Hash_include__Q", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1835, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1836_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1838_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Hash_include__Q", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1835, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1838_else:
	# METHOD BODY:
	.stabn  68,0,88,.LM1098	
.LM1098:
	.stabn  68,0,89,.LM1099	
.LM1099:
	# callm :self.:member?
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__member__Q(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.member? END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Hash_include__Q, .-__method_Hash_include__Q
.Lscope210:
	.stabs  "",36,0,0,.Lscope210-.LFBB210	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Hash_empty__Q ########################	
		
	.stabs  "__method_Hash_empty__Q:F(0,0)",36,0,0,__method_Hash_empty__Q	
.globl __method_Hash_empty__Q
	.type	__method_Hash_empty__Q, @function
__method_Hash_empty__Q:
.LFBB211:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1841_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Hash_empty__Q", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1840, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1841_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1843_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Hash_empty__Q", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1840, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1843_else:
	# METHOD BODY:
	.stabn  68,0,92,.LM1100	
.LM1100:
	.stabn  68,0,93,.LM1101	
.LM1101:
	# callm :@length.:==
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I0, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @length.== END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Hash_empty__Q, .-__method_Hash_empty__Q
.Lscope211:
	.stabs  "",36,0,0,.Lscope211-.LFBB211	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Hash___NDX ##########################	
		
	.stabs  "__method_Hash___NDX:F(0,0)",36,0,0,__method_Hash___NDX	
.globl __method_Hash___NDX
	.type	__method_Hash___NDX, @function
__method_Hash___NDX:
.LFBB212:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1846_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Hash___NDX", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1845, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1846_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1848_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Hash___NDX", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1845, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1848_else:
	# METHOD BODY:
	.stabn  68,0,96,.LM1102	
.LM1102:
	subl	$12, %esp
	addl	$3, %ebx
	.stabn  68,0,97,.LM1103	
.LM1103:
	# callm :self.:_find_slot
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	# [:arg, 2, :ecx]
	movl	16(%ebp), %ecx
	movl	%ecx, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff___find_slot(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self._find_slot END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# if: [:callm, :@data, :[], [:pos]]
	# callm :@data.:[]
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	24(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @data.[] END
	cmpl	%eax, nil
	je	.L1850_else
	cmpl	%eax, false
	je	.L1850_else
	# then: [:callm, :@data, :[], [[:callm, :pos, :+, [[:sexp, :__I1]]]]]
	# callm :@data.:[]
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	24(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :pos.:+
	subl	$28, %esp
	# [:lvar, 1, :edx]
	movl	-12(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm pos.+ END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @data.[] END
	jmp	.L1851_endif
	# else: :@defval
.L1850_else:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	20(%esi), %eax
.L1851_endif:
	addl	$12, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Hash___NDX, .-__method_Hash___NDX
.Lscope212:
	.stabs  "",36,0,0,.Lscope212-.LFBB212	
		
	########################################################################	
		
		
		
		
		
		
		
	#################### __method_Hash_capacity_too_low ####################	
		
	.stabs  "__method_Hash_capacity_too_low:F(0,0)",36,0,0,__method_Hash_capacity_too_low	
.globl __method_Hash_capacity_too_low
	.type	__method_Hash_capacity_too_low, @function
__method_Hash_capacity_too_low:
.LFBB213:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1853_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Hash_capacity_too_low", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1852, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1853_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1855_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Hash_capacity_too_low", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1852, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1855_else:
	# METHOD BODY:
	.stabn  68,0,101,.LM1104	
.LM1104:
	.stabn  68,0,104,.LM1105	
.LM1105:
	# callm :self.:puts
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	subl	$20, %esp
	movl	$.L23, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__puts(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.puts END
	# callm :self.:exit
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__exit(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.exit END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Hash_capacity_too_low, .-__method_Hash_capacity_too_low
.Lscope213:
	.stabs  "",36,0,0,.Lscope213-.LFBB213	
		
	########################################################################	
		
		
		
		
		
		
		
	####################### __method_Hash___NDX__3d ########################	
		
	.stabs  "__method_Hash___NDX__3d:F(0,0)",36,0,0,__method_Hash___NDX__3d	
.globl __method_Hash___NDX__3d
	.type	__method_Hash___NDX__3d, @function
__method_Hash___NDX__3d:
.LFBB214:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$4, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1858_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Hash___NDX__3d", 2, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1857, %eax
	movl	%eax, 4(%esp)
	movl	$2, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1858_else:
	# if: [:gt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$4, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1860_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Hash___NDX__3d", 2, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1857, %eax
	movl	%eax, 4(%esp)
	movl	$2, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1860_else:
	# METHOD BODY:
	.stabn  68,0,108,.LM1106	
.LM1106:
	subl	$20, %esp
	addl	$5, %ebx
	.stabn  68,0,109,.LM1107	
.LM1107:
	# callm [:callm, :@capacity, :*, [[:sexp, :__I3]]].:/
	subl	$28, %esp
	# callm :@capacity.:*
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	8(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I3, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____mul(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @capacity.* END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I4, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____div(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :@capacity, :*, [[:sexp, :__I3]]]./ END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# if: [:callm, :limit, :<=, [:@length]]
	# callm :limit.:<=
	subl	$28, %esp
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____le(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm limit.<= END
	cmpl	%eax, nil
	je	.L1862_else
	cmpl	%eax, false
	je	.L1862_else
	# then: :_grow
	# callm :self.:_grow
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff___grow(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self._grow END
	# else: nil
.L1862_else:
	.stabn  68,0,111,.LM1108	
.LM1108:
	# if: [:callm, :@capacity, :<=, [:@length]]
	# callm :@capacity.:<=
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	8(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	4(%esi), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____le(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @capacity.<= END
	cmpl	%eax, nil
	je	.L1864_else
	cmpl	%eax, false
	je	.L1864_else
	# then: :capacity_too_low
	# callm :self.:capacity_too_low
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__capacity_too_low(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.capacity_too_low END
	# else: nil
.L1864_else:
	.stabn  68,0,113,.LM1109	
.LM1109:
	# callm :self.:_find_slot
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	movl	%edi, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff___find_slot(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self._find_slot END
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	.stabn  68,0,115,.LM1110	
.LM1110:
	# callm [:callm, :@data, :[], [:slot]].:nil?
	subl	$24, %esp
	# callm :@data.:[]
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	24(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 2, :edx]
	movl	-16(%ebp), %edx
	movl	%edx, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @data.[] END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__nil__Q(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :@data, :[], [:slot]].nil? END
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	.stabn  68,0,116,.LM1111	
.LM1111:
	# if: :new
	# [:lvar, 3, :ecx]
	movl	-20(%ebp), %ecx
	movl	%ecx, %eax
	cmpl	%eax, nil
	je	.L1866_else
	cmpl	%eax, false
	je	.L1866_else
	# then: [:do, [:assign, :@length, [:callm, :@length, :+, [[:sexp, :__I1]]]]]
	.stabn  68,0,118,.LM1112	
.LM1112:
	# callm :@length.:+
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @length.+ END
	pushl	%eax
	popl	%eax
	pushl	%eax
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%edi
	movl	%edi, 4(%esi)
	# else: nil
.L1866_else:
	.stabn  68,0,119,.LM1113	
.LM1113:
	# callm :@data.:[]=
	subl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	24(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :slot.:+
	subl	$28, %esp
	# [:lvar, 2, :edx]
	movl	-16(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm slot.+ END
	movl	%eax, 8(%esp)
	# [:arg, 3, :ecx]
	movl	20(%ebp), %ecx
	movl	%ecx, 12(%esp)
	movl	$4, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX__3d(%eax)
	# Evicting self
	# Static adj: 32
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @data.[]= END
	.stabn  68,0,121,.LM1114	
.LM1114:
	# if: [:callm, :new, :!]
	# callm :new.:!
	subl	$24, %esp
	# [:lvar, 3, :edi]
	movl	-20(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____X(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm new.! END
	cmpl	%eax, nil
	je	.L1868_else
	cmpl	%eax, false
	je	.L1868_else
	# then: [:return]
	movl	nil, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L1868_else:
	.stabn  68,0,122,.LM1115	
.LM1115:
	# callm :@data.:[]=
	subl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	24(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 2, :edx]
	movl	-16(%ebp), %edx
	movl	%edx, 8(%esp)
	# [:arg, 2, :ecx]
	movl	16(%ebp), %ecx
	movl	%ecx, 12(%esp)
	movl	$4, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX__3d(%eax)
	# Evicting self
	# Static adj: 32
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @data.[]= END
	.stabn  68,0,124,.LM1116	
.LM1116:
	# if: :@last
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	16(%esi), %eax
	cmpl	%eax, nil
	je	.L1870_else
	cmpl	%eax, false
	je	.L1870_else
	# then: [:do, [:callm, :@data, :[]=, [[:callm, :@last, :+, [[:sexp, :__I2]]], :slot]]]
	.stabn  68,0,127,.LM1117	
.LM1117:
	# callm :@data.:[]=
	subl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	24(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :@last.:+
	subl	$28, %esp
	movl	16(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I2, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @last.+ END
	movl	%eax, 8(%esp)
	# [:lvar, 2, :edi]
	movl	-16(%ebp), %edi
	movl	%edi, 12(%esp)
	movl	$4, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX__3d(%eax)
	# Evicting self
	# Static adj: 32
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @data.[]= END
	# else: nil
.L1870_else:
	.stabn  68,0,128,.LM1118	
.LM1118:
	# if: [:callm, :@first, :nil?]
	# callm :@first.:nil?
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	12(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__nil__Q(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @first.nil? END
	cmpl	%eax, nil
	je	.L1872_else
	cmpl	%eax, false
	je	.L1872_else
	# then: [:do, [:assign, :@first, :slot]]
	.stabn  68,0,130,.LM1119	
.LM1119:
	# [:lvar, 2, :edx]
	movl	-16(%ebp), %edx
	pushl	%edx
	popl	%edx
	pushl	%edx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ecx
	movl	%ecx, 12(%esi)
	# else: nil
.L1872_else:
	.stabn  68,0,131,.LM1120	
.LM1120:
	# callm :@data.:[]=
	subl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	24(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :slot.:+
	subl	$28, %esp
	# [:lvar, 2, :edi]
	movl	-16(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	__I2, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm slot.+ END
	movl	%eax, 8(%esp)
	movl	nil, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX__3d(%eax)
	# Evicting self
	# Static adj: 32
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @data.[]= END
	.stabn  68,0,132,.LM1121	
.LM1121:
	# callm :@data.:[]=
	subl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	24(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :slot.:+
	subl	$28, %esp
	# [:lvar, 2, :ecx]
	movl	-16(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	__I3, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm slot.+ END
	movl	%eax, 8(%esp)
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	16(%esi), %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX__3d(%eax)
	# Evicting self
	# Static adj: 32
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @data.[]= END
	.stabn  68,0,133,.LM1122	
.LM1122:
	# [:lvar, 2, :edx]
	movl	-16(%ebp), %edx
	pushl	%edx
	popl	%edx
	pushl	%edx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%edi
	movl	%edi, 16(%esi)
	movl	nil, %eax
	addl	$20, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Hash___NDX__3d, .-__method_Hash___NDX__3d
.Lscope214:
	.stabs  "",36,0,0,.Lscope214-.LFBB214	
		
	########################################################################	
		
		
		
		
		
		
		
	##################### __method_Hash___delete_first #####################	
		
	.stabs  "__method_Hash___delete_first:F(0,0)",36,0,0,__method_Hash___delete_first	
.globl __method_Hash___delete_first
	.type	__method_Hash___delete_first, @function
__method_Hash___delete_first:
.LFBB215:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1875_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Hash___delete_first", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1874, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1875_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1877_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Hash___delete_first", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1874, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1877_else:
	# METHOD BODY:
	.stabn  68,0,139,.LM1123	
.LM1123:
	subl	$12, %esp
	addl	$3, %ebx
	.stabn  68,0,140,.LM1124	
.LM1124:
	# if: [:callm, :@first, :!]
	# callm :@first.:!
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	12(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____X(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @first.! END
	cmpl	%eax, nil
	je	.L1879_else
	cmpl	%eax, false
	je	.L1879_else
	# then: [:return]
	movl	nil, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L1879_else:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	12(%esi), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	.stabn  68,0,141,.LM1125	
.LM1125:
	# callm :@data.:[]
	subl	$28, %esp
	movl	24(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :@first.:+
	subl	$28, %esp
	movl	12(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I2, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @first.+ END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @data.[] END
	pushl	%eax
	popl	%eax
	pushl	%eax
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ecx
	movl	%ecx, 12(%esi)
	.stabn  68,0,142,.LM1126	
.LM1126:
	# if: [:callm, :old, :==, [:@last]]
	# callm :old.:==
	subl	$28, %esp
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	16(%esi), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm old.== END
	cmpl	%eax, nil
	je	.L1881_else
	cmpl	%eax, false
	je	.L1881_else
	# then: [:do, [:assign, :@last, :@first]]
	.stabn  68,0,144,.LM1127	
.LM1127:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	12(%esi), %eax
	pushl	%eax
	popl	%eax
	pushl	%eax
	popl	%edx
	movl	%edx, 16(%esi)
	# else: nil
.L1881_else:
	.stabn  68,0,145,.LM1128	
.LM1128:
	# callm :@data.:[]=
	subl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	24(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, 8(%esp)
	movl	nil, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX__3d(%eax)
	# Evicting self
	# Static adj: 32
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @data.[]= END
	.stabn  68,0,146,.LM1129	
.LM1129:
	# callm :@data.:[]=
	subl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	24(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :old.:+
	subl	$28, %esp
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm old.+ END
	movl	%eax, 8(%esp)
	movl	nil, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX__3d(%eax)
	# Evicting self
	# Static adj: 32
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @data.[]= END
	.stabn  68,0,147,.LM1130	
.LM1130:
	# callm :@data.:[]=
	subl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	24(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :old.:+
	subl	$28, %esp
	# [:lvar, 1, :edx]
	movl	-12(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	__I2, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm old.+ END
	movl	%eax, 8(%esp)
	movl	nil, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX__3d(%eax)
	# Evicting self
	# Static adj: 32
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @data.[]= END
	.stabn  68,0,148,.LM1131	
.LM1131:
	# callm :@data.:[]=
	subl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	24(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :old.:+
	subl	$28, %esp
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	__I3, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm old.+ END
	movl	%eax, 8(%esp)
	movl	nil, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX__3d(%eax)
	# Evicting self
	# Static adj: 32
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @data.[]= END
	.stabn  68,0,149,.LM1132	
.LM1132:
	# callm :@length.:-
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____minus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @length.- END
	pushl	%eax
	popl	%eax
	pushl	%eax
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%edi
	movl	%edi, 4(%esi)
	addl	$12, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Hash___delete_first, .-__method_Hash___delete_first
.Lscope215:
	.stabs  "",36,0,0,.Lscope215-.LFBB215	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Hash_shift ##########################	
		
	.stabs  "__method_Hash_shift:F(0,0)",36,0,0,__method_Hash_shift	
.globl __method_Hash_shift
	.type	__method_Hash_shift, @function
__method_Hash_shift:
.LFBB216:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1884_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Hash_shift", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1883, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1884_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1886_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Hash_shift", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1883, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1886_else:
	# METHOD BODY:
	.stabn  68,0,153,.LM1133	
.LM1133:
	subl	$20, %esp
	addl	$5, %ebx
	.stabn  68,0,154,.LM1134	
.LM1134:
	# if: [:callm, :@first, :!]
	# callm :@first.:!
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	12(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____X(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @first.! END
	cmpl	%eax, nil
	je	.L1888_else
	cmpl	%eax, false
	je	.L1888_else
	# then: [:return, :nil]
	movl	nil, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L1888_else:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	12(%esi), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	.stabn  68,0,156,.LM1135	
.LM1135:
	# callm :@data.:[]
	subl	$28, %esp
	movl	24(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @data.[] END
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	.stabn  68,0,157,.LM1136	
.LM1136:
	# callm :@data.:[]
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	24(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :slot.:+
	subl	$28, %esp
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm slot.+ END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @data.[] END
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	# callm :self.:__delete_first
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____delete_first(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.__delete_first END
	.stabn  68,0,160,.LM1137	
.LM1137:
	# callm :Array.:[]
	subl	$32, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 2, :edx]
	movl	-16(%ebp), %edx
	movl	%edx, 8(%esp)
	# [:lvar, 3, :edi]
	movl	-20(%ebp), %edi
	movl	%edi, 12(%esp)
	movl	$4, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 32
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm Array.[] END
	addl	$20, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Hash_shift, .-__method_Hash_shift
.Lscope216:
	.stabs  "",36,0,0,.Lscope216-.LFBB216	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Hash_length #########################	
		
	.stabs  "__method_Hash_length:F(0,0)",36,0,0,__method_Hash_length	
.globl __method_Hash_length
	.type	__method_Hash_length, @function
__method_Hash_length:
.LFBB217:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1891_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Hash_length", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1890, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1891_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1893_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Hash_length", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1890, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1893_else:
	# METHOD BODY:
	.stabn  68,0,164,.LM1138	
.LM1138:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Hash_length, .-__method_Hash_length
.Lscope217:
	.stabs  "",36,0,0,.Lscope217-.LFBB217	
		
	########################################################################	
		
		
		
		
		
		
		
	########################## __method_Hash_size ##########################	
		
	.stabs  "__method_Hash_size:F(0,0)",36,0,0,__method_Hash_size	
.globl __method_Hash_size
	.type	__method_Hash_size, @function
__method_Hash_size:
.LFBB218:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1896_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Hash_size", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1895, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1896_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1898_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Hash_size", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1895, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1898_else:
	# METHOD BODY:
	.stabn  68,0,168,.LM1139	
.LM1139:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Hash_size, .-__method_Hash_size
.Lscope218:
	.stabs  "",36,0,0,.Lscope218-.LFBB218	
		
	########################################################################	
		
		
		
		
		
		
		
	########################## __method_Hash_to_a ##########################	
		
	.stabs  "__method_Hash_to_a:F(0,0)",36,0,0,__method_Hash_to_a	
.globl __method_Hash_to_a
	.type	__method_Hash_to_a, @function
__method_Hash_to_a:
.LFBB219:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1901_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Hash_to_a", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1900, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1901_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1903_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Hash_to_a", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1900, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1903_else:
	# METHOD BODY:
	.stabn  68,0,172,.LM1140	
.LM1140:
	subl	$16, %esp
	addl	$4, %ebx
	subl	$20, %esp
	movl	$12, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %edi
	addl	$8, %edi
	popl	%eax
	movl	%eax, (%edi)
	.stabn  68,0,173,.LM1141	
.LM1141:
	# callm :Array.:[]
	subl	$24, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm Array.[] END
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	# callm :self.:each
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	.stabn  68,0,174,.LM1142	
.LM1142:
	# Stack frame
	pushl	%ebp
	movl	-12(%ebp), %eax
	movl	%eax, %edx
	popl	%eax
	movl	%eax, (%edx)
	movl	$__lambda_L103, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	subl	$32, %esp
	movl	-16(%ebp), %eax
	movl	%eax, (%esp)
	movl	-12(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%esi, 8(%esp)
	movl	$2, 12(%esp)
	movl	$4, %ebx
	call	__new_proc
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__each(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.each END
	movl	-12(%ebp), %eax
	movl	%eax, %edi
	addl	$4, %edi
	movl	(%edi), %eax
	addl	$16, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Hash_to_a, .-__method_Hash_to_a
.Lscope219:
	.stabs  "",36,0,0,.Lscope219-.LFBB219	
		
	########################################################################	
		
		
		
		
		
		
		
	########################## __method_Hash_each ##########################	
		
	.stabs  "__method_Hash_each:F(0,0)",36,0,0,__method_Hash_each	
.globl __method_Hash_each
	.type	__method_Hash_each, @function
__method_Hash_each:
.LFBB220:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1907_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Hash_each", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1906, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1907_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1909_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Hash_each", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1906, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1909_else:
	# METHOD BODY:
	.stabn  68,0,180,.LM1143	
.LM1143:
	subl	$36, %esp
	addl	$9, %ebx
	subl	$20, %esp
	movl	$8, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -32(%ebp)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-32(%ebp), %eax
	movl	%eax, %edi
	addl	$4, %edi
	popl	%eax
	movl	%eax, (%edi)
	.stabn  68,0,181,.LM1144	
.LM1144:
	movl	__I0, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# callm :@capacity.:*
	subl	$28, %esp
	movl	8(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I2, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____mul(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @capacity.* END
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	.stabn  68,0,182,.LM1145	
.LM1145:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	12(%esi), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	.stabn  68,0,183,.LM1146	
.LM1146:
.L1912:
	# [:lvar, 3, :ecx]
	movl	-20(%ebp), %ecx
	movl	%ecx, %eax
	cmpl	%eax, nil
	je	.L1911
	cmpl	%eax, false
	je	.L1911
	.stabn  68,0,184,.LM1147	
.LM1147:
	# if: [:and, [:assign, :key, [:callm, :@data, :[], [:slot]]], [:callm, :Deleted, :!=, [:key]]]
	# if: [:assign, :key, [:callm, :@data, :[], [:slot]]]
	# callm :@data.:[]
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	24(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 3, :edx]
	movl	-20(%ebp), %edx
	movl	%edx, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @data.[] END
	pushl	%eax
	popl	%eax
	movl	%eax, -24(%ebp)
	cmpl	%eax, nil
	je	.L1913_else
	cmpl	%eax, false
	je	.L1913_else
	# then: [:callm, :Deleted, :!=, [:key]]
	# callm :Deleted.:!=
	subl	$28, %esp
	movl	Hash__Deleted, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 4, :edi]
	movl	-24(%ebp), %edi
	movl	%edi, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____X__3d(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm Deleted.!= END
	# else: nil
.L1913_else:
	cmpl	%eax, nil
	je	.L1915_else
	cmpl	%eax, false
	je	.L1915_else
	# then: [:do, [:assign, :value, [:callm, :@data, :[], [[:callm, :slot, :+, [[:sexp, :__I1]]]]]], [:callm, [:index, :__env__, 1], :call, [:key, :value]]]
	.stabn  68,0,186,.LM1148	
.LM1148:
	# callm :@data.:[]
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	24(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :slot.:+
	subl	$28, %esp
	# [:lvar, 3, :ecx]
	movl	-20(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm slot.+ END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @data.[] END
	pushl	%eax
	popl	%eax
	movl	%eax, -28(%ebp)
	# callm [:index, :__env__, 1].:call
	subl	$32, %esp
	movl	-32(%ebp), %eax
	movl	%eax, %edx
	addl	$4, %edx
	movl	(%edx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 4, :edi]
	movl	-24(%ebp), %edi
	movl	%edi, 8(%esp)
	# [:lvar, 5, :ecx]
	movl	-28(%ebp), %ecx
	movl	%ecx, 12(%esp)
	movl	$4, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__call(%eax)
	# Evicting self
	# Static adj: 32
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].call END
	# else: nil
.L1915_else:
	.stabn  68,0,188,.LM1149	
.LM1149:
	# callm :@data.:[]
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	24(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :slot.:+
	subl	$28, %esp
	# [:lvar, 3, :edx]
	movl	-20(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	__I2, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm slot.+ END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @data.[] END
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	jmp	.L1912
.L1911:
	movl	nil, %eax
	addl	$36, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Hash_each, .-__method_Hash_each
.Lscope220:
	.stabs  "",36,0,0,.Lscope220-.LFBB220	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Hash_delete #########################	
		
	.stabs  "__method_Hash_delete:F(0,0)",36,0,0,__method_Hash_delete	
.globl __method_Hash_delete
	.type	__method_Hash_delete, @function
__method_Hash_delete:
.LFBB221:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1918_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Hash_delete", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1917, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1918_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1920_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Hash_delete", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1917, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1920_else:
	# METHOD BODY:
	.stabn  68,0,209,.LM1150	
.LM1150:
	subl	$16, %esp
	addl	$4, %ebx
	.stabn  68,0,210,.LM1151	
.LM1151:
	# callm :self.:_find_slot
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	# [:arg, 2, :ecx]
	movl	16(%ebp), %ecx
	movl	%ecx, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff___find_slot(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self._find_slot END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# if: [:callm, [:callm, :@data, :[], [:slot]], :!]
	# callm [:callm, :@data, :[], [:slot]].:!
	subl	$24, %esp
	# callm :@data.:[]
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	24(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @data.[] END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____X(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :@data, :[], [:slot]].! END
	cmpl	%eax, nil
	je	.L1922_else
	cmpl	%eax, false
	je	.L1922_else
	# then: [:return, :nil]
	movl	nil, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L1922_else:
	.stabn  68,0,211,.LM1152	
.LM1152:
	# callm :@data.:[]
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	24(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :slot.:+
	subl	$28, %esp
	# [:lvar, 1, :edx]
	movl	-12(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm slot.+ END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @data.[] END
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	.stabn  68,0,212,.LM1153	
.LM1153:
	# callm :@data.:[]=
	subl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	24(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, 8(%esp)
	movl	Hash__Deleted, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX__3d(%eax)
	# Evicting self
	# Static adj: 32
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @data.[]= END
	.stabn  68,0,213,.LM1154	
.LM1154:
	# callm :@data.:[]=
	subl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	24(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :slot.:+
	subl	$28, %esp
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm slot.+ END
	movl	%eax, 8(%esp)
	movl	nil, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX__3d(%eax)
	# Evicting self
	# Static adj: 32
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @data.[]= END
	# [:lvar, 2, :edx]
	movl	-16(%ebp), %edx
	movl	%edx, %eax
	addl	$16, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Hash_delete, .-__method_Hash_delete
.Lscope221:
	.stabs  "",36,0,0,.Lscope221-.LFBB221	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_IO_initialize ########################	
		
	.stabs  "__method_IO_initialize:F(0,0)",36,0,0,__method_IO_initialize	
.globl __method_IO_initialize
	.type	__method_IO_initialize, @function
__method_IO_initialize:
.LFBB222:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1925_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_IO_initialize", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1924, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1925_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1927_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_IO_initialize", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1924, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1927_else:
	# METHOD BODY:
	.stabn  68,0,9,.LM1155	
.LM1155:
	subl	$12, %esp
	addl	$3, %ebx
	.stabn  68,0,10,.LM1156	
.LM1156:
	# [:arg, 2, :ecx]
	movl	16(%ebp), %ecx
	pushl	%ecx
	popl	%ecx
	pushl	%ecx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%edi
	movl	%edi, 4(%esi)
	subl	$20, %esp
	movl	$256, (%esp)
	movl	$1, %ebx
	call	__alloc_leaf
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	.stabn  68,0,12,.LM1157	
.LM1157:
	# [:lvar, 1, :edx]
	movl	-12(%ebp), %edx
	pushl	%edx
	popl	%edx
	pushl	%edx
	popl	%edi
	movl	%edi, 8(%esi)
	addl	$12, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_IO_initialize, .-__method_IO_initialize
.Lscope222:
	.stabs  "",36,0,0,.Lscope222-.LFBB222	
		
	########################################################################	
		
		
		
		
		
		
		
	########################### __method_IO_to_i ###########################	
		
	.stabs  "__method_IO_to_i:F(0,0)",36,0,0,__method_IO_to_i	
.globl __method_IO_to_i
	.type	__method_IO_to_i, @function
__method_IO_to_i:
.LFBB223:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1930_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_IO_to_i", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1929, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1930_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1932_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_IO_to_i", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1929, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1932_else:
	# METHOD BODY:
	.stabn  68,0,16,.LM1158	
.LM1158:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_IO_to_i, .-__method_IO_to_i
.Lscope223:
	.stabs  "",36,0,0,.Lscope223-.LFBB223	
		
	########################################################################	
		
		
		
		
		
		
		
	########################### __method_IO_getc ###########################	
		
	.stabs  "__method_IO_getc:F(0,0)",36,0,0,__method_IO_getc	
.globl __method_IO_getc
	.type	__method_IO_getc, @function
__method_IO_getc:
.LFBB224:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1935_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_IO_getc", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1934, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1935_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1937_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_IO_getc", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1934, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1937_else:
	# METHOD BODY:
	.stabn  68,0,20,.LM1159	
.LM1159:
	subl	$20, %esp
	addl	$5, %ebx
	.stabn  68,0,21,.LM1160	
.LM1160:
	movl	__I0, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	movl	__I0, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	.stabn  68,0,22,.LM1161	
.LM1161:
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	.stabn  68,0,23,.LM1162	
.LM1162:
	subl	$28, %esp
	# callm :@fd.:__get_raw
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____get_raw(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @fd.__get_raw END
	movl	%eax, (%esp)
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	8(%esi), %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	$3, %ebx
	call	read
	addl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	# if: [:le, :len, 0]
	# [:lvar, 3, :ecx]
	movl	-20(%ebp), %ecx
	# Locked register ecx
	movl	$0, %eax
	cmpl	%eax, %ecx
	setle	%al
	movzbl	%al, %eax
	# Unlocked register ecx
	testl	%eax, %eax
	je	.L1939_else
	# then: [:return, :nil]
	movl	nil, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L1939_else:
	subl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	8(%esi), %eax
	pushl	%eax
	popl	%edi
	movl	$0, %eax
	addl	%eax, %edi
	movzbl	(%edi), %eax
	movzbl	%al, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__int
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# [:lvar, 1, :edx]
	movl	-12(%ebp), %edx
	movl	%edx, %eax
	addl	$20, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_IO_getc, .-__method_IO_getc
.Lscope224:
	.stabs  "",36,0,0,.Lscope224-.LFBB224	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_IO_file__Q ##########################	
		
	.stabs  "__method_IO_file__Q:F(0,0)",36,0,0,__method_IO_file__Q	
.globl __method_IO_file__Q
	.type	__method_IO_file__Q, @function
__method_IO_file__Q:
.LFBB225:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1942_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_IO_file__Q", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1941, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1942_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1944_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_IO_file__Q", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1941, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1944_else:
	# METHOD BODY:
	.stabn  68,0,32,.LM1163	
.LM1163:
	movl	false, %eax
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_IO_file__Q, .-__method_IO_file__Q
.Lscope225:
	.stabs  "",36,0,0,.Lscope225-.LFBB225	
		
	########################################################################	
		
		
		
		
		
		
		
	########################## __method__file__Q ###########################	
		
	.stabs  "__method__file__Q:F(0,0)",36,0,0,__method__file__Q	
.globl __method__file__Q
	.type	__method__file__Q, @function
__method__file__Q:
.LFBB226:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1947_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method__file__Q", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1946, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1947_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1949_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method__file__Q", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1946, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1949_else:
	# METHOD BODY:
	.stabn  68,0,7,.LM1164	
.LM1164:
	.stabn  68,0,10,.LM1165	
.LM1165:
	# callm :io.:is_a?
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	File, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__is_a__Q(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm io.is_a? END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method__file__Q, .-__method__file__Q
.Lscope226:
	.stabs  "",36,0,0,.Lscope226-.LFBB226	
		
	########################################################################	
		
		
		
		
		
		
		
	########################## __method_File_path ##########################	
		
	.stabs  "__method_File_path:F(0,0)",36,0,0,__method_File_path	
.globl __method_File_path
	.type	__method_File_path, @function
__method_File_path:
.LFBB227:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1952_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_File_path", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1951, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1952_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1954_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_File_path", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1951, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1954_else:
	# METHOD BODY:
	.stabn  68,0,13,.LM1166	
.LM1166:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	12(%esi), %eax
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_File_path, .-__method_File_path
.Lscope227:
	.stabs  "",36,0,0,.Lscope227-.LFBB227	
		
	########################################################################	
		
		
		
		
		
		
		
	####################### __method_File_initialize #######################	
		
	.stabs  "__method_File_initialize:F(0,0)",36,0,0,__method_File_initialize	
.globl __method_File_initialize
	.type	__method_File_initialize, @function
__method_File_initialize:
.LFBB228:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1957_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_File_initialize", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1956, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1957_else:
	# if: [:gt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$4, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1959_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_File_initialize", 2, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1956, %eax
	movl	%eax, 4(%esp)
	movl	$2, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1959_else:
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for mode at position 5
	# [:sexp, [:call, :__get_string, :".L25"]]
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$4, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1961_else
	# then: [:assign, :"#mode", [:sexp, [:call, :__get_string, :".L25"]]]
	subl	$20, %esp
	movl	$.L25, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L1962_endif
	# else: [:assign, :"#mode", :mode]
.L1961_else:
	movl	20(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L1962_endif:
	# METHOD BODY:
	.stabn  68,0,17,.LM1167	
.LM1167:
	subl	$16, %esp
	addl	$4, %ebx
	.stabn  68,0,18,.LM1168	
.LM1168:
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	pushl	%edi
	popl	%edi
	pushl	%edi
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%edx
	movl	%edx, 12(%esi)
	# callm :path.:__get_raw
	subl	$24, %esp
	# [:arg, 2, :ecx]
	movl	16(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____get_raw(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm path.__get_raw END
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	.stabn  68,0,19,.LM1169	
.LM1169:
	subl	$24, %esp
	# [:lvar, 2, :edx]
	movl	-16(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	call	open
	addl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	.stabn  68,0,20,.LM1170	
.LM1170:
	# if: [:le, :fd, 0]
	# [:lvar, 3, :edi]
	movl	-20(%ebp), %edi
	# Locked register edi
	movl	$0, %eax
	cmpl	%eax, %edi
	setle	%al
	movzbl	%al, %eax
	# Unlocked register edi
	testl	%eax, %eax
	je	.L1963_else
	# then: [:do, [:printf, "Failed to open '%s' got %ld\n", :rpath, :fd], [:div, 0, 0]]
	subl	$28, %esp
	movl	$.L1964, %eax
	movl	%eax, (%esp)
	# [:lvar, 2, :ecx]
	movl	-16(%ebp), %ecx
	movl	%ecx, 4(%esp)
	# [:lvar, 3, :edx]
	movl	-20(%ebp), %edx
	movl	%edx, 8(%esp)
	movl	$3, %ebx
	call	printf
	addl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$0
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1963_else:
	.stabn  68,0,26,.LM1171	
.LM1171:
	subl	$20, %esp
	# [:lvar, 3, :ecx]
	movl	-20(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$1, %ebx
	call	__int
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	.stabn  68,0,27,.LM1172	
.LM1172:
	# super :initialize
	# callm :self.:initialize
	subl	$28, %esp
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 3, :edi]
	movl	-20(%ebp), %edi
	movl	%edi, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	movl	12(%eax), %eax
	call	*__voff__initialize(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.initialize END
	addl	$16, %esp
	addl	$4, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_File_initialize, .-__method_File_initialize
.Lscope228:
	.stabs  "",36,0,0,.Lscope228-.LFBB228	
		
	########################################################################	
		
		
		
		
		
		
		
	############################ __method__open ############################	
		
	.stabs  "__method__open:F(0,0)",36,0,0,__method__open	
.globl __method__open
	.type	__method__open, @function
__method__open:
.LFBB229:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$3, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1967_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method__open", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1966, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1967_else:
	# if: [:gt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$4, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1969_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method__open", 2, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1966, %eax
	movl	%eax, 4(%esp)
	movl	$2, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1969_else:
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for mode at position 5
	# [:sexp, [:call, :__get_string, :".L25"]]
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$4, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1971_else
	# then: [:assign, :"#mode", [:sexp, [:call, :__get_string, :".L25"]]]
	subl	$20, %esp
	movl	$.L25, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L1972_endif
	# else: [:assign, :"#mode", :mode]
.L1971_else:
	# [:arg, 3, :ecx]
	movl	20(%ebp), %ecx
	pushl	%ecx
	popl	%eax
	movl	%eax, -8(%ebp)
.L1972_endif:
	# METHOD BODY:
	.stabn  68,0,32,.LM1173	
.LM1173:
	subl	$12, %esp
	addl	$3, %ebx
	.stabn  68,0,33,.LM1174	
.LM1174:
	# callm :File.:new
	subl	$32, %esp
	movl	File, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# [:arg, 2, :edx]
	movl	16(%ebp), %edx
	movl	%edx, 8(%esp)
	# [:lvar, 0, :edi]
	movl	-8(%ebp), %edi
	movl	%edi, 12(%esp)
	movl	$4, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__new(%eax)
	# Evicting self
	# Static adj: 32
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm File.new END
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	addl	$12, %esp
	addl	$4, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method__open, .-__method__open
.Lscope229:
	.stabs  "",36,0,0,.Lscope229-.LFBB229	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method__exists__Q ##########################	
		
	.stabs  "__method__exists__Q:F(0,0)",36,0,0,__method__exists__Q	
.globl __method__exists__Q
	.type	__method__exists__Q, @function
__method__exists__Q:
.LFBB230:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1974_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method__exists__Q", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1973, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1974_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1976_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method__exists__Q", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1973, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1976_else:
	# METHOD BODY:
	.stabn  68,0,36,.LM1175	
.LM1175:
	subl	$16, %esp
	addl	$4, %ebx
	.stabn  68,0,37,.LM1176	
.LM1176:
	# callm :path.:__get_raw
	subl	$24, %esp
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____get_raw(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm path.__get_raw END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	subl	$24, %esp
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	call	open
	addl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	.stabn  68,0,38,.LM1177	
.LM1177:
	# if: [:le, :fd, 0]
	# [:lvar, 2, :edx]
	movl	-16(%ebp), %edx
	# Locked register edx
	movl	$0, %eax
	cmpl	%eax, %edx
	setle	%al
	movzbl	%al, %eax
	# Unlocked register edx
	testl	%eax, %eax
	je	.L1978_else
	# then: [:return, :false]
	movl	false, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L1978_else:
	.stabn  68,0,39,.LM1178	
.LM1178:
	subl	$20, %esp
	# [:lvar, 2, :edi]
	movl	-16(%ebp), %edi
	movl	%edi, (%esp)
	movl	$1, %ebx
	call	close
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	.stabn  68,0,40,.LM1179	
.LM1179:
	movl	true, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	addl	$16, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method__exists__Q, .-__method__exists__Q
.Lscope230:
	.stabs  "",36,0,0,.Lscope230-.LFBB230	
		
	########################################################################	
		
		
		
		
		
		
		
	########################## __method__basename ##########################	
		
	.stabs  "__method__basename:F(0,0)",36,0,0,__method__basename	
.globl __method__basename
	.type	__method__basename, @function
__method__basename:
.LFBB231:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1981_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method__basename", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1980, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1981_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1983_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method__basename", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1980, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1983_else:
	# METHOD BODY:
	.stabn  68,0,44,.LM1180	
.LM1180:
	subl	$12, %esp
	addl	$3, %ebx
	.stabn  68,0,45,.LM1181	
.LM1181:
	# callm :name.:rindex
	subl	$28, %esp
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	File__SEPARATOR, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__rindex(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm name.rindex END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# if: [:and, [:callm, :i, :!], :ALT_SEPARATOR]
	# if: [:callm, :i, :!]
	# callm :i.:!
	subl	$24, %esp
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____X(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm i.! END
	cmpl	%eax, nil
	je	.L1985_else
	cmpl	%eax, false
	je	.L1985_else
	# then: :ALT_SEPARATOR
	movl	File__ALT_SEPARATOR, %eax
	# else: nil
.L1985_else:
	cmpl	%eax, nil
	je	.L1987_else
	cmpl	%eax, false
	je	.L1987_else
	# then: [:do, [:assign, :i, [:callm, :name, :rindex, [:ALT_SEPARATOR]]]]
	.stabn  68,0,47,.LM1182	
.LM1182:
	# callm :name.:rindex
	subl	$28, %esp
	# [:arg, 2, :edx]
	movl	16(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	File__ALT_SEPARATOR, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__rindex(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm name.rindex END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# else: nil
.L1987_else:
	.stabn  68,0,48,.LM1183	
.LM1183:
	# if: :i
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, %eax
	cmpl	%eax, nil
	je	.L1989_else
	cmpl	%eax, false
	je	.L1989_else
	# then: [:do, [:assign, :i, [:callm, :i, :+, [[:sexp, :__I1]]]], [:return, [:callm, :name, :[], [[:callm, :Range, :new, [:i, [:sexp, :__Ineg1]]]]]]]
	.stabn  68,0,51,.LM1184	
.LM1184:
	# callm :i.:+
	subl	$28, %esp
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm i.+ END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# callm :name.:[]
	subl	$28, %esp
	# [:arg, 2, :edx]
	movl	16(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	# callm :Range.:new
	subl	$32, %esp
	movl	Range, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, 8(%esp)
	movl	__Ineg1, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__new(%eax)
	# Evicting self
	# Static adj: 32
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm Range.new END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm name.[] END
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L1989_else:
	.stabn  68,0,53,.LM1185	
.LM1185:
	# [:arg, 2, :ecx]
	movl	16(%ebp), %ecx
	movl	%ecx, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	addl	$12, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method__basename, .-__method__basename
.Lscope231:
	.stabs  "",36,0,0,.Lscope231-.LFBB231	
		
	########################################################################	
		
		
		
		
		
		
		
	########################## __method__dirname ###########################	
		
	.stabs  "__method__dirname:F(0,0)",36,0,0,__method__dirname	
.globl __method__dirname
	.type	__method__dirname, @function
__method__dirname:
.LFBB232:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$3, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1992_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method__dirname", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L1991, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L1992_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L1994_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method__dirname", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L1991, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L1994_else:
	# METHOD BODY:
	.stabn  68,0,57,.LM1186	
.LM1186:
	subl	$20, %esp
	addl	$5, %ebx
	.stabn  68,0,58,.LM1187	
.LM1187:
	# callm :dname.:rindex
	subl	$28, %esp
	# [:arg, 2, :ecx]
	movl	16(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	File__SEPARATOR, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__rindex(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm dname.rindex END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# if: [:and, [:callm, :i, :!], :ALT_SEPARATOR]
	# if: [:callm, :i, :!]
	# callm :i.:!
	subl	$24, %esp
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____X(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm i.! END
	cmpl	%eax, nil
	je	.L1996_else
	cmpl	%eax, false
	je	.L1996_else
	# then: :ALT_SEPARATOR
	movl	File__ALT_SEPARATOR, %eax
	# else: nil
.L1996_else:
	cmpl	%eax, nil
	je	.L1998_else
	cmpl	%eax, false
	je	.L1998_else
	# then: [:do, [:assign, :i, [:callm, :dname, :rindex, [:ALT_SEPARATOR]]]]
	.stabn  68,0,60,.LM1188	
.LM1188:
	# callm :dname.:rindex
	subl	$28, %esp
	# [:arg, 2, :edx]
	movl	16(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	File__ALT_SEPARATOR, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__rindex(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm dname.rindex END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# else: nil
.L1998_else:
	.stabn  68,0,61,.LM1189	
.LM1189:
	# if: [:and, :i, [:callm, :i, :>, [[:sexp, :__I0]]]]
	# if: :i
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, %eax
	cmpl	%eax, nil
	je	.L2000_else
	cmpl	%eax, false
	je	.L2000_else
	# then: [:callm, :i, :>, [[:sexp, :__I0]]]
	# callm :i.:>
	subl	$28, %esp
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	__I0, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____gt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm i.> END
	# else: nil
.L2000_else:
	cmpl	%eax, nil
	je	.L2002_else
	cmpl	%eax, false
	je	.L2002_else
	# then: [:do, [:assign, :i, [:callm, :i, :-, [[:sexp, :__I1]]]], [:assign, :r, [:callm, :Range, :new, [[:sexp, :__I0], :i]]], [:assign, :d, [:callm, :dname, :[], [:r]]], [:return, :d]]
	.stabn  68,0,64,.LM1190	
.LM1190:
	# callm :i.:-
	subl	$28, %esp
	# [:lvar, 1, :edx]
	movl	-12(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____minus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm i.- END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# callm :Range.:new
	subl	$32, %esp
	movl	Range, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I0, %eax
	movl	%eax, 8(%esp)
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, 12(%esp)
	movl	$4, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__new(%eax)
	# Evicting self
	# Static adj: 32
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm Range.new END
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	.stabn  68,0,65,.LM1191	
.LM1191:
	# callm :dname.:[]
	subl	$28, %esp
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 2, :edx]
	movl	-16(%ebp), %edx
	movl	%edx, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm dname.[] END
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	.stabn  68,0,66,.LM1192	
.LM1192:
	# [:lvar, 3, :ecx]
	movl	-20(%ebp), %ecx
	movl	%ecx, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L2002_else:
	.stabn  68,0,68,.LM1193	
.LM1193:
	movl	nil, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	addl	$20, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method__dirname, .-__method__dirname
.Lscope232:
	.stabs  "",36,0,0,.Lscope232-.LFBB232	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method__expand_path #########################	
		
	.stabs  "__method__expand_path:F(0,0)",36,0,0,__method__expand_path	
.globl __method__expand_path
	.type	__method__expand_path, @function
__method__expand_path:
.LFBB233:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$3, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2005_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method__expand_path", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2004, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2005_else:
	# if: [:gt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$4, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2007_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method__expand_path", 2, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2004, %eax
	movl	%eax, 4(%esp)
	movl	$2, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2007_else:
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for dir_string at position 5
	# [:callm, :Dir, :pwd]
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$4, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2009_else
	# then: [:assign, :"#dir_string", [:callm, :Dir, :pwd]]
	# callm :Dir.:pwd
	subl	$24, %esp
	movl	Dir, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__pwd(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm Dir.pwd END
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L2010_endif
	# else: [:assign, :"#dir_string", :dir_string]
.L2009_else:
	movl	20(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L2010_endif:
	# METHOD BODY:
	.stabn  68,0,72,.LM1194	
.LM1194:
	subl	$20, %esp
	addl	$5, %ebx
	subl	$20, %esp
	movl	$12, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-20(%ebp), %eax
	movl	%eax, %edi
	addl	$8, %edi
	popl	%eax
	movl	%eax, (%edi)
	.stabn  68,0,73,.LM1195	
.LM1195:
	# if: [:callm, [:callm, :path, :[], [[:sexp, :__I0]]], :==, [[:sexp, :__I47]]]
	# callm [:callm, :path, :[], [[:sexp, :__I0]]].:==
	subl	$28, %esp
	# callm :path.:[]
	subl	$28, %esp
	# [:arg, 2, :edx]
	movl	16(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	__I0, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm path.[] END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I47, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :path, :[], [[:sexp, :__I0]]].== END
	cmpl	%eax, nil
	je	.L2011_else
	cmpl	%eax, false
	je	.L2011_else
	# then: [:return, :path]
	# [:arg, 2, :ecx]
	movl	16(%ebp), %ecx
	movl	%ecx, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L2011_else:
	# callm [:callm, [:callm, [:callm, [:callm, [:sexp, [:call, :__get_string, :".L0"]], :to_s], :concat, [[:callm, :dir_string, :to_s]]], :concat, [[:callm, [:sexp, [:call, :__get_string, :".L24"]], :to_s]]], :concat, [[:callm, :path, :to_s]]].:split
	subl	$28, %esp
	# callm [:callm, [:callm, [:callm, [:sexp, [:call, :__get_string, :".L0"]], :to_s], :concat, [[:callm, :dir_string, :to_s]]], :concat, [[:callm, [:sexp, [:call, :__get_string, :".L24"]], :to_s]]].:concat
	subl	$28, %esp
	# callm [:callm, [:callm, [:sexp, [:call, :__get_string, :".L0"]], :to_s], :concat, [[:callm, :dir_string, :to_s]]].:concat
	subl	$28, %esp
	# callm [:callm, [:sexp, [:call, :__get_string, :".L0"]], :to_s].:concat
	subl	$28, %esp
	# callm [:sexp, [:call, :__get_string, :".L0"]].:to_s
	subl	$24, %esp
	subl	$20, %esp
	movl	$.L0, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:sexp, [:call, :__get_string, :".L0"]].to_s END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :dir_string.:to_s
	subl	$24, %esp
	movl	-8(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm dir_string.to_s END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__concat(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:sexp, [:call, :__get_string, :".L0"]], :to_s].concat END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm [:sexp, [:call, :__get_string, :".L24"]].:to_s
	subl	$24, %esp
	subl	$20, %esp
	movl	$.L24, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:sexp, [:call, :__get_string, :".L24"]].to_s END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__concat(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:callm, [:sexp, [:call, :__get_string, :".L0"]], :to_s], :concat, [[:callm, :dir_string, :to_s]]].concat END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :path.:to_s
	subl	$24, %esp
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm path.to_s END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__concat(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:callm, [:callm, [:sexp, [:call, :__get_string, :".L0"]], :to_s], :concat, [[:callm, :dir_string, :to_s]]], :concat, [[:callm, [:sexp, [:call, :__get_string, :".L24"]], :to_s]]].concat END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	subl	$20, %esp
	movl	$.L24, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__split(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:callm, [:callm, [:callm, [:sexp, [:call, :__get_string, :".L0"]], :to_s], :concat, [[:callm, :dir_string, :to_s]]], :concat, [[:callm, [:sexp, [:call, :__get_string, :".L24"]], :to_s]]], :concat, [[:callm, :path, :to_s]]].split END
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	.stabn  68,0,75,.LM1196	
.LM1196:
	# callm :Array.:[]
	subl	$24, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm Array.[] END
	pushl	%eax
	movl	-20(%ebp), %eax
	movl	%eax, %edx
	addl	$4, %edx
	popl	%eax
	movl	%eax, (%edx)
	.stabn  68,0,77,.LM1197	
.LM1197:
	# callm :str.:each
	subl	$24, %esp
	# [:lvar, 2, :ecx]
	movl	-16(%ebp), %ecx
	movl	%ecx, (%esp)
	.stabn  68,0,78,.LM1198	
.LM1198:
	# Stack frame
	pushl	%ebp
	movl	-20(%ebp), %eax
	movl	%eax, %edi
	popl	%eax
	movl	%eax, (%edi)
	movl	$__lambda_L104, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -24(%ebp)
	subl	$32, %esp
	movl	-24(%ebp), %eax
	movl	%eax, (%esp)
	movl	-20(%ebp), %eax
	movl	%eax, 4(%esp)
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, 8(%esp)
	movl	$1, 12(%esp)
	movl	$4, %ebx
	call	__new_proc
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__each(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm str.each END
	.stabn  68,0,88,.LM1199	
.LM1199:
	# callm [:callm, [:sexp, [:call, :__get_string, :".L24"]], :to_s].:concat
	subl	$28, %esp
	# callm [:sexp, [:call, :__get_string, :".L24"]].:to_s
	subl	$24, %esp
	subl	$20, %esp
	movl	$.L24, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:sexp, [:call, :__get_string, :".L24"]].to_s END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm [:callm, [:index, :__env__, 1], :join, [[:sexp, [:call, :__get_string, :".L24"]]]].:to_s
	subl	$24, %esp
	.stabn  68,0,90,.LM1200	
.LM1200:
	# callm [:index, :__env__, 1].:join
	subl	$28, %esp
	movl	-20(%ebp), %eax
	movl	%eax, %edx
	addl	$4, %edx
	movl	(%edx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	subl	$20, %esp
	movl	$.L24, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__join(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].join END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:index, :__env__, 1], :join, [[:sexp, [:call, :__get_string, :".L24"]]]].to_s END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__concat(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:sexp, [:call, :__get_string, :".L24"]], :to_s].concat END
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	addl	$20, %esp
	addl	$4, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method__expand_path, .-__method__expand_path
.Lscope233:
	.stabs  "",36,0,0,.Lscope233-.LFBB233	
		
	########################################################################	
		
		
		
		
		
		
		
	############################ __method__pwd #############################	
		
	.stabs  "__method__pwd:F(0,0)",36,0,0,__method__pwd	
.globl __method__pwd
	.type	__method__pwd, @function
__method__pwd:
.LFBB234:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2015_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method__pwd", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2014, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2015_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2017_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method__pwd", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2014, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2017_else:
	# METHOD BODY:
	.stabn  68,0,3,.LM1201	
.LM1201:
	subl	$16, %esp
	addl	$4, %ebx
	.stabn  68,0,4,.LM1202	
.LM1202:
	subl	$16, %esp
	movl	$0, %ebx
	call	get_current_dir_name
	addl	$16, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	subl	$20, %esp
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	.stabn  68,0,5,.LM1203	
.LM1203:
	# callm :cwd.:dup
	subl	$24, %esp
	# [:lvar, 2, :ecx]
	movl	-16(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__dup(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm cwd.dup END
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	.stabn  68,0,6,.LM1204	
.LM1204:
	subl	$20, %esp
	# [:lvar, 1, :edx]
	movl	-12(%ebp), %edx
	movl	%edx, (%esp)
	movl	$1, %ebx
	call	free
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	.stabn  68,0,7,.LM1205	
.LM1205:
	# [:lvar, 2, :edi]
	movl	-16(%ebp), %edi
	movl	%edi, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	addl	$16, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method__pwd, .-__method__pwd
.Lscope234:
	.stabs  "",36,0,0,.Lscope234-.LFBB234	
		
	########################################################################	
		
		
		
		
		
		
		
	###################### __method_Fixnum_initialize ######################	
		
	.stabs  "__method_Fixnum_initialize:F(0,0)",36,0,0,__method_Fixnum_initialize	
.globl __method_Fixnum_initialize
	.type	__method_Fixnum_initialize, @function
__method_Fixnum_initialize:
.LFBB235:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2020_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Fixnum_initialize", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2019, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2020_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2022_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Fixnum_initialize", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2019, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2022_else:
	# METHOD BODY:
	.stabn  68,0,3,.LM1206	
.LM1206:
	.stabn  68,0,7,.LM1207	
.LM1207:
	pushl	$0
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%edi
	movl	%edi, 4(%esi)
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Fixnum_initialize, .-__method_Fixnum_initialize
.Lscope235:
	.stabs  "",36,0,0,.Lscope235-.LFBB235	
		
	########################################################################	
		
		
		
		
		
		
		
	########################## __method__allocate ##########################	
		
	.stabs  "__method__allocate:F(0,0)",36,0,0,__method__allocate	
.globl __method__allocate
	.type	__method__allocate, @function
__method__allocate:
.LFBB236:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2025_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method__allocate", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2024, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2025_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2027_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method__allocate", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2024, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2027_else:
	# METHOD BODY:
	.stabn  68,0,10,.LM1208	
.LM1208:
	subl	$16, %esp
	addl	$4, %ebx
	.stabn  68,0,11,.LM1209	
.LM1209:
	subl	$20, %esp
	movl	$2, (%esp)
	movl	$1, %ebx
	call	__array_leaf
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	pushl	%esi
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	movl	%edi, %eax
	addl	$16, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method__allocate, .-__method__allocate
.Lscope236:
	.stabs  "",36,0,0,.Lscope236-.LFBB236	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Fixnum___25 #########################	
		
	.stabs  "__method_Fixnum___25:F(0,0)",36,0,0,__method_Fixnum___25	
.globl __method_Fixnum___25
	.type	__method_Fixnum___25, @function
__method_Fixnum___25:
.LFBB237:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$3, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2030_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Fixnum___25", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2029, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2030_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2032_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Fixnum___25", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2029, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2032_else:
	# METHOD BODY:
	.stabn  68,0,16,.LM1210	
.LM1210:
	subl	$16, %esp
	addl	$4, %ebx
	.stabn  68,0,17,.LM1211	
.LM1211:
	# callm :other.:__get_raw
	subl	$24, %esp
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____get_raw(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm other.__get_raw END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	pushl	%eax
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	movl	%edx, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	.stabn  68,0,18,.LM1212	
.LM1212:
	# if: [:eq, [:ge, :m, 0], [:lt, :r, 0]]
	# [:lvar, 2, :edi]
	movl	-16(%ebp), %edi
	# Locked register edi
	movl	$0, %eax
	cmpl	%eax, %edi
	setge	%al
	movzbl	%al, %eax
	# Unlocked register edi
	movl	%eax, %edx
	# Locked register ecx
	movl	$0, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	# Unlocked register ecx
	cmpl	%eax, %edx
	sete	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2034_else
	# then: [:assign, :m, [:add, :m, :r]]
	# [:lvar, 2, :edx]
	movl	-16(%ebp), %edx
	# Locked register edx
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, %eax
	addl	%edx, %eax
	# Unlocked register edx
	pushl	%eax
	# Marked edx dirty (lvar,2)
	popl	%eax
	movl	%eax, %edx
	# Saving edx to lvar,2
	movl	%edx, -16(%ebp)
	# else: nil
.L2034_else:
	.stabn  68,0,20,.LM1213	
.LM1213:
	subl	$20, %esp
	# [:lvar, 2, :edi]
	movl	-16(%ebp), %edi
	movl	%edi, (%esp)
	movl	$1, %ebx
	call	__int
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	addl	$16, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Fixnum___25, .-__method_Fixnum___25
.Lscope237:
	.stabs  "",36,0,0,.Lscope237-.LFBB237	
		
	########################################################################	
		
		
		
		
		
		
		
	###################### __method_Fixnum___set_raw #######################	
		
	.stabs  "__method_Fixnum___set_raw:F(0,0)",36,0,0,__method_Fixnum___set_raw	
.globl __method_Fixnum___set_raw
	.type	__method_Fixnum___set_raw, @function
__method_Fixnum___set_raw:
.LFBB238:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$3, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2037_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Fixnum___set_raw", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2036, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2037_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2039_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Fixnum___set_raw", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2036, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2039_else:
	# METHOD BODY:
	.stabn  68,0,24,.LM1214	
.LM1214:
	.stabn  68,0,25,.LM1215	
.LM1215:
	movl	16(%ebp), %eax
	pushl	%eax
	popl	%eax
	pushl	%eax
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%edi
	movl	%edi, 4(%esi)
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Fixnum___set_raw, .-__method_Fixnum___set_raw
.Lscope238:
	.stabs  "",36,0,0,.Lscope238-.LFBB238	
		
	########################################################################	
		
		
		
		
		
		
		
	###################### __method_Fixnum___get_raw #######################	
		
	.stabs  "__method_Fixnum___get_raw:F(0,0)",36,0,0,__method_Fixnum___get_raw	
.globl __method_Fixnum___get_raw
	.type	__method_Fixnum___get_raw, @function
__method_Fixnum___get_raw:
.LFBB239:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2042_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Fixnum___get_raw", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2041, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2042_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2044_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Fixnum___get_raw", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2041, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2044_else:
	# METHOD BODY:
	.stabn  68,0,28,.LM1216	
.LM1216:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Fixnum___get_raw, .-__method_Fixnum___get_raw
.Lscope239:
	.stabs  "",36,0,0,.Lscope239-.LFBB239	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Fixnum_to_i #########################	
		
	.stabs  "__method_Fixnum_to_i:F(0,0)",36,0,0,__method_Fixnum_to_i	
.globl __method_Fixnum_to_i
	.type	__method_Fixnum_to_i, @function
__method_Fixnum_to_i:
.LFBB240:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2047_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Fixnum_to_i", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2046, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2047_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2049_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Fixnum_to_i", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2046, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2049_else:
	# METHOD BODY:
	.stabn  68,0,32,.LM1217	
.LM1217:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, %eax
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Fixnum_to_i, .-__method_Fixnum_to_i
.Lscope240:
	.stabs  "",36,0,0,.Lscope240-.LFBB240	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Fixnum___NDX #########################	
		
	.stabs  "__method_Fixnum___NDX:F(0,0)",36,0,0,__method_Fixnum___NDX	
.globl __method_Fixnum___NDX
	.type	__method_Fixnum___NDX, @function
__method_Fixnum___NDX:
.LFBB241:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2052_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Fixnum___NDX", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2051, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2052_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2054_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Fixnum___NDX", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2051, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2054_else:
	# METHOD BODY:
	.stabn  68,0,38,.LM1218	
.LM1218:
	movl	__I1, %eax
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Fixnum___NDX, .-__method_Fixnum___NDX
.Lscope241:
	.stabs  "",36,0,0,.Lscope241-.LFBB241	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Fixnum_to_s #########################	
		
	.stabs  "__method_Fixnum_to_s:F(0,0)",36,0,0,__method_Fixnum_to_s	
.globl __method_Fixnum_to_s
	.type	__method_Fixnum_to_s, @function
__method_Fixnum_to_s:
.LFBB242:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2057_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Fixnum_to_s", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2056, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2057_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2059_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Fixnum_to_s", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2056, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2059_else:
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for radix at position 4
	# [:sexp, :__I10]
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2061_else
	# then: [:assign, :"#radix", [:sexp, :__I10]]
	movl	__I10, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L2062_endif
	# else: [:assign, :"#radix", :radix]
.L2061_else:
	# [:arg, 2, :ecx]
	movl	16(%ebp), %ecx
	pushl	%ecx
	popl	%eax
	movl	%eax, -8(%ebp)
.L2062_endif:
	# METHOD BODY:
	.stabn  68,0,42,.LM1219	
.LM1219:
	subl	$28, %esp
	addl	$7, %ebx
	.stabn  68,0,43,.LM1220	
.LM1220:
	# if: [:or, [:callm, :radix, :<, [[:sexp, :__I2]]], [:callm, :radix, :>, [[:sexp, :__I36]]]]
	# compile_or: [:callm, :radix, :<, [[:sexp, :__I2]]] || [:callm, :radix, :>, [[:sexp, :__I36]]]
	# callm :radix.:<
	subl	$28, %esp
	# [:lvar, 0, :edx]
	movl	-8(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	__I2, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm radix.< END
	cmpl	%eax, nil
	je	.L2063_or
	cmpl	%eax, false
	je	.L2063_or
	jmp	.L2064_end_or
	# .. or:
.L2063_or:
	# callm :radix.:>
	subl	$28, %esp
	# [:lvar, 0, :edi]
	movl	-8(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	__I36, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____gt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm radix.> END
.L2064_end_or:
	cmpl	%eax, nil
	je	.L2065_else
	cmpl	%eax, false
	je	.L2065_else
	# then: [:do, [:callm, :STDERR, :puts, [[:callm, [:callm, [:callm, [:sexp, [:call, :__get_string, :".L27"]], :to_s], :concat, [[:callm, [:callm, :radix, :inspect], :to_s]]], :concat, [[:callm, [:sexp, [:call, :__get_string, :".L28"]], :to_s]]]]], [:callm, [:sexp, :__I1], :/, [[:sexp, :__I0]]]]
	.stabn  68,0,44,.LM1221	
.LM1221:
	# callm :STDERR.:puts
	subl	$28, %esp
	movl	STDERR, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm [:callm, [:callm, [:sexp, [:call, :__get_string, :".L27"]], :to_s], :concat, [[:callm, [:callm, :radix, :inspect], :to_s]]].:concat
	subl	$28, %esp
	# callm [:callm, [:sexp, [:call, :__get_string, :".L27"]], :to_s].:concat
	subl	$28, %esp
	# callm [:sexp, [:call, :__get_string, :".L27"]].:to_s
	subl	$24, %esp
	subl	$20, %esp
	movl	$.L27, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:sexp, [:call, :__get_string, :".L27"]].to_s END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm [:callm, :radix, :inspect].:to_s
	subl	$24, %esp
	# callm :radix.:inspect
	subl	$24, %esp
	# [:lvar, 0, :ecx]
	movl	-8(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__inspect(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm radix.inspect END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :radix, :inspect].to_s END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__concat(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:sexp, [:call, :__get_string, :".L27"]], :to_s].concat END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm [:sexp, [:call, :__get_string, :".L28"]].:to_s
	subl	$24, %esp
	subl	$20, %esp
	movl	$.L28, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:sexp, [:call, :__get_string, :".L28"]].to_s END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__concat(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:callm, [:sexp, [:call, :__get_string, :".L27"]], :to_s], :concat, [[:callm, [:callm, :radix, :inspect], :to_s]]].concat END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__puts(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm STDERR.puts END
	# callm [:sexp, :__I1].:/
	subl	$28, %esp
	movl	__I1, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I0, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____div(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:sexp, :__I1]./ END
	jmp	.L2066_endif
	# else: [:do, [:assign, :out, [:sexp, [:call, :__get_string, :".L0"]]], [:assign, :n, :self], [:assign, :neg, [:callm, :self, :<, [[:sexp, :__I0]]]], [:if, :neg, [:do, [:assign, :n, [:callm, [:sexp, :__I0], :-, [:n]]]]], [:assign, :digits, [:sexp, [:call, :__get_string, :".L29"]]], [:while, [:callm, :n, :!=, [[:sexp, :__I0]]], [:do, [:assign, :r, [:callm, :n, :%, [:radix]]], [:callm, :out, :<<, [[:callm, :digits, :[], [:r]]]], [:if, [:callm, :n, :<, [:radix]], [:break]], [:assign, :n, [:callm, :n, :/, [:radix]]]]], [:if, [:callm, :out, :empty?], [:do, [:assign, :out, [:sexp, [:call, :__get_string, :".L30"]]]], [:do, [:if, :neg, [:do, [:callm, :out, :<<, [[:sexp, [:call, :__get_string, :".L31"]]]]]]]], [:callm, :out, :reverse]]
.L2065_else:
	.stabn  68,0,47,.LM1222	
.LM1222:
	subl	$20, %esp
	movl	$.L0, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	pushl	%esi
	popl	%eax
	movl	%eax, -20(%ebp)
	.stabn  68,0,48,.LM1223	
.LM1223:
	# callm :self.:<
	subl	$28, %esp
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	__I0, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.< END
	pushl	%eax
	popl	%eax
	movl	%eax, -24(%ebp)
	.stabn  68,0,49,.LM1224	
.LM1224:
	# if: :neg
	# [:lvar, 4, :edx]
	movl	-24(%ebp), %edx
	movl	%edx, %eax
	cmpl	%eax, nil
	je	.L2067_else
	cmpl	%eax, false
	je	.L2067_else
	# then: [:do, [:assign, :n, [:callm, [:sexp, :__I0], :-, [:n]]]]
	.stabn  68,0,51,.LM1225	
.LM1225:
	# callm [:sexp, :__I0].:-
	subl	$28, %esp
	movl	__I0, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 3, :edi]
	movl	-20(%ebp), %edi
	movl	%edi, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____minus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:sexp, :__I0].- END
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	# else: nil
.L2067_else:
	.stabn  68,0,52,.LM1226	
.LM1226:
	subl	$20, %esp
	movl	$.L29, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -28(%ebp)
	.stabn  68,0,53,.LM1227	
.LM1227:
.L2070:
	# callm :n.:!=
	subl	$28, %esp
	# [:lvar, 3, :ecx]
	movl	-20(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	__I0, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____X__3d(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm n.!= END
	cmpl	%eax, nil
	je	.L2069
	cmpl	%eax, false
	je	.L2069
	.stabn  68,0,54,.LM1228	
.LM1228:
	# callm :n.:%
	subl	$28, %esp
	# [:lvar, 3, :edx]
	movl	-20(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 0, :edi]
	movl	-8(%ebp), %edi
	movl	%edi, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____25(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm n.% END
	pushl	%eax
	popl	%eax
	movl	%eax, -32(%ebp)
	.stabn  68,0,55,.LM1229	
.LM1229:
	# callm :out.:<<
	subl	$28, %esp
	# [:lvar, 2, :ecx]
	movl	-16(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	# callm :digits.:[]
	subl	$28, %esp
	# [:lvar, 5, :edx]
	movl	-28(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 6, :edi]
	movl	-32(%ebp), %edi
	movl	%edi, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm digits.[] END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt__lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm out.<< END
	.stabn  68,0,56,.LM1230	
.LM1230:
	# if: [:callm, :n, :<, [:radix]]
	# callm :n.:<
	subl	$28, %esp
	# [:lvar, 3, :ecx]
	movl	-20(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 0, :edx]
	movl	-8(%ebp), %edx
	movl	%edx, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm n.< END
	cmpl	%eax, nil
	je	.L2071_else
	cmpl	%eax, false
	je	.L2071_else
	# then: [:break]
	# BREAK
	jmp	.L2069
	# else: nil
.L2071_else:
	.stabn  68,0,57,.LM1231	
.LM1231:
	# callm :n.:/
	subl	$28, %esp
	# [:lvar, 3, :edi]
	movl	-20(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 0, :edx]
	movl	-8(%ebp), %edx
	movl	%edx, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____div(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm n./ END
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	jmp	.L2070
.L2069:
	movl	nil, %eax
	.stabn  68,0,59,.LM1232	
.LM1232:
	# if: [:callm, :out, :empty?]
	# callm :out.:empty?
	subl	$24, %esp
	# [:lvar, 2, :ecx]
	movl	-16(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__empty__Q(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm out.empty? END
	cmpl	%eax, nil
	je	.L2073_else
	cmpl	%eax, false
	je	.L2073_else
	# then: [:do, [:assign, :out, [:sexp, [:call, :__get_string, :".L30"]]]]
	.stabn  68,0,61,.LM1233	
.LM1233:
	subl	$20, %esp
	movl	$.L30, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	jmp	.L2074_endif
	# else: [:do, [:if, :neg, [:do, [:callm, :out, :<<, [[:sexp, [:call, :__get_string, :".L31"]]]]]]]
.L2073_else:
	.stabn  68,0,62,.LM1234	
.LM1234:
	# if: :neg
	# [:lvar, 4, :edx]
	movl	-24(%ebp), %edx
	movl	%edx, %eax
	cmpl	%eax, nil
	je	.L2075_else
	cmpl	%eax, false
	je	.L2075_else
	# then: [:do, [:callm, :out, :<<, [[:sexp, [:call, :__get_string, :".L31"]]]]]
	.stabn  68,0,63,.LM1235	
.LM1235:
	# callm :out.:<<
	subl	$28, %esp
	# [:lvar, 2, :edi]
	movl	-16(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	subl	$20, %esp
	movl	$.L31, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt__lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm out.<< END
	# else: nil
.L2075_else:
.L2074_endif:
	.stabn  68,0,64,.LM1236	
.LM1236:
	# callm :out.:reverse
	subl	$24, %esp
	# [:lvar, 2, :ecx]
	movl	-16(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__reverse(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm out.reverse END
.L2066_endif:
	addl	$28, %esp
	addl	$4, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Fixnum_to_s, .-__method_Fixnum_to_s
.Lscope242:
	.stabs  "",36,0,0,.Lscope242-.LFBB242	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Fixnum_hash #########################	
		
	.stabs  "__method_Fixnum_hash:F(0,0)",36,0,0,__method_Fixnum_hash	
.globl __method_Fixnum_hash
	.type	__method_Fixnum_hash, @function
__method_Fixnum_hash:
.LFBB243:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2078_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Fixnum_hash", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2077, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2078_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2080_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Fixnum_hash", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2077, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2080_else:
	# METHOD BODY:
	.stabn  68,0,69,.LM1237	
.LM1237:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, %eax
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Fixnum_hash, .-__method_Fixnum_hash
.Lscope243:
	.stabs  "",36,0,0,.Lscope243-.LFBB243	
		
	########################################################################	
		
		
		
		
		
		
		
	####################### __method_Fixnum_inspect ########################	
		
	.stabs  "__method_Fixnum_inspect:F(0,0)",36,0,0,__method_Fixnum_inspect	
.globl __method_Fixnum_inspect
	.type	__method_Fixnum_inspect, @function
__method_Fixnum_inspect:
.LFBB244:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2083_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Fixnum_inspect", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2082, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2083_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2085_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Fixnum_inspect", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2082, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2085_else:
	# METHOD BODY:
	.stabn  68,0,73,.LM1238	
.LM1238:
	# callm :self.:to_s
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.to_s END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Fixnum_inspect, .-__method_Fixnum_inspect
.Lscope244:
	.stabs  "",36,0,0,.Lscope244-.LFBB244	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Fixnum_chr ##########################	
		
	.stabs  "__method_Fixnum_chr:F(0,0)",36,0,0,__method_Fixnum_chr	
.globl __method_Fixnum_chr
	.type	__method_Fixnum_chr, @function
__method_Fixnum_chr:
.LFBB245:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2088_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Fixnum_chr", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2087, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2088_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2090_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Fixnum_chr", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2087, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2090_else:
	# METHOD BODY:
	.stabn  68,0,77,.LM1239	
.LM1239:
	subl	$12, %esp
	addl	$3, %ebx
	.stabn  68,0,78,.LM1240	
.LM1240:
	subl	$12, %esp
	addl	$3, %ebx
	subl	$20, %esp
	movl	$2, (%esp)
	movl	$1, %ebx
	call	__alloc_leaf
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	subl	$32, %esp
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$2, 4(%esp)
	movl	$.L2092, %eax
	movl	%eax, 8(%esp)
	movl	4(%esi), %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	snprintf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	subl	$20, %esp
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	addl	$12, %esp
	addl	$12, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Fixnum_chr, .-__method_Fixnum_chr
.Lscope245:
	.stabs  "",36,0,0,.Lscope245-.LFBB245	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Fixnum___plus ########################	
		
	.stabs  "__method_Fixnum___plus:F(0,0)",36,0,0,__method_Fixnum___plus	
.globl __method_Fixnum___plus
	.type	__method_Fixnum___plus, @function
__method_Fixnum___plus:
.LFBB246:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$3, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2094_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Fixnum___plus", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2093, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2094_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2096_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Fixnum___plus", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2093, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2096_else:
	# METHOD BODY:
	.stabn  68,0,85,.LM1241	
.LM1241:
	.stabn  68,0,86,.LM1242	
.LM1242:
	subl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	movl	%eax, %edi
	# callm :other.:__get_raw
	pushl	%edi
	subl	$24, %esp
	movl	16(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____get_raw(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	popl	%edi
	# callm other.__get_raw END
	addl	%edi, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__int
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Fixnum___plus, .-__method_Fixnum___plus
.Lscope246:
	.stabs  "",36,0,0,.Lscope246-.LFBB246	
		
	########################################################################	
		
		
		
		
		
		
		
	####################### __method_Fixnum___minus ########################	
		
	.stabs  "__method_Fixnum___minus:F(0,0)",36,0,0,__method_Fixnum___minus	
.globl __method_Fixnum___minus
	.type	__method_Fixnum___minus, @function
__method_Fixnum___minus:
.LFBB247:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2099_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Fixnum___minus", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2098, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2099_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2101_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Fixnum___minus", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2098, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2101_else:
	# METHOD BODY:
	.stabn  68,0,89,.LM1243	
.LM1243:
	.stabn  68,0,90,.LM1244	
.LM1244:
	subl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	movl	%eax, %edi
	# callm :other.:__get_raw
	pushl	%edi
	subl	$24, %esp
	movl	16(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____get_raw(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	popl	%edi
	# callm other.__get_raw END
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__int
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Fixnum___minus, .-__method_Fixnum___minus
.Lscope247:
	.stabs  "",36,0,0,.Lscope247-.LFBB247	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Fixnum___le #########################	
		
	.stabs  "__method_Fixnum___le:F(0,0)",36,0,0,__method_Fixnum___le	
.globl __method_Fixnum___le
	.type	__method_Fixnum___le, @function
__method_Fixnum___le:
.LFBB248:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2104_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Fixnum___le", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2103, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2104_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2106_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Fixnum___le", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2103, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2106_else:
	# METHOD BODY:
	.stabn  68,0,93,.LM1245	
.LM1245:
	.stabn  68,0,94,.LM1246	
.LM1246:
	# if: [:le, :@value, [:callm, :other, :__get_raw]]
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	movl	%eax, %edi
	# callm :other.:__get_raw
	pushl	%edi
	subl	$24, %esp
	movl	16(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____get_raw(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	popl	%edi
	# callm other.__get_raw END
	cmpl	%eax, %edi
	setle	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2108_else
	# then: :true
	movl	true, %eax
	jmp	.L2109_endif
	# else: :false
.L2108_else:
	movl	false, %eax
.L2109_endif:
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Fixnum___le, .-__method_Fixnum___le
.Lscope248:
	.stabs  "",36,0,0,.Lscope248-.LFBB248	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Fixnum___eq #########################	
		
	.stabs  "__method_Fixnum___eq:F(0,0)",36,0,0,__method_Fixnum___eq	
.globl __method_Fixnum___eq
	.type	__method_Fixnum___eq, @function
__method_Fixnum___eq:
.LFBB249:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2111_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Fixnum___eq", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2110, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2111_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2113_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Fixnum___eq", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2110, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2113_else:
	# METHOD BODY:
	.stabn  68,0,97,.LM1247	
.LM1247:
	.stabn  68,0,98,.LM1248	
.LM1248:
	# if: [:callm, :other, :nil?]
	# callm :other.:nil?
	subl	$24, %esp
	movl	16(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__nil__Q(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm other.nil? END
	cmpl	%eax, nil
	je	.L2115_else
	cmpl	%eax, false
	je	.L2115_else
	# then: [:do, [:return, :false]]
	.stabn  68,0,99,.LM1249	
.LM1249:
	movl	false, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L2115_else:
	.stabn  68,0,100,.LM1250	
.LM1250:
	# if: [:callm, [:callm, :other, :is_a?, [:Numeric]], :!]
	# callm [:callm, :other, :is_a?, [:Numeric]].:!
	subl	$24, %esp
	# callm :other.:is_a?
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	Numeric, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__is_a__Q(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm other.is_a? END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____X(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :other, :is_a?, [:Numeric]].! END
	cmpl	%eax, nil
	je	.L2117_else
	cmpl	%eax, false
	je	.L2117_else
	# then: [:return, :false]
	movl	false, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L2117_else:
	.stabn  68,0,101,.LM1251	
.LM1251:
	# if: [:eq, :@value, [:callm, :other, :__get_raw]]
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	movl	%eax, %edi
	# callm :other.:__get_raw
	pushl	%edi
	subl	$24, %esp
	movl	16(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____get_raw(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	popl	%edi
	# callm other.__get_raw END
	cmpl	%eax, %edi
	sete	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2119_else
	# then: :true
	movl	true, %eax
	jmp	.L2120_endif
	# else: :false
.L2119_else:
	movl	false, %eax
.L2120_endif:
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Fixnum___eq, .-__method_Fixnum___eq
.Lscope249:
	.stabs  "",36,0,0,.Lscope249-.LFBB249	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Fixnum___X ##########################	
		
	.stabs  "__method_Fixnum___X:F(0,0)",36,0,0,__method_Fixnum___X	
.globl __method_Fixnum___X
	.type	__method_Fixnum___X, @function
__method_Fixnum___X:
.LFBB250:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2122_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Fixnum___X", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2121, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2122_else:
	# METHOD BODY:
	.stabn  68,0,106,.LM1252	
.LM1252:
	subl	$12, %esp
	addl	$3, %ebx
	subl	$24, %esp
	leal	16(%ebp), %eax
	movl	%eax, (%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$0, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	call	__splat_to_Array
	addl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	movl	false, %eax
	addl	$12, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Fixnum___X, .-__method_Fixnum___X
.Lscope250:
	.stabs  "",36,0,0,.Lscope250-.LFBB250	
		
	########################################################################	
		
		
		
		
		
		
		
	####################### __method_Fixnum___X__3d ########################	
		
	.stabs  "__method_Fixnum___X__3d:F(0,0)",36,0,0,__method_Fixnum___X__3d	
.globl __method_Fixnum___X__3d
	.type	__method_Fixnum___X__3d, @function
__method_Fixnum___X__3d:
.LFBB251:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2125_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Fixnum___X__3d", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2124, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2125_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2127_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Fixnum___X__3d", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2124, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2127_else:
	# METHOD BODY:
	.stabn  68,0,110,.LM1253	
.LM1253:
	.stabn  68,0,111,.LM1254	
.LM1254:
	# if: [:callm, [:callm, :other, :is_a?, [:Numeric]], :!]
	# callm [:callm, :other, :is_a?, [:Numeric]].:!
	subl	$24, %esp
	# callm :other.:is_a?
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	Numeric, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__is_a__Q(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm other.is_a? END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____X(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :other, :is_a?, [:Numeric]].! END
	cmpl	%eax, nil
	je	.L2129_else
	cmpl	%eax, false
	je	.L2129_else
	# then: [:return, :true]
	movl	true, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L2129_else:
	# callm :other.:to_i
	subl	$24, %esp
	movl	16(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_i(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm other.to_i END
	pushl	%eax
	popl	%eax
	movl	%eax, 16(%ebp)
	.stabn  68,0,112,.LM1255	
.LM1255:
	# if: [:ne, :@value, [:callm, :other, :__get_raw]]
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	movl	%eax, %ecx
	# callm :other.:__get_raw
	pushl	%ecx
	subl	$24, %esp
	movl	16(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____get_raw(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	popl	%ecx
	# callm other.__get_raw END
	cmpl	%eax, %ecx
	setne	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2131_else
	# then: :true
	movl	true, %eax
	jmp	.L2132_endif
	# else: :false
.L2131_else:
	movl	false, %eax
.L2132_endif:
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Fixnum___X__3d, .-__method_Fixnum___X__3d
.Lscope251:
	.stabs  "",36,0,0,.Lscope251-.LFBB251	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Fixnum___lt #########################	
		
	.stabs  "__method_Fixnum___lt:F(0,0)",36,0,0,__method_Fixnum___lt	
.globl __method_Fixnum___lt
	.type	__method_Fixnum___lt, @function
__method_Fixnum___lt:
.LFBB252:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2134_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Fixnum___lt", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2133, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2134_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2136_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Fixnum___lt", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2133, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2136_else:
	# METHOD BODY:
	.stabn  68,0,116,.LM1256	
.LM1256:
	.stabn  68,0,117,.LM1257	
.LM1257:
	# if: [:lt, :@value, [:callm, :other, :__get_raw]]
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	movl	%eax, %ecx
	# callm :other.:__get_raw
	pushl	%ecx
	subl	$24, %esp
	movl	16(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____get_raw(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	popl	%ecx
	# callm other.__get_raw END
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2138_else
	# then: :true
	movl	true, %eax
	jmp	.L2139_endif
	# else: :false
.L2138_else:
	movl	false, %eax
.L2139_endif:
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Fixnum___lt, .-__method_Fixnum___lt
.Lscope252:
	.stabs  "",36,0,0,.Lscope252-.LFBB252	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Fixnum___gt #########################	
		
	.stabs  "__method_Fixnum___gt:F(0,0)",36,0,0,__method_Fixnum___gt	
.globl __method_Fixnum___gt
	.type	__method_Fixnum___gt, @function
__method_Fixnum___gt:
.LFBB253:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2141_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Fixnum___gt", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2140, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2141_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2143_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Fixnum___gt", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2140, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2143_else:
	# METHOD BODY:
	.stabn  68,0,120,.LM1258	
.LM1258:
	.stabn  68,0,121,.LM1259	
.LM1259:
	# if: [:gt, :@value, [:callm, :other, :__get_raw]]
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	movl	%eax, %ecx
	# callm :other.:__get_raw
	pushl	%ecx
	subl	$24, %esp
	movl	16(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____get_raw(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	popl	%ecx
	# callm other.__get_raw END
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2145_else
	# then: :true
	movl	true, %eax
	jmp	.L2146_endif
	# else: :false
.L2145_else:
	movl	false, %eax
.L2146_endif:
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Fixnum___gt, .-__method_Fixnum___gt
.Lscope253:
	.stabs  "",36,0,0,.Lscope253-.LFBB253	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Fixnum___ge #########################	
		
	.stabs  "__method_Fixnum___ge:F(0,0)",36,0,0,__method_Fixnum___ge	
.globl __method_Fixnum___ge
	.type	__method_Fixnum___ge, @function
__method_Fixnum___ge:
.LFBB254:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2148_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Fixnum___ge", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2147, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2148_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2150_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Fixnum___ge", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2147, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2150_else:
	# METHOD BODY:
	.stabn  68,0,124,.LM1260	
.LM1260:
	.stabn  68,0,125,.LM1261	
.LM1261:
	# if: [:ge, :@value, [:callm, :other, :__get_raw]]
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	movl	%eax, %ecx
	# callm :other.:__get_raw
	pushl	%ecx
	subl	$24, %esp
	movl	16(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____get_raw(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	popl	%ecx
	# callm other.__get_raw END
	cmpl	%eax, %ecx
	setge	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2152_else
	# then: :true
	movl	true, %eax
	jmp	.L2153_endif
	# else: :false
.L2152_else:
	movl	false, %eax
.L2153_endif:
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Fixnum___ge, .-__method_Fixnum___ge
.Lscope254:
	.stabs  "",36,0,0,.Lscope254-.LFBB254	
		
	########################################################################	
		
		
		
		
		
		
		
	####################### __method_Fixnum___le__gt #######################	
		
	.stabs  "__method_Fixnum___le__gt:F(0,0)",36,0,0,__method_Fixnum___le__gt	
.globl __method_Fixnum___le__gt
	.type	__method_Fixnum___le__gt, @function
__method_Fixnum___le__gt:
.LFBB255:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2155_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Fixnum___le__gt", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2154, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2155_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2157_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Fixnum___le__gt", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2154, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2157_else:
	# METHOD BODY:
	.stabn  68,0,128,.LM1262	
.LM1262:
	.stabn  68,0,129,.LM1263	
.LM1263:
	# if: [:callm, [:callm, :other, :is_a?, [:Numeric]], :!]
	# callm [:callm, :other, :is_a?, [:Numeric]].:!
	subl	$24, %esp
	# callm :other.:is_a?
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	Numeric, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__is_a__Q(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm other.is_a? END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____X(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :other, :is_a?, [:Numeric]].! END
	cmpl	%eax, nil
	je	.L2159_else
	cmpl	%eax, false
	je	.L2159_else
	# then: [:return, :nil]
	movl	nil, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L2159_else:
	# if: [:callm, :self, :>, [:other]]
	# callm :self.:>
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____gt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.> END
	cmpl	%eax, nil
	je	.L2161_else
	cmpl	%eax, false
	je	.L2161_else
	# then: [:do, [:return, [:sexp, :__I1]]]
	.stabn  68,0,131,.LM1264	
.LM1264:
	movl	__I1, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L2161_else:
	.stabn  68,0,132,.LM1265	
.LM1265:
	# if: [:callm, :self, :<, [:other]]
	# callm :self.:<
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.< END
	cmpl	%eax, nil
	je	.L2163_else
	cmpl	%eax, false
	je	.L2163_else
	# then: [:do, [:return, [:sexp, :__Ineg1]]]
	.stabn  68,0,134,.LM1266	
.LM1266:
	movl	__Ineg1, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L2163_else:
	.stabn  68,0,135,.LM1267	
.LM1267:
	movl	__I0, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Fixnum___le__gt, .-__method_Fixnum___le__gt
.Lscope255:
	.stabs  "",36,0,0,.Lscope255-.LFBB255	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Fixnum_div ##########################	
		
	.stabs  "__method_Fixnum_div:F(0,0)",36,0,0,__method_Fixnum_div	
.globl __method_Fixnum_div
	.type	__method_Fixnum_div, @function
__method_Fixnum_div:
.LFBB256:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2166_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Fixnum_div", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2165, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2166_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2168_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Fixnum_div", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2165, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2168_else:
	# METHOD BODY:
	.stabn  68,0,139,.LM1268	
.LM1268:
	.stabn  68,0,140,.LM1269	
.LM1269:
	subl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	pushl	%eax
	# callm :other.:__get_raw
	subl	$24, %esp
	movl	16(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____get_raw(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm other.__get_raw END
	movl	%eax, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__int
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Fixnum_div, .-__method_Fixnum_div
.Lscope256:
	.stabs  "",36,0,0,.Lscope256-.LFBB256	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Fixnum_mul ##########################	
		
	.stabs  "__method_Fixnum_mul:F(0,0)",36,0,0,__method_Fixnum_mul	
.globl __method_Fixnum_mul
	.type	__method_Fixnum_mul, @function
__method_Fixnum_mul:
.LFBB257:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2171_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Fixnum_mul", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2170, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2171_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2173_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Fixnum_mul", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2170, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2173_else:
	# METHOD BODY:
	.stabn  68,0,143,.LM1270	
.LM1270:
	.stabn  68,0,144,.LM1271	
.LM1271:
	subl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	movl	%eax, %edi
	# callm :other.:__get_raw
	pushl	%edi
	subl	$24, %esp
	movl	16(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____get_raw(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	popl	%edi
	# callm other.__get_raw END
	imull	%edi, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__int
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Fixnum_mul, .-__method_Fixnum_mul
.Lscope257:
	.stabs  "",36,0,0,.Lscope257-.LFBB257	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Fixnum___mul #########################	
		
	.stabs  "__method_Fixnum___mul:F(0,0)",36,0,0,__method_Fixnum___mul	
.globl __method_Fixnum___mul
	.type	__method_Fixnum___mul, @function
__method_Fixnum___mul:
.LFBB258:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2176_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Fixnum___mul", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2175, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2176_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2178_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Fixnum___mul", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2175, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2178_else:
	# METHOD BODY:
	.stabn  68,0,150,.LM1272	
.LM1272:
	.stabn  68,0,151,.LM1273	
.LM1273:
	# callm :self.:mul
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__mul(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.mul END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Fixnum___mul, .-__method_Fixnum___mul
.Lscope258:
	.stabs  "",36,0,0,.Lscope258-.LFBB258	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Fixnum___div #########################	
		
	.stabs  "__method_Fixnum___div:F(0,0)",36,0,0,__method_Fixnum___div	
.globl __method_Fixnum___div
	.type	__method_Fixnum___div, @function
__method_Fixnum___div:
.LFBB259:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2181_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Fixnum___div", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2180, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2181_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2183_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Fixnum___div", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2180, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2183_else:
	# METHOD BODY:
	.stabn  68,0,154,.LM1274	
.LM1274:
	.stabn  68,0,155,.LM1275	
.LM1275:
	# callm :self.:div
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__div(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.div END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Fixnum___div, .-__method_Fixnum___div
.Lscope259:
	.stabs  "",36,0,0,.Lscope259-.LFBB259	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Fixnum_ord ##########################	
		
	.stabs  "__method_Fixnum_ord:F(0,0)",36,0,0,__method_Fixnum_ord	
.globl __method_Fixnum_ord
	.type	__method_Fixnum_ord, @function
__method_Fixnum_ord:
.LFBB260:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2186_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Fixnum_ord", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2185, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2186_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2188_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Fixnum_ord", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2185, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2188_else:
	# METHOD BODY:
	.stabn  68,0,158,.LM1276	
.LM1276:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, %eax
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Fixnum_ord, .-__method_Fixnum_ord
.Lscope260:
	.stabs  "",36,0,0,.Lscope260-.LFBB260	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Fixnum_times #########################	
		
	.stabs  "__method_Fixnum_times:F(0,0)",36,0,0,__method_Fixnum_times	
.globl __method_Fixnum_times
	.type	__method_Fixnum_times, @function
__method_Fixnum_times:
.LFBB261:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2191_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Fixnum_times", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2190, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2191_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2193_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Fixnum_times", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2190, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2193_else:
	# METHOD BODY:
	.stabn  68,0,162,.LM1277	
.LM1277:
	subl	$12, %esp
	addl	$3, %ebx
	.stabn  68,0,163,.LM1278	
.LM1278:
	movl	__I0, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
.L2196:
	# callm :i.:<
	subl	$28, %esp
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm i.< END
	cmpl	%eax, nil
	je	.L2195
	cmpl	%eax, false
	je	.L2195
	# yield
	# callm :__closure__.:call
	subl	$24, %esp
	movl	12(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__call(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm __closure__.call END
	.stabn  68,0,165,.LM1279	
.LM1279:
	# callm :i.:+
	subl	$28, %esp
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm i.+ END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	jmp	.L2196
.L2195:
	movl	nil, %eax
	addl	$12, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Fixnum_times, .-__method_Fixnum_times
.Lscope261:
	.stabs  "",36,0,0,.Lscope261-.LFBB261	
		
	########################################################################	
		
		
		
		
		
		
		
	################################ __int #################################	
		
	.stabs  "__int:F(0,0)",36,0,0,__int	
.globl __int
	.type	__int, @function
__int:
.LFBB262:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# METHOD BODY:
	subl	$12, %esp
	addl	$3, %ebx
	# if: [:and, [:ge, :val, 0], [:lt, :val, :FixNum_cache_size]]
	# if: [:ge, :val, 0]
	movl	8(%ebp), %eax
	movl	%eax, %edx
	movl	$0, %eax
	cmpl	%eax, %edx
	setge	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2198_else
	# then: [:lt, :val, :FixNum_cache_size]
	movl	8(%ebp), %eax
	movl	%eax, %edi
	movl	FixNum_cache_size, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	# else: nil
.L2198_else:
	testl	%eax, %eax
	je	.L2200_else
	# then: [:do, [:assign, :num, [:add, :FixNum_cache, [:mul, :val, 8]]], [:if, [:eq, [:index, :num, 0], 0], [:do, [:assign, [:index, :num, 0], :Fixnum], [:callm, :num, :__set_raw, [:val]], [:return, :num]]], [:return, :num]]
	movl	FixNum_cache, %eax
	movl	%eax, %ecx
	movl	8(%ebp), %eax
	movl	%eax, %edx
	movl	$8, %eax
	imull	%edx, %eax
	addl	%ecx, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# if: [:eq, [:index, :num, 0], 0]
	movl	-12(%ebp), %eax
	movl	%eax, %edi
	movl	(%edi), %eax
	movl	%eax, %edx
	movl	$0, %eax
	cmpl	%eax, %edx
	sete	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2201_else
	# then: [:do, [:assign, [:index, :num, 0], :Fixnum], [:callm, :num, :__set_raw, [:val]], [:return, :num]]
	movl	Fixnum, %eax
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	# callm :num.:__set_raw
	subl	$28, %esp
	movl	-12(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	8(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____set_raw(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm num.__set_raw END
	movl	-12(%ebp), %eax
	movl	-4(%ebp), %ebx
	# [:global, :self, :esi]
	movl	self, %esi
	leave	
	ret	
	# else: nil
.L2201_else:
	movl	-12(%ebp), %eax
	movl	-4(%ebp), %ebx
	# [:global, :self, :esi]
	movl	self, %esi
	leave	
	ret	
	# else: nil
.L2200_else:
	# callm :Fixnum.:allocate
	subl	$24, %esp
	movl	Fixnum, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__allocate(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm Fixnum.allocate END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# callm :num.:__set_raw
	subl	$28, %esp
	movl	-12(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	8(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____set_raw(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm num.__set_raw END
	movl	-12(%ebp), %eax
	movl	-4(%ebp), %ebx
	# [:global, :self, :esi]
	movl	self, %esi
	leave	
	ret	
	addl	$12, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__int, .-__int
.Lscope262:
	.stabs  "",36,0,0,.Lscope262-.LFBB262	
		
	########################################################################	
		
		
		
		
		
		
		
	###################### __method_Symbol_initialize ######################	
		
	.stabs  "__method_Symbol_initialize:F(0,0)",36,0,0,__method_Symbol_initialize	
.globl __method_Symbol_initialize
	.type	__method_Symbol_initialize, @function
__method_Symbol_initialize:
.LFBB263:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2205_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Symbol_initialize", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2204, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2205_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2207_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Symbol_initialize", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2204, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2207_else:
	# METHOD BODY:
	.stabn  68,0,24,.LM1280	
.LM1280:
	.stabn  68,0,25,.LM1281	
.LM1281:
	movl	16(%ebp), %eax
	pushl	%eax
	popl	%eax
	pushl	%eax
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ecx
	movl	%ecx, 4(%esi)
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Symbol_initialize, .-__method_Symbol_initialize
.Lscope263:
	.stabs  "",36,0,0,.Lscope263-.LFBB263	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Symbol_eql__Q ########################	
		
	.stabs  "__method_Symbol_eql__Q:F(0,0)",36,0,0,__method_Symbol_eql__Q	
.globl __method_Symbol_eql__Q
	.type	__method_Symbol_eql__Q, @function
__method_Symbol_eql__Q:
.LFBB264:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2210_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Symbol_eql__Q", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2209, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2210_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2212_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Symbol_eql__Q", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2209, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2212_else:
	# METHOD BODY:
	.stabn  68,0,28,.LM1282	
.LM1282:
	.stabn  68,0,29,.LM1283	
.LM1283:
	# callm :self.:==
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.== END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Symbol_eql__Q, .-__method_Symbol_eql__Q
.Lscope264:
	.stabs  "",36,0,0,.Lscope264-.LFBB264	
		
	########################################################################	
		
		
		
		
		
		
		
	####################### __method_Symbol___le__gt #######################	
		
	.stabs  "__method_Symbol___le__gt:F(0,0)",36,0,0,__method_Symbol___le__gt	
.globl __method_Symbol___le__gt
	.type	__method_Symbol___le__gt, @function
__method_Symbol___le__gt:
.LFBB265:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2215_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Symbol___le__gt", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2214, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2215_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2217_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Symbol___le__gt", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2214, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2217_else:
	# METHOD BODY:
	.stabn  68,0,32,.LM1284	
.LM1284:
	.stabn  68,0,33,.LM1285	
.LM1285:
	# if: [:call, :eql?, [:other]]
	# callm :self.:eql?
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__eql__Q(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.eql? END
	cmpl	%eax, nil
	je	.L2219_else
	cmpl	%eax, false
	je	.L2219_else
	# then: [:do, [:return, [:sexp, :__I0]]]
	.stabn  68,0,34,.LM1286	
.LM1286:
	movl	__I0, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L2219_else:
	.stabn  68,0,35,.LM1287	
.LM1287:
	# callm :to_s.:<=>
	subl	$28, %esp
	# callm :self.:to_s
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.to_s END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :other.:to_s
	subl	$24, %esp
	movl	16(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm other.to_s END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____le__gt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm to_s.<=> END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Symbol___le__gt, .-__method_Symbol___le__gt
.Lscope265:
	.stabs  "",36,0,0,.Lscope265-.LFBB265	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Symbol_to_s #########################	
		
	.stabs  "__method_Symbol_to_s:F(0,0)",36,0,0,__method_Symbol_to_s	
.globl __method_Symbol_to_s
	.type	__method_Symbol_to_s, @function
__method_Symbol_to_s:
.LFBB266:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2222_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Symbol_to_s", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2221, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2222_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2224_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Symbol_to_s", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2221, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2224_else:
	# METHOD BODY:
	.stabn  68,0,39,.LM1288	
.LM1288:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Symbol_to_s, .-__method_Symbol_to_s
.Lscope266:
	.stabs  "",36,0,0,.Lscope266-.LFBB266	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Symbol_to_sym ########################	
		
	.stabs  "__method_Symbol_to_sym:F(0,0)",36,0,0,__method_Symbol_to_sym	
.globl __method_Symbol_to_sym
	.type	__method_Symbol_to_sym, @function
__method_Symbol_to_sym:
.LFBB267:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2227_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Symbol_to_sym", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2226, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2227_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2229_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Symbol_to_sym", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2226, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2229_else:
	# METHOD BODY:
	.stabn  68,0,43,.LM1289	
.LM1289:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, %eax
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Symbol_to_sym, .-__method_Symbol_to_sym
.Lscope267:
	.stabs  "",36,0,0,.Lscope267-.LFBB267	
		
	########################################################################	
		
		
		
		
		
		
		
	####################### __method_Symbol_inspect ########################	
		
	.stabs  "__method_Symbol_inspect:F(0,0)",36,0,0,__method_Symbol_inspect	
.globl __method_Symbol_inspect
	.type	__method_Symbol_inspect, @function
__method_Symbol_inspect:
.LFBB268:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2232_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Symbol_inspect", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2231, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2232_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2234_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Symbol_inspect", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2231, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2234_else:
	# METHOD BODY:
	.stabn  68,0,47,.LM1290	
.LM1290:
	subl	$12, %esp
	addl	$3, %ebx
	.stabn  68,0,57,.LM1291	
.LM1291:
	# if: [:callm, :@name, :==, [[:sexp, [:call, :__get_string, :".L32"]]]]
	# callm :@name.:==
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	subl	$20, %esp
	movl	$.L32, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @name.== END
	cmpl	%eax, nil
	je	.L2236_else
	cmpl	%eax, false
	je	.L2236_else
	# then: [:return, [:sexp, [:call, :__get_string, :".L33"]]]
	subl	$20, %esp
	movl	$.L33, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L2236_else:
	# if: [:callm, :@name, :==, [[:sexp, [:call, :__get_string, :".L34"]]]]
	# callm :@name.:==
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	subl	$20, %esp
	movl	$.L34, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @name.== END
	cmpl	%eax, nil
	je	.L2238_else
	cmpl	%eax, false
	je	.L2238_else
	# then: [:return, [:sexp, [:call, :__get_string, :".L35"]]]
	subl	$20, %esp
	movl	$.L35, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L2238_else:
	.stabn  68,0,58,.LM1292	
.LM1292:
	# if: [:callm, :@name, :==, [[:sexp, [:call, :__get_string, :".L36"]]]]
	# callm :@name.:==
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	subl	$20, %esp
	movl	$.L36, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @name.== END
	cmpl	%eax, nil
	je	.L2240_else
	cmpl	%eax, false
	je	.L2240_else
	# then: [:return, [:sexp, [:call, :__get_string, :".L37"]]]
	subl	$20, %esp
	movl	$.L37, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L2240_else:
	.stabn  68,0,59,.LM1293	
.LM1293:
	# if: [:callm, :@name, :==, [[:sexp, [:call, :__get_string, :".L38"]]]]
	# callm :@name.:==
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	subl	$20, %esp
	movl	$.L38, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @name.== END
	cmpl	%eax, nil
	je	.L2242_else
	cmpl	%eax, false
	je	.L2242_else
	# then: [:return, [:sexp, [:call, :__get_string, :".L39"]]]
	subl	$20, %esp
	movl	$.L39, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L2242_else:
	.stabn  68,0,60,.LM1294	
.LM1294:
	# if: [:callm, :@name, :==, [[:sexp, [:call, :__get_string, :".L40"]]]]
	# callm :@name.:==
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	subl	$20, %esp
	movl	$.L40, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @name.== END
	cmpl	%eax, nil
	je	.L2244_else
	cmpl	%eax, false
	je	.L2244_else
	# then: [:return, [:sexp, [:call, :__get_string, :".L41"]]]
	subl	$20, %esp
	movl	$.L41, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L2244_else:
	.stabn  68,0,61,.LM1295	
.LM1295:
	# if: [:callm, :@name, :==, [[:sexp, [:call, :__get_string, :".L42"]]]]
	# callm :@name.:==
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	subl	$20, %esp
	movl	$.L42, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @name.== END
	cmpl	%eax, nil
	je	.L2246_else
	cmpl	%eax, false
	je	.L2246_else
	# then: [:return, [:sexp, [:call, :__get_string, :".L43"]]]
	subl	$20, %esp
	movl	$.L43, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L2246_else:
	.stabn  68,0,62,.LM1296	
.LM1296:
	# if: [:callm, :@name, :==, [[:sexp, [:call, :__get_string, :".L4"]]]]
	# callm :@name.:==
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	subl	$20, %esp
	movl	$.L4, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @name.== END
	cmpl	%eax, nil
	je	.L2248_else
	cmpl	%eax, false
	je	.L2248_else
	# then: [:return, [:sexp, [:call, :__get_string, :".L44"]]]
	subl	$20, %esp
	movl	$.L44, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L2248_else:
	.stabn  68,0,63,.LM1297	
.LM1297:
	# if: [:callm, :@name, :==, [[:sexp, [:call, :__get_string, :".L45"]]]]
	# callm :@name.:==
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	subl	$20, %esp
	movl	$.L45, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @name.== END
	cmpl	%eax, nil
	je	.L2250_else
	cmpl	%eax, false
	je	.L2250_else
	# then: [:return, [:sexp, [:call, :__get_string, :".L46"]]]
	subl	$20, %esp
	movl	$.L46, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L2250_else:
	.stabn  68,0,64,.LM1298	
.LM1298:
	# if: [:callm, :@name, :==, [[:sexp, [:call, :__get_string, :".L47"]]]]
	# callm :@name.:==
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	subl	$20, %esp
	movl	$.L47, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @name.== END
	cmpl	%eax, nil
	je	.L2252_else
	cmpl	%eax, false
	je	.L2252_else
	# then: [:return, [:sexp, [:call, :__get_string, :".L48"]]]
	subl	$20, %esp
	movl	$.L48, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L2252_else:
	.stabn  68,0,65,.LM1299	
.LM1299:
	# if: [:callm, :@name, :==, [[:sexp, [:call, :__get_string, :".L49"]]]]
	# callm :@name.:==
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	subl	$20, %esp
	movl	$.L49, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @name.== END
	cmpl	%eax, nil
	je	.L2254_else
	cmpl	%eax, false
	je	.L2254_else
	# then: [:return, [:sexp, [:call, :__get_string, :".L50"]]]
	subl	$20, %esp
	movl	$.L50, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L2254_else:
	.stabn  68,0,66,.LM1300	
.LM1300:
	# if: [:callm, :@name, :==, [[:sexp, [:call, :__get_string, :".L31"]]]]
	# callm :@name.:==
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	subl	$20, %esp
	movl	$.L31, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @name.== END
	cmpl	%eax, nil
	je	.L2256_else
	cmpl	%eax, false
	je	.L2256_else
	# then: [:return, [:sexp, [:call, :__get_string, :".L51"]]]
	subl	$20, %esp
	movl	$.L51, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L2256_else:
	.stabn  68,0,67,.LM1301	
.LM1301:
	# if: [:callm, :@name, :==, [[:sexp, [:call, :__get_string, :".L24"]]]]
	# callm :@name.:==
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	subl	$20, %esp
	movl	$.L24, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @name.== END
	cmpl	%eax, nil
	je	.L2258_else
	cmpl	%eax, false
	je	.L2258_else
	# then: [:return, [:sexp, [:call, :__get_string, :".L52"]]]
	subl	$20, %esp
	movl	$.L52, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L2258_else:
	.stabn  68,0,68,.LM1302	
.LM1302:
	# if: [:callm, :@name, :==, [[:sexp, [:call, :__get_string, :".L53"]]]]
	# callm :@name.:==
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	subl	$20, %esp
	movl	$.L53, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @name.== END
	cmpl	%eax, nil
	je	.L2260_else
	cmpl	%eax, false
	je	.L2260_else
	# then: [:return, [:sexp, [:call, :__get_string, :".L54"]]]
	subl	$20, %esp
	movl	$.L54, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	# else: nil
.L2260_else:
	.stabn  68,0,69,.LM1303	
.LM1303:
	# callm [:callm, :@name, :[], [[:sexp, :__I0]]].:ord
	subl	$24, %esp
	# callm :@name.:[]
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I0, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @name.[] END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__ord(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :@name, :[], [[:sexp, :__I0]]].ord END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	.stabn  68,0,71,.LM1304	
.LM1304:
	# if: [:or, [:and, [:callm, :o, :>=, [[:sexp, :__I97]]], [:callm, :o, :<=, [[:sexp, :__I122]]]], [:or, [:and, [:callm, :o, :>=, [[:sexp, :__I64]]], [:callm, :o, :<=, [[:sexp, :__I91]]]], [:or, [:callm, :o, :==, [[:sexp, :__I42]]], [:or, [:callm, :o, :==, [[:sexp, :__I43]]], [:or, [:callm, :o, :==, [[:sexp, :__I95]]], [:callm, :o, :==, [[:sexp, :__I33]]]]]]]]
	# compile_or: [:and, [:callm, :o, :>=, [[:sexp, :__I97]]], [:callm, :o, :<=, [[:sexp, :__I122]]]] || [:or, [:and, [:callm, :o, :>=, [[:sexp, :__I64]]], [:callm, :o, :<=, [[:sexp, :__I91]]]], [:or, [:callm, :o, :==, [[:sexp, :__I42]]], [:or, [:callm, :o, :==, [[:sexp, :__I43]]], [:or, [:callm, :o, :==, [[:sexp, :__I95]]], [:callm, :o, :==, [[:sexp, :__I33]]]]]]]
	# if: [:callm, :o, :>=, [[:sexp, :__I97]]]
	# callm :o.:>=
	subl	$28, %esp
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	__I97, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____ge(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm o.>= END
	cmpl	%eax, nil
	je	.L2262_else
	cmpl	%eax, false
	je	.L2262_else
	# then: [:callm, :o, :<=, [[:sexp, :__I122]]]
	# callm :o.:<=
	subl	$28, %esp
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	__I122, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____le(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm o.<= END
	# else: nil
.L2262_else:
	cmpl	%eax, nil
	je	.L2264_or
	cmpl	%eax, false
	je	.L2264_or
	jmp	.L2265_end_or
	# .. or:
.L2264_or:
	# compile_or: [:and, [:callm, :o, :>=, [[:sexp, :__I64]]], [:callm, :o, :<=, [[:sexp, :__I91]]]] || [:or, [:callm, :o, :==, [[:sexp, :__I42]]], [:or, [:callm, :o, :==, [[:sexp, :__I43]]], [:or, [:callm, :o, :==, [[:sexp, :__I95]]], [:callm, :o, :==, [[:sexp, :__I33]]]]]]
	# if: [:callm, :o, :>=, [[:sexp, :__I64]]]
	# callm :o.:>=
	subl	$28, %esp
	# [:lvar, 1, :edx]
	movl	-12(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	__I64, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____ge(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm o.>= END
	cmpl	%eax, nil
	je	.L2266_else
	cmpl	%eax, false
	je	.L2266_else
	# then: [:callm, :o, :<=, [[:sexp, :__I91]]]
	# callm :o.:<=
	subl	$28, %esp
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	__I91, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____le(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm o.<= END
	# else: nil
.L2266_else:
	cmpl	%eax, nil
	je	.L2268_or
	cmpl	%eax, false
	je	.L2268_or
	jmp	.L2269_end_or
	# .. or:
.L2268_or:
	# compile_or: [:callm, :o, :==, [[:sexp, :__I42]]] || [:or, [:callm, :o, :==, [[:sexp, :__I43]]], [:or, [:callm, :o, :==, [[:sexp, :__I95]]], [:callm, :o, :==, [[:sexp, :__I33]]]]]
	# callm :o.:==
	subl	$28, %esp
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	__I42, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm o.== END
	cmpl	%eax, nil
	je	.L2270_or
	cmpl	%eax, false
	je	.L2270_or
	jmp	.L2271_end_or
	# .. or:
.L2270_or:
	# compile_or: [:callm, :o, :==, [[:sexp, :__I43]]] || [:or, [:callm, :o, :==, [[:sexp, :__I95]]], [:callm, :o, :==, [[:sexp, :__I33]]]]
	# callm :o.:==
	subl	$28, %esp
	# [:lvar, 1, :edx]
	movl	-12(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	__I43, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm o.== END
	cmpl	%eax, nil
	je	.L2272_or
	cmpl	%eax, false
	je	.L2272_or
	jmp	.L2273_end_or
	# .. or:
.L2272_or:
	# compile_or: [:callm, :o, :==, [[:sexp, :__I95]]] || [:callm, :o, :==, [[:sexp, :__I33]]]
	# callm :o.:==
	subl	$28, %esp
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	__I95, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm o.== END
	cmpl	%eax, nil
	je	.L2274_or
	cmpl	%eax, false
	je	.L2274_or
	jmp	.L2275_end_or
	# .. or:
.L2274_or:
	# callm :o.:==
	subl	$28, %esp
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	__I33, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm o.== END
.L2275_end_or:
.L2273_end_or:
.L2271_end_or:
.L2269_end_or:
.L2265_end_or:
	cmpl	%eax, nil
	je	.L2276_else
	cmpl	%eax, false
	je	.L2276_else
	# then: [:do, [:callm, [:callm, [:sexp, [:call, :__get_string, :".L3"]], :to_s], :concat, [[:callm, :to_s, :to_s]]]]
	.stabn  68,0,75,.LM1305	
.LM1305:
	# callm [:callm, [:sexp, [:call, :__get_string, :".L3"]], :to_s].:concat
	subl	$28, %esp
	# callm [:sexp, [:call, :__get_string, :".L3"]].:to_s
	subl	$24, %esp
	subl	$20, %esp
	movl	$.L3, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:sexp, [:call, :__get_string, :".L3"]].to_s END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :to_s.:to_s
	subl	$24, %esp
	# callm :self.:to_s
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.to_s END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm to_s.to_s END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__concat(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:sexp, [:call, :__get_string, :".L3"]], :to_s].concat END
	jmp	.L2277_endif
	# else: [:do, [:callm, [:callm, [:sexp, [:call, :__get_string, :".L3"]], :to_s], :concat, [[:callm, [:callm, :to_s, :inspect], :to_s]]]]
.L2276_else:
	.stabn  68,0,77,.LM1306	
.LM1306:
	# callm [:callm, [:sexp, [:call, :__get_string, :".L3"]], :to_s].:concat
	subl	$28, %esp
	# callm [:sexp, [:call, :__get_string, :".L3"]].:to_s
	subl	$24, %esp
	subl	$20, %esp
	movl	$.L3, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:sexp, [:call, :__get_string, :".L3"]].to_s END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm [:callm, :to_s, :inspect].:to_s
	subl	$24, %esp
	# callm :to_s.:inspect
	subl	$24, %esp
	# callm :self.:to_s
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.to_s END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__inspect(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm to_s.inspect END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :to_s, :inspect].to_s END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__concat(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:sexp, [:call, :__get_string, :".L3"]], :to_s].concat END
.L2277_endif:
	addl	$12, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Symbol_inspect, .-__method_Symbol_inspect
.Lscope268:
	.stabs  "",36,0,0,.Lscope268-.LFBB268	
		
	########################################################################	
		
		
		
		
		
		
		
	######################### __method_Symbol_hash #########################	
		
	.stabs  "__method_Symbol_hash:F(0,0)",36,0,0,__method_Symbol_hash	
.globl __method_Symbol_hash
	.type	__method_Symbol_hash, @function
__method_Symbol_hash:
.LFBB269:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2279_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Symbol_hash", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2278, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2279_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2281_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Symbol_hash", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2278, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2281_else:
	# METHOD BODY:
	.stabn  68,0,81,.LM1307	
.LM1307:
	.stabn  68,0,82,.LM1308	
.LM1308:
	# callm :to_s.:hash
	subl	$24, %esp
	# callm :self.:to_s
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.to_s END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__hash(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm to_s.hash END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Symbol_hash, .-__method_Symbol_hash
.Lscope269:
	.stabs  "",36,0,0,.Lscope269-.LFBB269	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Symbol___NDX #########################	
		
	.stabs  "__method_Symbol___NDX:F(0,0)",36,0,0,__method_Symbol___NDX	
.globl __method_Symbol___NDX
	.type	__method_Symbol___NDX, @function
__method_Symbol___NDX:
.LFBB270:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2284_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Symbol___NDX", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2283, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2284_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2286_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Symbol___NDX", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2283, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2286_else:
	# METHOD BODY:
	.stabn  68,0,85,.LM1309	
.LM1309:
	.stabn  68,0,86,.LM1310	
.LM1310:
	# callm :to_s.:[]
	subl	$28, %esp
	# callm :self.:to_s
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.to_s END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm to_s.[] END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Symbol___NDX, .-__method_Symbol___NDX
.Lscope270:
	.stabs  "",36,0,0,.Lscope270-.LFBB270	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method____get_symbol ########################	
		
	.stabs  "__method____get_symbol:F(0,0)",36,0,0,__method____get_symbol	
.globl __method____get_symbol
	.type	__method____get_symbol, @function
__method____get_symbol:
.LFBB271:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2289_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method____get_symbol", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2288, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2289_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2291_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method____get_symbol", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2288, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2291_else:
	# METHOD BODY:
	.stabn  68,0,93,.LM1311	
.LM1311:
	subl	$12, %esp
	addl	$3, %ebx
	.stabn  68,0,94,.LM1312	
.LM1312:
	# callm :@@symbols.:[]
	subl	$28, %esp
	movl	__classvar__Symbol__symbols, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	movl	%edi, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @@symbols.[] END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# if: [:callm, :sym, :!]
	# callm :sym.:!
	subl	$24, %esp
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____X(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm sym.! END
	cmpl	%eax, nil
	je	.L2293_else
	cmpl	%eax, false
	je	.L2293_else
	# then: [:do, [:assign, :sym, [:callm, :Symbol, :new, [:name]]], [:callm, :@@symbols, :[]=, [:name, :sym]]]
	.stabn  68,0,96,.LM1313	
.LM1313:
	# callm :Symbol.:new
	subl	$28, %esp
	movl	Symbol, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# [:arg, 2, :edx]
	movl	16(%ebp), %edx
	movl	%edx, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__new(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm Symbol.new END
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# callm :@@symbols.:[]=
	subl	$32, %esp
	movl	__classvar__Symbol__symbols, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	movl	%edi, 8(%esp)
	# [:lvar, 1, :ecx]
	movl	-12(%ebp), %ecx
	movl	%ecx, 12(%esp)
	movl	$4, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX__3d(%eax)
	# Evicting self
	# Static adj: 32
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @@symbols.[]= END
	# else: nil
.L2293_else:
	# [:lvar, 1, :edx]
	movl	-12(%ebp), %edx
	movl	%edx, %eax
	addl	$12, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method____get_symbol, .-__method____get_symbol
.Lscope271:
	.stabs  "",36,0,0,.Lscope271-.LFBB271	
		
	########################################################################	
		
		
		
		
		
		
		
	############################# __get_symbol #############################	
		
	.stabs  "__get_symbol:F(0,0)",36,0,0,__get_symbol	
.globl __get_symbol
	.type	__get_symbol, @function
__get_symbol:
.LFBB272:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# METHOD BODY:
	# callm :Symbol.:__get_symbol
	subl	$28, %esp
	movl	Symbol, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	subl	$20, %esp
	movl	8(%ebp), %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____get_symbol(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm Symbol.__get_symbol END
	# Reloading self if evicted:
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	leave	
	ret	
	.size	__get_symbol, .-__get_symbol
.Lscope272:
	.stabs  "",36,0,0,.Lscope272-.LFBB272	
		
	########################################################################	
		
		
		
		
		
		
		
	####################### __method__method_to_voff #######################	
		
	.stabs  "__method__method_to_voff:F(0,0)",36,0,0,__method__method_to_voff	
.globl __method__method_to_voff
	.type	__method__method_to_voff, @function
__method__method_to_voff:
.LFBB273:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2297_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method__method_to_voff", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2296, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2297_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2299_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method__method_to_voff", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2296, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2299_else:
	# METHOD BODY:
	.stabn  68,0,10,.LM1314	
.LM1314:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	12(%esi), %eax
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method__method_to_voff, .-__method__method_to_voff
.Lscope273:
	.stabs  "",36,0,0,.Lscope273-.LFBB273	
		
	########################################################################	
		
		
		
		
		
		
		
	#################### __method_Class_method_missing #####################	
		
	.stabs  "__method_Class_method_missing:F(0,0)",36,0,0,__method_Class_method_missing	
.globl __method_Class_method_missing
	.type	__method_Class_method_missing, @function
__method_Class_method_missing:
.LFBB274:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2302_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Class_method_missing", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2301, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2302_else:
	# METHOD BODY:
	.stabn  68,0,14,.LM1315	
.LM1315:
	subl	$12, %esp
	addl	$3, %ebx
	subl	$24, %esp
	leal	20(%ebp), %eax
	movl	%eax, (%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$1, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	call	__splat_to_Array
	addl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	.stabn  68,0,15,.LM1316	
.LM1316:
	# if: :sym
	# [:arg, 2, :ecx]
	movl	16(%ebp), %ecx
	movl	%ecx, %eax
	cmpl	%eax, nil
	je	.L2304_else
	cmpl	%eax, false
	je	.L2304_else
	# then: [:printf, "WARNING:    Method: '%s'\n", [:callm, [:callm, :sym, :to_s], :__get_raw]]
	subl	$24, %esp
	movl	$.L2305, %eax
	movl	%eax, (%esp)
	# callm [:callm, :sym, :to_s].:__get_raw
	subl	$24, %esp
	# callm :sym.:to_s
	subl	$24, %esp
	# [:arg, 2, :edx]
	movl	16(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm sym.to_s END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____get_raw(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :sym, :to_s].__get_raw END
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	call	printf
	addl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	# else: nil
.L2304_else:
	subl	$24, %esp
	movl	$.L2307, %eax
	movl	%eax, (%esp)
	# [:arg, 2, :edi]
	movl	16(%ebp), %edi
	movl	%edi, 4(%esp)
	movl	$2, %ebx
	call	printf
	addl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	.stabn  68,0,16,.LM1317	
.LM1317:
	subl	$24, %esp
	movl	$.L2308, %eax
	movl	%eax, (%esp)
	# callm [:callm, :self, :name].:__get_raw
	subl	$24, %esp
	# callm :self.:name
	subl	$24, %esp
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__name(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.name END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____get_raw(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :self, :name].__get_raw END
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	call	printf
	addl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	.stabn  68,0,17,.LM1318	
.LM1318:
	subl	$20, %esp
	movl	$1, (%esp)
	movl	$1, %ebx
	call	exit
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	addl	$12, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Class_method_missing, .-__method_Class_method_missing
.Lscope274:
	.stabs  "",36,0,0,.Lscope274-.LFBB274	
		
	########################################################################	
		
		
		
		
		
		
		
	################### __method_Class___send_for_obj__ ####################	
		
	.stabs  "__method_Class___send_for_obj__:F(0,0)",36,0,0,__method_Class___send_for_obj__	
.globl __method_Class___send_for_obj__
	.type	__method_Class___send_for_obj__, @function
__method_Class___send_for_obj__:
.LFBB275:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$4, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2310_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Class___send_for_obj__", 2, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2309, %eax
	movl	%eax, 4(%esp)
	movl	$2, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2310_else:
	# METHOD BODY:
	.stabn  68,0,22,.LM1319	
.LM1319:
	subl	$20, %esp
	addl	$5, %ebx
	subl	$24, %esp
	leal	24(%ebp), %eax
	movl	%eax, (%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	call	__splat_to_Array
	addl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -24(%ebp)
	.stabn  68,0,23,.LM1320	
.LM1320:
	# callm :sym.:to_sym
	subl	$24, %esp
	# [:arg, 3, :edi]
	movl	20(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_sym(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm sym.to_sym END
	pushl	%eax
	popl	%eax
	movl	%eax, 20(%ebp)
	# callm [:callm, :Class, :method_to_voff].:[]
	subl	$28, %esp
	# callm :Class.:method_to_voff
	subl	$24, %esp
	movl	Class, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__method_to_voff(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm Class.method_to_voff END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# [:arg, 3, :edx]
	movl	20(%ebp), %edx
	movl	%edx, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :Class, :method_to_voff].[] END
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	.stabn  68,0,24,.LM1321	
.LM1321:
	# if: [:callm, :voff, :!]
	# callm :voff.:!
	subl	$24, %esp
	# [:lvar, 2, :ecx]
	movl	-16(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____X(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm voff.! END
	cmpl	%eax, nil
	je	.L2312_else
	cmpl	%eax, false
	je	.L2312_else
	# then: [:do, [:return, [:callm, :obj, :method_missing, [:sym, [:splat, :args]]]]]
	.stabn  68,0,27,.LM1322	
.LM1322:
	# callm :obj.:method_missing
	# BEGIN Calculating argument count for splat
	# [:lvar, 4, :edi]
	movl	-24(%ebp), %edi
	movl	%edi, %edx
	addl	$4, %edx
	movl	(%edx), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	addl	%ecx, %eax
	movl	%eax, %ebx
	# END Calculating argument count for splat; numargs is now in ebx
	# Moving stack pointer to start of argument array:
	imull	$4, %eax
	subl	%eax, %esp
	# BEGIN Pushing arguments:
	movl	%esp, %edx
	pushl	%ebx
	# BEGIN args.each do |a|
	# [:arg, 2, :ecx]
	movl	16(%ebp), %ecx
	movl	%ecx, (%edx)
	addl	$4, %edx
	movl	$0, (%edx)
	addl	$4, %edx
	movl	20(%ebp), %eax
	movl	%eax, (%edx)
	addl	$4, %edx
	# SPLAT
	movl	-24(%ebp), %eax
	addl	$4, %eax
	movl	(%eax), %edi
	addl	$4, %eax
	movl	(%eax), %eax
	testl	%eax, %eax
	je	.L2313
.L2315:
	testl	%edi, %edi
	je	.L2314
	pushl	(%eax)
	popl	(%edx)
	addl	$4, %eax
	addl	$4, %edx
	subl	$1, %edi
	jmp	.L2315
.L2314:
.L2313:
	# END args.each
	popl	%ebx
	# END Pushing arguments
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__method_missing(%eax)
	# Evicting self
	# Re-adjusting stack post-call:
	imull	$4, %ebx
	addl	%ebx, %esp
	# callm obj.method_missing END
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	jmp	.L2316_endif
	# else: [:do, [:sexp, [:assign, :raw, [:callm, :voff, :__get_raw]]], [:sexp, [:callm, :obj, [:index, :self, :raw], [[:splat, :args]]]]]
.L2312_else:
	.stabn  68,0,32,.LM1323	
.LM1323:
	# callm :voff.:__get_raw
	subl	$24, %esp
	# [:lvar, 2, :ecx]
	movl	-16(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____get_raw(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm voff.__get_raw END
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	# callm :obj.[:index, :self, :raw]
	# BEGIN Calculating argument count for splat
	# [:lvar, 4, :edi]
	movl	-24(%ebp), %edi
	movl	%edi, %edx
	addl	$4, %edx
	movl	(%edx), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	addl	%ecx, %eax
	movl	%eax, %ebx
	# END Calculating argument count for splat; numargs is now in ebx
	# Moving stack pointer to start of argument array:
	imull	$4, %eax
	subl	%eax, %esp
	# BEGIN Pushing arguments:
	movl	%esp, %edx
	pushl	%ebx
	# BEGIN args.each do |a|
	# [:arg, 2, :ecx]
	movl	16(%ebp), %ecx
	movl	%ecx, (%edx)
	addl	$4, %edx
	movl	$0, (%edx)
	addl	$4, %edx
	# SPLAT
	movl	-24(%ebp), %eax
	addl	$4, %eax
	movl	(%eax), %edi
	addl	$4, %eax
	movl	(%eax), %eax
	testl	%eax, %eax
	je	.L2317
.L2319:
	testl	%edi, %edi
	je	.L2318
	pushl	(%eax)
	popl	(%edx)
	addl	$4, %eax
	addl	$4, %edx
	subl	$1, %edi
	jmp	.L2319
.L2318:
.L2317:
	# END args.each
	popl	%ebx
	# END Pushing arguments
	movl	(%esp), %esi
	movl	(%esi), %eax
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, %ecx
	pushl	%ecx
	# [:lvar, 3, :edi]
	movl	-20(%ebp), %edi
	movl	%edi, %eax
	sall	$2, %eax
	popl	%ecx
	addl	%eax, %ecx
	movl	(%ecx), %eax
	call	*%eax
	# Evicting self
	# Re-adjusting stack post-call:
	imull	$4, %ebx
	addl	%ebx, %esp
	# callm obj.[:index, :self, :raw] END
.L2316_endif:
	addl	$20, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Class___send_for_obj__, .-__method_Class___send_for_obj__
.Lscope275:
	.stabs  "",36,0,0,.Lscope275-.LFBB275	
		
	########################################################################	
		
		
		
		
		
		
		
	########################## __method____NDX__2 ##########################	
		
	.stabs  "__method____NDX__2:F(0,0)",36,0,0,__method____NDX__2	
.globl __method____NDX__2
	.type	__method____NDX__2, @function
__method____NDX__2:
.LFBB276:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2321_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method____NDX__2", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2320, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2321_else:
	# METHOD BODY:
	.stabn  68,0,6,.LM1324	
.LM1324:
	subl	$32, %esp
	addl	$8, %ebx
	subl	$24, %esp
	leal	16(%ebp), %eax
	movl	%eax, (%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$0, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	call	__splat_to_Array
	addl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -36(%ebp)
	.stabn  68,0,7,.LM1325	
.LM1325:
	# callm :Hash.:new
	subl	$24, %esp
	movl	Hash, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__new(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm Hash.new END
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	# callm :args.:length
	subl	$24, %esp
	# [:lvar, 7, :edi]
	movl	-36(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__length(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm args.length END
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	.stabn  68,0,9,.LM1326	
.LM1326:
	# if: [:callm, [:callm, :len, :%, [[:sexp, :__I2]]], :==, [[:sexp, :__I1]]]
	# callm [:callm, :len, :%, [[:sexp, :__I2]]].:==
	subl	$28, %esp
	# callm :len.:%
	subl	$28, %esp
	# [:lvar, 3, :edx]
	movl	-20(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	__I2, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____25(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm len.% END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :len, :%, [[:sexp, :__I2]]].== END
	cmpl	%eax, nil
	je	.L2323_else
	cmpl	%eax, false
	je	.L2323_else
	# then: [:do, [:call, :puts, [[:sexp, [:call, :__get_string, :".L55"]]]], [:call, :exit, [[:sexp, :__I1]]]]
	.stabn  68,0,12,.LM1327	
.LM1327:
	# callm :self.:puts
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	subl	$20, %esp
	movl	$.L55, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__puts(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.puts END
	# callm :self.:exit
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__exit(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.exit END
	# else: nil
.L2323_else:
	.stabn  68,0,14,.LM1328	
.LM1328:
	movl	__I0, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -24(%ebp)
	.stabn  68,0,16,.LM1329	
.LM1329:
.L2326:
	# callm :pos.:<
	subl	$28, %esp
	# [:lvar, 4, :ecx]
	movl	-24(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 3, :edi]
	movl	-20(%ebp), %edi
	movl	%edi, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm pos.< END
	cmpl	%eax, nil
	je	.L2325
	cmpl	%eax, false
	je	.L2325
	.stabn  68,0,17,.LM1330	
.LM1330:
	# callm :args.:[]
	subl	$28, %esp
	# [:lvar, 7, :edx]
	movl	-36(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 4, :ecx]
	movl	-24(%ebp), %ecx
	movl	%ecx, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm args.[] END
	pushl	%eax
	popl	%eax
	movl	%eax, -28(%ebp)
	.stabn  68,0,19,.LM1331	
.LM1331:
	# callm :args.:[]
	subl	$28, %esp
	# [:lvar, 7, :edi]
	movl	-36(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	# callm :pos.:+
	subl	$28, %esp
	# [:lvar, 4, :edx]
	movl	-24(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm pos.+ END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm args.[] END
	pushl	%eax
	popl	%eax
	movl	%eax, -32(%ebp)
	.stabn  68,0,20,.LM1332	
.LM1332:
	# callm :h.:[]=
	subl	$32, %esp
	# [:lvar, 2, :ecx]
	movl	-16(%ebp), %ecx
	movl	%ecx, (%esp)
	movl	$0, 4(%esp)
	# [:lvar, 5, :edi]
	movl	-28(%ebp), %edi
	movl	%edi, 8(%esp)
	# [:lvar, 6, :edx]
	movl	-32(%ebp), %edx
	movl	%edx, 12(%esp)
	movl	$4, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX__3d(%eax)
	# Evicting self
	# Static adj: 32
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm h.[]= END
	.stabn  68,0,21,.LM1333	
.LM1333:
	# callm :pos.:+
	subl	$28, %esp
	# [:lvar, 4, :edx]
	movl	-24(%ebp), %edx
	movl	%edx, (%esp)
	movl	$0, 4(%esp)
	movl	__I2, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm pos.+ END
	pushl	%eax
	popl	%eax
	movl	%eax, -24(%ebp)
	jmp	.L2326
.L2325:
	movl	nil, %eax
	# [:lvar, 2, :ecx]
	movl	-16(%ebp), %ecx
	movl	%ecx, %eax
	addl	$32, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method____NDX__2, .-__method____NDX__2
.Lscope276:
	.stabs  "",36,0,0,.Lscope276-.LFBB276	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Hash_sort_by #########################	
		
	.stabs  "__method_Hash_sort_by:F(0,0)",36,0,0,__method_Hash_sort_by	
.globl __method_Hash_sort_by
	.type	__method_Hash_sort_by, @function
__method_Hash_sort_by:
.LFBB277:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2328_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Hash_sort_by", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2327, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2328_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2330_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Hash_sort_by", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2327, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2330_else:
	# METHOD BODY:
	.stabn  68,0,28,.LM1334	
.LM1334:
	subl	$16, %esp
	addl	$4, %ebx
	subl	$20, %esp
	movl	$8, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	.stabn  68,0,29,.LM1335	
.LM1335:
	# callm :to_a.:sort_by
	subl	$24, %esp
	# callm :self.:to_a
	subl	$24, %esp
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__to_a(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.to_a END
	movl	%eax, (%esp)
	# Stack frame
	pushl	%ebp
	movl	-12(%ebp), %eax
	movl	%eax, %edi
	popl	%eax
	movl	%eax, (%edi)
	movl	$__lambda_L105, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	subl	$32, %esp
	movl	-16(%ebp), %eax
	movl	%eax, (%esp)
	movl	-12(%ebp), %eax
	movl	%eax, 4(%esp)
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, 8(%esp)
	movl	$1, 12(%esp)
	movl	$4, %ebx
	call	__new_proc
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__sort_by(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm to_a.sort_by END
	addl	$16, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Hash_sort_by, .-__method_Hash_sort_by
.Lscope277:
	.stabs  "",36,0,0,.Lscope277-.LFBB277	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Hash_collect #########################	
		
	.stabs  "__method_Hash_collect:F(0,0)",36,0,0,__method_Hash_collect	
.globl __method_Hash_collect
	.type	__method_Hash_collect, @function
__method_Hash_collect:
.LFBB278:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2334_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Hash_collect", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2333, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2334_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2336_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Hash_collect", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2333, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2336_else:
	# METHOD BODY:
	.stabn  68,0,32,.LM1336	
.LM1336:
	.stabn  68,0,33,.LM1337	
.LM1337:
	# callm :to_a.:collect
	subl	$24, %esp
	# callm :self.:to_a
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__to_a(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.to_a END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__collect(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm to_a.collect END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Hash_collect, .-__method_Hash_collect
.Lscope278:
	.stabs  "",36,0,0,.Lscope278-.LFBB278	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Hash_inspect #########################	
		
	.stabs  "__method_Hash_inspect:F(0,0)",36,0,0,__method_Hash_inspect	
.globl __method_Hash_inspect
	.type	__method_Hash_inspect, @function
__method_Hash_inspect:
.LFBB279:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2339_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Hash_inspect", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2338, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2339_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2341_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Hash_inspect", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2338, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2341_else:
	# METHOD BODY:
	.stabn  68,0,35,.LM1338	
.LM1338:
	subl	$16, %esp
	addl	$4, %ebx
	subl	$20, %esp
	movl	$16, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %edi
	addl	$12, %edi
	popl	%eax
	movl	%eax, (%edi)
	.stabn  68,0,36,.LM1339	
.LM1339:
	subl	$20, %esp
	movl	$.L56, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	addl	$8, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	movl	true, %eax
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %edx
	addl	$4, %edx
	popl	%eax
	movl	%eax, (%edx)
	.stabn  68,0,37,.LM1340	
.LM1340:
	# callm :self.:each
	subl	$24, %esp
	movl	%esi, (%esp)
	.stabn  68,0,38,.LM1341	
.LM1341:
	# Stack frame
	pushl	%ebp
	movl	-12(%ebp), %eax
	movl	%eax, %edi
	popl	%eax
	movl	%eax, (%edi)
	movl	$__lambda_L106, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	subl	$32, %esp
	movl	-16(%ebp), %eax
	movl	%eax, (%esp)
	movl	-12(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%esi, 8(%esp)
	movl	$2, 12(%esp)
	movl	$4, %ebx
	call	__new_proc
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__each(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.each END
	.stabn  68,0,47,.LM1342	
.LM1342:
	# callm [:index, :__env__, 2].:+
	subl	$28, %esp
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	addl	$8, %ecx
	movl	(%ecx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	subl	$20, %esp
	movl	$.L58, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 2].+ END
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %edx
	addl	$8, %edx
	popl	%eax
	movl	%eax, (%edx)
	movl	-12(%ebp), %eax
	movl	%eax, %edi
	addl	$8, %edi
	movl	(%edi), %eax
	addl	$16, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Hash_inspect, .-__method_Hash_inspect
.Lscope279:
	.stabs  "",36,0,0,.Lscope279-.LFBB279	
		
	########################################################################	
		
		
		
		
		
		
		
	########################## __method_Hash_keys ##########################	
		
	.stabs  "__method_Hash_keys:F(0,0)",36,0,0,__method_Hash_keys	
.globl __method_Hash_keys
	.type	__method_Hash_keys, @function
__method_Hash_keys:
.LFBB280:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2345_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Hash_keys", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2344, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2345_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2347_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Hash_keys", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2344, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2347_else:
	# METHOD BODY:
	.stabn  68,0,53,.LM1343	
.LM1343:
	subl	$16, %esp
	addl	$4, %ebx
	subl	$20, %esp
	movl	$12, (%esp)
	movl	$1, %ebx
	call	__alloc_mem
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	movl	12(%ebp), %eax
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %edi
	addl	$8, %edi
	popl	%eax
	movl	%eax, (%edi)
	.stabn  68,0,54,.LM1344	
.LM1344:
	# callm :Array.:[]
	subl	$24, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm Array.[] END
	pushl	%eax
	movl	-12(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	# callm :self.:each
	subl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	.stabn  68,0,55,.LM1345	
.LM1345:
	# Stack frame
	pushl	%ebp
	movl	-12(%ebp), %eax
	movl	%eax, %edx
	popl	%eax
	movl	%eax, (%edx)
	movl	$__lambda_L107, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	subl	$32, %esp
	movl	-16(%ebp), %eax
	movl	%eax, (%esp)
	movl	-12(%ebp), %eax
	movl	%eax, 4(%esp)
	movl	%esi, 8(%esp)
	movl	$2, 12(%esp)
	movl	$4, %ebx
	call	__new_proc
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__each(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.each END
	movl	-12(%ebp), %eax
	movl	%eax, %edi
	addl	$4, %edi
	movl	(%edi), %eax
	addl	$16, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Hash_keys, .-__method_Hash_keys
.Lscope280:
	.stabs  "",36,0,0,.Lscope280-.LFBB280	
		
	########################################################################	
		
		
		
		
		
		
		
	###################### __method_Struct_initialize ######################	
		
	.stabs  "__method_Struct_initialize:F(0,0)",36,0,0,__method_Struct_initialize	
.globl __method_Struct_initialize
	.type	__method_Struct_initialize, @function
__method_Struct_initialize:
.LFBB281:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2351_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Struct_initialize", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2350, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2351_else:
	# METHOD BODY:
	.stabn  68,0,4,.LM1346	
.LM1346:
	subl	$12, %esp
	addl	$3, %ebx
	subl	$24, %esp
	leal	16(%ebp), %eax
	movl	%eax, (%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$0, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	call	__splat_to_Array
	addl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	movl	nil, %eax
	addl	$12, %esp
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_Struct_initialize, .-__method_Struct_initialize
.Lscope281:
	.stabs  "",36,0,0,.Lscope281-.LFBB281	
		
	########################################################################	
		
		
		
		
		
		
		
	###################### __method_Regexp_initialize ######################	
		
	.stabs  "__method_Regexp_initialize:F(0,0)",36,0,0,__method_Regexp_initialize	
.globl __method_Regexp_initialize
	.type	__method_Regexp_initialize, @function
__method_Regexp_initialize:
.LFBB282:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2354_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Regexp_initialize", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2353, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2354_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2356_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Regexp_initialize", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2353, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2356_else:
	# METHOD BODY:
	.stabn  68,0,5,.LM1347	
.LM1347:
	movl	nil, %eax
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Regexp_initialize, .-__method_Regexp_initialize
.Lscope282:
	.stabs  "",36,0,0,.Lscope282-.LFBB282	
		
	########################################################################	
		
		
		
		
		
		
		
	################# __method_ArrayEnumerator_initialize ##################	
		
	.stabs  "__method_ArrayEnumerator_initialize:F(0,0)",36,0,0,__method_ArrayEnumerator_initialize	
.globl __method_ArrayEnumerator_initialize
	.type	__method_ArrayEnumerator_initialize, @function
__method_ArrayEnumerator_initialize:
.LFBB283:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2359_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_ArrayEnumerator_initialize", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2358, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2359_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$3, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2361_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_ArrayEnumerator_initialize", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2358, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2361_else:
	# METHOD BODY:
	.stabn  68,0,13,.LM1348	
.LM1348:
	.stabn  68,0,14,.LM1349	
.LM1349:
	movl	16(%ebp), %eax
	pushl	%eax
	popl	%eax
	pushl	%eax
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ecx
	movl	%ecx, 4(%esi)
	movl	__I0, %eax
	pushl	%eax
	popl	%eax
	pushl	%eax
	popl	%edi
	movl	%edi, 8(%esi)
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_ArrayEnumerator_initialize, .-__method_ArrayEnumerator_initialize
.Lscope283:
	.stabs  "",36,0,0,.Lscope283-.LFBB283	
		
	########################################################################	
		
		
		
		
		
		
		
	#################### __method_ArrayEnumerator_next #####################	
		
	.stabs  "__method_ArrayEnumerator_next:F(0,0)",36,0,0,__method_ArrayEnumerator_next	
.globl __method_ArrayEnumerator_next
	.type	__method_ArrayEnumerator_next, @function
__method_ArrayEnumerator_next:
.LFBB284:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2364_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_ArrayEnumerator_next", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2363, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2364_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2366_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_ArrayEnumerator_next", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2363, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2366_else:
	# METHOD BODY:
	.stabn  68,0,18,.LM1350	
.LM1350:
	.stabn  68,0,19,.LM1351	
.LM1351:
	# if: [:callm, :@pos, :<, [[:callm, :@ary, :length]]]
	# callm :@pos.:<
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	8(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :@ary.:length
	subl	$24, %esp
	movl	4(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__length(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @ary.length END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @pos.< END
	cmpl	%eax, nil
	je	.L2368_else
	cmpl	%eax, false
	je	.L2368_else
	# then: [:do, [:assign, :@pos, [:callm, :@pos, :+, [[:sexp, :__I1]]]], [:return, [:callm, :@ary, :[], [:@pos]]]]
	.stabn  68,0,20,.LM1352	
.LM1352:
	# callm :@pos.:+
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	8(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @pos.+ END
	pushl	%eax
	popl	%eax
	pushl	%eax
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%edi
	movl	%edi, 8(%esi)
	# callm :@ary.:[]
	subl	$28, %esp
	movl	4(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	8(%esi), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @ary.[] END
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	jmp	.L2369_endif
	# else: [:do, [:return, :nil]]
.L2368_else:
	.stabn  68,0,23,.LM1353	
.LM1353:
	movl	nil, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
.L2369_endif:
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_ArrayEnumerator_next, .-__method_ArrayEnumerator_next
.Lscope284:
	.stabs  "",36,0,0,.Lscope284-.LFBB284	
		
	########################################################################	
		
		
		
		
		
		
		
	################# __method_RangeEnumerator_initialize ##################	
		
	.stabs  "__method_RangeEnumerator_initialize:F(0,0)",36,0,0,__method_RangeEnumerator_initialize	
.globl __method_RangeEnumerator_initialize
	.type	__method_RangeEnumerator_initialize, @function
__method_RangeEnumerator_initialize:
.LFBB285:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2371_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_RangeEnumerator_initialize", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2370, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2371_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2373_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_RangeEnumerator_initialize", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2370, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2373_else:
	# METHOD BODY:
	.stabn  68,0,34,.LM1354	
.LM1354:
	.stabn  68,0,35,.LM1355	
.LM1355:
	# callm :r.:first
	subl	$24, %esp
	movl	16(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__first(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm r.first END
	pushl	%eax
	popl	%eax
	pushl	%eax
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%edi
	movl	%edi, 4(%esi)
	# callm :r.:last
	subl	$24, %esp
	movl	16(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__last(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm r.last END
	pushl	%eax
	popl	%eax
	pushl	%eax
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ecx
	movl	%ecx, 8(%esi)
	# callm :self.:rewind
	subl	$24, %esp
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__rewind(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.rewind END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_RangeEnumerator_initialize, .-__method_RangeEnumerator_initialize
.Lscope285:
	.stabs  "",36,0,0,.Lscope285-.LFBB285	
		
	########################################################################	
		
		
		
		
		
		
		
	################### __method_RangeEnumerator_rewind ####################	
		
	.stabs  "__method_RangeEnumerator_rewind:F(0,0)",36,0,0,__method_RangeEnumerator_rewind	
.globl __method_RangeEnumerator_rewind
	.type	__method_RangeEnumerator_rewind, @function
__method_RangeEnumerator_rewind:
.LFBB286:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2376_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_RangeEnumerator_rewind", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2375, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2376_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2378_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_RangeEnumerator_rewind", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2375, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2378_else:
	# METHOD BODY:
	.stabn  68,0,40,.LM1356	
.LM1356:
	.stabn  68,0,41,.LM1357	
.LM1357:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	4(%esi), %eax
	pushl	%eax
	popl	%eax
	pushl	%eax
	popl	%ecx
	movl	%ecx, 12(%esi)
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	__method_RangeEnumerator_rewind, .-__method_RangeEnumerator_rewind
.Lscope286:
	.stabs  "",36,0,0,.Lscope286-.LFBB286	
		
	########################################################################	
		
		
		
		
		
		
		
	#################### __method_RangeEnumerator_next #####################	
		
	.stabs  "__method_RangeEnumerator_next:F(0,0)",36,0,0,__method_RangeEnumerator_next	
.globl __method_RangeEnumerator_next
	.type	__method_RangeEnumerator_next, @function
__method_RangeEnumerator_next:
.LFBB287:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2381_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_RangeEnumerator_next", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2380, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2381_else:
	# if: [:gt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	cmpl	%eax, %edi
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2383_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_RangeEnumerator_next", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2380, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2383_else:
	# METHOD BODY:
	.stabn  68,0,44,.LM1358	
.LM1358:
	subl	$12, %esp
	addl	$3, %ebx
	.stabn  68,0,45,.LM1359	
.LM1359:
	# if: [:callm, :@cur, :<=, [:@max]]
	# callm :@cur.:<=
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	12(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	8(%esi), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____le(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @cur.<= END
	cmpl	%eax, nil
	je	.L2385_else
	cmpl	%eax, false
	je	.L2385_else
	# then: [:do, [:assign, :cur, :@cur], [:assign, :@cur, [:callm, :@cur, :+, [[:sexp, :__I1]]]], [:return, :cur]]
	.stabn  68,0,46,.LM1360	
.LM1360:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	12(%esi), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	# callm :@cur.:+
	subl	$28, %esp
	movl	12(%esi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm @cur.+ END
	pushl	%eax
	popl	%eax
	pushl	%eax
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ecx
	movl	%ecx, 12(%esi)
	.stabn  68,0,47,.LM1361	
.LM1361:
	# [:lvar, 1, :edi]
	movl	-12(%ebp), %edi
	movl	%edi, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
	jmp	.L2386_endif
	# else: [:do, [:return, :nil]]
.L2385_else:
	.stabn  68,0,52,.LM1362	
.LM1362:
	movl	nil, %eax
	movl	-4(%ebp), %ebx
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	leave	
	ret	
.L2386_endif:
	addl	$12, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_RangeEnumerator_next, .-__method_RangeEnumerator_next
.Lscope287:
	.stabs  "",36,0,0,.Lscope287-.LFBB287	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Object_raise #########################	
		
	.stabs  "__method_Object_raise:F(0,0)",36,0,0,__method_Object_raise	
.globl __method_Object_raise
	.type	__method_Object_raise, @function
__method_Object_raise:
.LFBB288:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 2]
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2388_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Object_raise", 0, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2387, %eax
	movl	%eax, 4(%esp)
	movl	$0, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2388_else:
	# METHOD BODY:
	.stabn  68,0,32,.LM1363	
.LM1363:
	subl	$12, %esp
	addl	$3, %ebx
	subl	$24, %esp
	leal	16(%ebp), %eax
	movl	%eax, (%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$0, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	call	__splat_to_Array
	addl	$24, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	.stabn  68,0,33,.LM1364	
.LM1364:
	# callm :self.:puts
	subl	$28, %esp
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	subl	$20, %esp
	movl	$.L60, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__puts(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.puts END
	# callm :self.:puts
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	subl	$20, %esp
	movl	$.L61, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__puts(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.puts END
	.stabn  68,0,34,.LM1365	
.LM1365:
	# callm :self.:puts
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	# callm :exp.:inspect
	subl	$24, %esp
	# [:lvar, 2, :edi]
	movl	-16(%ebp), %edi
	movl	%edi, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__inspect(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm exp.inspect END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	(%esi), %eax
	call	*__voff__puts(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.puts END
	.stabn  68,0,35,.LM1366	
.LM1366:
	# callm :self.:puts
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	subl	$20, %esp
	movl	$.L62, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff__puts(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.puts END
	.stabn  68,0,36,.LM1367	
.LM1367:
	pushl	$0
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	addl	$12, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Object_raise, .-__method_Object_raise
.Lscope288:
	.stabs  "",36,0,0,.Lscope288-.LFBB288	
		
	########################################################################	
		
		
		
		
		
		
		
	################################ range #################################	
		
	.stabs  "range:F(0,0)",36,0,0,range	
.globl range
	.type	range, @function
range:
.LFBB289:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# METHOD BODY:
	subl	$20, %esp
	movl	$.L2391, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	puts
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	range, .-range
.Lscope289:
	.stabs  "",36,0,0,.Lscope289-.LFBB289	
		
	########################################################################	
		
		
		
		
		
		
		
	############################## printregs ###############################	
		
	.stabs  "printregs:F(0,0)",36,0,0,printregs	
.globl printregs
	.type	printregs, @function
printregs:
.LFBB290:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# METHOD BODY:
	subl	$52, %esp
	movl	$.L2393, %eax
	movl	%eax, (%esp)
	movl	8(%ebp), %eax
	movl	%eax, %edi
	movl	(%edi), %eax
	movl	%eax, 4(%esp)
	movl	8(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	movl	(%ecx), %eax
	movl	%eax, 8(%esp)
	movl	8(%ebp), %eax
	movl	%eax, %edx
	addl	$8, %edx
	movl	(%edx), %eax
	movl	%eax, 12(%esp)
	movl	8(%ebp), %eax
	movl	%eax, %edi
	addl	$12, %edi
	movl	(%edi), %eax
	movl	%eax, 16(%esp)
	movl	8(%ebp), %eax
	movl	%eax, %ecx
	addl	$16, %ecx
	movl	(%ecx), %eax
	movl	%eax, 20(%esp)
	movl	8(%ebp), %eax
	movl	%eax, %edx
	addl	$20, %edx
	movl	(%edx), %eax
	movl	%eax, 24(%esp)
	movl	8(%ebp), %eax
	movl	%eax, %edi
	addl	$24, %edi
	movl	(%edi), %eax
	movl	%eax, 28(%esp)
	movl	8(%ebp), %eax
	movl	%eax, %ecx
	addl	$28, %ecx
	movl	(%ecx), %eax
	movl	%eax, 32(%esp)
	movl	$9, %ebx
	call	printf
	addl	$52, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	movl	8(%ebp), %eax
	movl	%eax, %edx
	addl	$24, %edx
	movl	(%edx), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, sp
	subl	$60, %esp
	movl	$.L2394, %eax
	movl	%eax, (%esp)
	movl	sp, %eax
	movl	%eax, %edi
	movl	(%edi), %eax
	movl	%eax, 4(%esp)
	movl	sp, %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	movl	(%ecx), %eax
	movl	%eax, 8(%esp)
	movl	sp, %eax
	movl	%eax, %edx
	addl	$8, %edx
	movl	(%edx), %eax
	movl	%eax, 12(%esp)
	movl	sp, %eax
	movl	%eax, %edi
	addl	$12, %edi
	movl	(%edi), %eax
	movl	%eax, 16(%esp)
	movl	sp, %eax
	movl	%eax, %ecx
	addl	$16, %ecx
	movl	(%ecx), %eax
	movl	%eax, 20(%esp)
	movl	sp, %eax
	movl	%eax, %edx
	addl	$20, %edx
	movl	(%edx), %eax
	movl	%eax, 24(%esp)
	movl	sp, %eax
	movl	%eax, %edi
	addl	$24, %edi
	movl	(%edi), %eax
	movl	%eax, 28(%esp)
	movl	sp, %eax
	movl	%eax, %ecx
	addl	$28, %ecx
	movl	(%ecx), %eax
	movl	%eax, 32(%esp)
	movl	sp, %eax
	movl	%eax, %edx
	addl	$32, %edx
	movl	(%edx), %eax
	movl	%eax, 36(%esp)
	movl	sp, %eax
	movl	%eax, %edi
	addl	$36, %edi
	movl	(%edi), %eax
	movl	%eax, 40(%esp)
	movl	$11, %ebx
	call	printf
	addl	$60, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	movl	8(%ebp), %eax
	movl	%eax, %ecx
	addl	$28, %ecx
	movl	(%ecx), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, sp
	subl	$52, %esp
	movl	$.L2395, %eax
	movl	%eax, (%esp)
	movl	sp, %eax
	movl	%eax, %edx
	movl	(%edx), %eax
	movl	%eax, 4(%esp)
	movl	sp, %eax
	movl	%eax, %edi
	addl	$4, %edi
	movl	(%edi), %eax
	movl	%eax, 8(%esp)
	movl	sp, %eax
	movl	%eax, %ecx
	addl	$8, %ecx
	movl	(%ecx), %eax
	movl	%eax, 12(%esp)
	movl	sp, %eax
	movl	%eax, %edx
	addl	$12, %edx
	movl	(%edx), %eax
	movl	%eax, 16(%esp)
	movl	sp, %eax
	movl	%eax, %edi
	addl	$16, %edi
	movl	(%edi), %eax
	movl	%eax, 20(%esp)
	movl	sp, %eax
	movl	%eax, %ecx
	addl	$20, %ecx
	movl	(%ecx), %eax
	movl	%eax, 24(%esp)
	movl	sp, %eax
	movl	%eax, %edx
	addl	$24, %edx
	movl	(%edx), %eax
	movl	%eax, 28(%esp)
	movl	sp, %eax
	movl	%eax, %edi
	addl	$28, %edi
	movl	(%edi), %eax
	movl	%eax, 32(%esp)
	movl	$9, %ebx
	call	printf
	addl	$52, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	# Reloading self if evicted:
	popl	%ebx
	leave	
	ret	
	.size	printregs, .-printregs
.Lscope290:
	.stabs  "",36,0,0,.Lscope290-.LFBB290	
		
	########################################################################	
		
		
		
		
		
		
		
	######################## __method_Integer___mul ########################	
		
	.stabs  "__method_Integer___mul:F(0,0)",36,0,0,__method_Integer___mul	
.globl __method_Integer___mul
	.type	__method_Integer___mul, @function
__method_Integer___mul:
.LFBB291:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2397_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Integer___mul", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2396, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$2, %eax
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2397_else:
	# if: [:gt, :numargs, 3]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$3, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2399_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Integer___mul", 1, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2396, %eax
	movl	%eax, 4(%esp)
	movl	$1, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2399_else:
	# METHOD BODY:
	.stabn  68,0,2,.LM1368	
.LM1368:
	.stabn  68,0,3,.LM1369	
.LM1369:
	# callm :self.:+
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.+ END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Integer___mul, .-__method_Integer___mul
.Lscope291:
	.stabs  "",36,0,0,.Lscope291-.LFBB291	
		
	########################################################################	
		
		
		
		
		
		
		
	####################### __method_Object_multiply #######################	
		
	.stabs  "__method_Object_multiply:F(0,0)",36,0,0,__method_Object_multiply	
.globl __method_Object_multiply
	.type	__method_Object_multiply, @function
__method_Object_multiply:
.LFBB292:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$4, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2402_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a minimum of %d arguments, got %d\n", "__method_Object_multiply", 2, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L536, %eax
	movl	%eax, (%esp)
	movl	$.L2401, %eax
	movl	%eax, 4(%esp)
	movl	$2, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$2, %eax
	subl	%eax, %ecx
	movl	%ecx, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %edi
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%edi
	# else: nil
.L2402_else:
	# if: [:gt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$4, %eax
	cmpl	%eax, %ecx
	setg	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2404_else
	# then: [:sexp, [:call, :printf, ["ArgumentError: In %s - expected a maximum of %d arguments, got %d\n", "__method_Object_multiply", 2, [:sub, :numargs, 2]]], [:div, 1, 0]]
	subl	$32, %esp
	movl	$.L539, %eax
	movl	%eax, (%esp)
	movl	$.L2401, %eax
	movl	%eax, 4(%esp)
	movl	$2, 8(%esp)
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$2, %eax
	subl	%eax, %edi
	movl	%edi, %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	call	printf
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	$1
	movl	$0, %ecx
	popl	%eax
	movl	%eax, %edx
	sarl	$31, %edx
	idivl	%ecx
	# else: nil
.L2404_else:
	# METHOD BODY:
	.stabn  68,0,7,.LM1370	
.LM1370:
	.stabn  68,0,8,.LM1371	
.LM1371:
	# callm :a.:*
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	20(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____mul(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm a.* END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__method_Object_multiply, .-__method_Object_multiply
.Lscope292:
	.stabs  "",36,0,0,.Lscope292-.LFBB292	
		
	########################################################################	
		
		
		
		
		
		
		
	############################# __lambda_L64 #############################	
		
	.stabs  "__lambda_L64:F(0,0)",36,0,0,__lambda_L64	
.globl __lambda_L64
	.type	__lambda_L64, @function
__lambda_L64:
.LFBB293:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# METHOD BODY:
	.stabn  68,0,162,.LM1372	
.LM1372:
	movl	nil, %eax
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__lambda_L64, .-__lambda_L64
.Lscope293:
	.stabs  "",36,0,0,.Lscope293-.LFBB293	
		
	########################################################################	
		
		
		
		
		
		
		
	############################# __lambda_L65 #############################	
		
	.stabs  "__lambda_L65:F(0,0)",36,0,0,__lambda_L65	
.globl __lambda_L65
	.type	__lambda_L65, @function
__lambda_L65:
.LFBB294:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for val at position 5
	# :nil
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$4, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2408_else
	# then: [:assign, :"#val", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L2409_endif
	# else: [:assign, :"#val", :val]
.L2408_else:
	movl	20(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L2409_endif:
	# METHOD BODY:
	.stabn  68,0,172,.LM1373	
.LM1373:
	movl	nil, %eax
	addl	$4, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__lambda_L65, .-__lambda_L65
.Lscope294:
	.stabs  "",36,0,0,.Lscope294-.LFBB294	
		
	########################################################################	
		
		
		
		
		
		
		
	############################# __lambda_L66 #############################	
		
	.stabs  "__lambda_L66:F(0,0)",36,0,0,__lambda_L66	
.globl __lambda_L66
	.type	__lambda_L66, @function
__lambda_L66:
.LFBB295:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for v at position 5
	# :nil
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$4, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2411_else
	# then: [:assign, :"#v", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L2412_endif
	# else: [:assign, :"#v", :v]
.L2411_else:
	movl	20(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L2412_endif:
	# METHOD BODY:
	.stabn  68,0,55,.LM1374	
.LM1374:
	.stabn  68,0,56,.LM1375	
.LM1375:
	# callm [:index, :__env__, 1].:<<
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %edx
	addl	$4, %edx
	movl	(%edx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	-8(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt__lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].<< END
	addl	$4, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__lambda_L66, .-__lambda_L66
.Lscope295:
	.stabs  "",36,0,0,.Lscope295-.LFBB295	
		
	########################################################################	
		
		
		
		
		
		
		
	############################# __lambda_L67 #############################	
		
	.stabs  "__lambda_L67:F(0,0)",36,0,0,__lambda_L67	
.globl __lambda_L67
	.type	__lambda_L67, @function
__lambda_L67:
.LFBB296:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for e at position 5
	# :nil
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$4, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2414_else
	# then: [:assign, :"#e", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L2415_endif
	# else: [:assign, :"#e", :e]
.L2414_else:
	movl	20(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L2415_endif:
	# METHOD BODY:
	.stabn  68,0,42,.LM1376	
.LM1376:
	subl	$12, %esp
	addl	$3, %ebx
	.stabn  68,0,43,.LM1377	
.LM1377:
	# callm [:index, :__env__, 1].:call
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	movl	(%ecx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	-8(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__call(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].call END
	pushl	%eax
	popl	%eax
	movl	%eax, -16(%ebp)
	# if: [:callm, :r, :!=, [:false]]
	# callm :r.:!=
	subl	$28, %esp
	movl	-16(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	false, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____X__3d(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm r.!= END
	cmpl	%eax, nil
	je	.L2416_else
	cmpl	%eax, false
	je	.L2416_else
	# then: [:preturn, :e]
	# preturn
	movl	-8(%ebp), %eax
	pushl	%eax
	movl	16(%ebp), %eax
	movl	%eax, %edx
	movl	(%edx), %eax
	movl	%eax, %ebp
	movl	-4(%ebp), %ebx
	popl	%eax
	leave	
	ret	
	# else: nil
.L2416_else:
	addl	$12, %esp
	addl	$4, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__lambda_L67, .-__lambda_L67
.Lscope296:
	.stabs  "",36,0,0,.Lscope296-.LFBB296	
		
	########################################################################	
		
		
		
		
		
		
		
	############################# __lambda_L68 #############################	
		
	.stabs  "__lambda_L68:F(0,0)",36,0,0,__lambda_L68	
.globl __lambda_L68
	.type	__lambda_L68, @function
__lambda_L68:
.LFBB297:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for e at position 5
	# :nil
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$4, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2419_else
	# then: [:assign, :"#e", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L2420_endif
	# else: [:assign, :"#e", :e]
.L2419_else:
	movl	20(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L2420_endif:
	# METHOD BODY:
	.stabn  68,0,51,.LM1378	
.LM1378:
	.stabn  68,0,52,.LM1379	
.LM1379:
	# if: [:callm, :e, :==, [[:index, :__env__, 1]]]
	# callm :e.:==
	subl	$28, %esp
	movl	-8(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	movl	(%ecx), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm e.== END
	cmpl	%eax, nil
	je	.L2421_else
	cmpl	%eax, false
	je	.L2421_else
	# then: [:preturn, :true]
	# preturn
	movl	true, %eax
	pushl	%eax
	movl	16(%ebp), %eax
	movl	%eax, %edx
	movl	(%edx), %eax
	movl	%eax, %ebp
	movl	-4(%ebp), %ebx
	popl	%eax
	leave	
	ret	
	# else: nil
.L2421_else:
	addl	$4, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__lambda_L68, .-__lambda_L68
.Lscope297:
	.stabs  "",36,0,0,.Lscope297-.LFBB297	
		
	########################################################################	
		
		
		
		
		
		
		
	############################# __lambda_L69 #############################	
		
	.stabs  "__lambda_L69:F(0,0)",36,0,0,__lambda_L69	
.globl __lambda_L69
	.type	__lambda_L69, @function
__lambda_L69:
.LFBB298:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for item at position 5
	# :nil
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$4, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2424_else
	# then: [:assign, :"#item", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L2425_endif
	# else: [:assign, :"#item", :item]
.L2424_else:
	movl	20(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L2425_endif:
	# METHOD BODY:
	.stabn  68,0,60,.LM1380	
.LM1380:
	.stabn  68,0,61,.LM1381	
.LM1381:
	# if: [:callm, [:callm, [:index, :__env__, 2], :call, [:item]], :!]
	# callm [:callm, [:index, :__env__, 2], :call, [:item]].:!
	subl	$24, %esp
	# callm [:index, :__env__, 2].:call
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %ecx
	addl	$8, %ecx
	movl	(%ecx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	-8(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__call(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 2].call END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____X(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:index, :__env__, 2], :call, [:item]].! END
	cmpl	%eax, nil
	je	.L2426_else
	cmpl	%eax, false
	je	.L2426_else
	# then: [:do, [:callm, [:index, :__env__, 1], :<<, [:item]]]
	.stabn  68,0,62,.LM1382	
.LM1382:
	# callm [:index, :__env__, 1].:<<
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %edx
	addl	$4, %edx
	movl	(%edx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	-8(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt__lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].<< END
	# else: nil
.L2426_else:
	addl	$4, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__lambda_L69, .-__lambda_L69
.Lscope298:
	.stabs  "",36,0,0,.Lscope298-.LFBB298	
		
	########################################################################	
		
		
		
		
		
		
		
	############################# __lambda_L70 #############################	
		
	.stabs  "__lambda_L70:F(0,0)",36,0,0,__lambda_L70	
.globl __lambda_L70
	.type	__lambda_L70, @function
__lambda_L70:
.LFBB299:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for item at position 5
	# :nil
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$4, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2429_else
	# then: [:assign, :"#item", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L2430_endif
	# else: [:assign, :"#item", :item]
.L2429_else:
	movl	20(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L2430_endif:
	# METHOD BODY:
	.stabn  68,0,72,.LM1383	
.LM1383:
	.stabn  68,0,73,.LM1384	
.LM1384:
	# callm [:index, :__env__, 1].:<<
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	movl	(%ecx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm [:index, :__env__, 2].:call
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %edx
	addl	$8, %edx
	movl	(%edx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	-8(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__call(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 2].call END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt__lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].<< END
	addl	$4, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__lambda_L70, .-__lambda_L70
.Lscope299:
	.stabs  "",36,0,0,.Lscope299-.LFBB299	
		
	########################################################################	
		
		
		
		
		
		
		
	############################# __lambda_L71 #############################	
		
	.stabs  "__lambda_L71:F(0,0)",36,0,0,__lambda_L71	
.globl __lambda_L71
	.type	__lambda_L71, @function
__lambda_L71:
.LFBB300:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for item at position 5
	# :nil
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$4, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2432_else
	# then: [:assign, :"#item", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L2433_endif
	# else: [:assign, :"#item", :item]
.L2432_else:
	movl	20(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L2433_endif:
	# METHOD BODY:
	.stabn  68,0,84,.LM1385	
.LM1385:
	.stabn  68,0,85,.LM1386	
.LM1386:
	# if: [:callm, [:index, :__env__, 1], :call, [:item]]
	# callm [:index, :__env__, 1].:call
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	movl	(%ecx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	-8(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__call(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].call END
	cmpl	%eax, nil
	je	.L2434_else
	cmpl	%eax, false
	je	.L2434_else
	# then: [:do, [:preturn, :item]]
	.stabn  68,0,86,.LM1387	
.LM1387:
	# preturn
	movl	-8(%ebp), %eax
	pushl	%eax
	movl	16(%ebp), %eax
	movl	%eax, %edx
	movl	(%edx), %eax
	movl	%eax, %ebp
	movl	-4(%ebp), %ebx
	popl	%eax
	leave	
	ret	
	# else: nil
.L2434_else:
	addl	$4, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__lambda_L71, .-__lambda_L71
.Lscope300:
	.stabs  "",36,0,0,.Lscope300-.LFBB300	
		
	########################################################################	
		
		
		
		
		
		
		
	############################# __lambda_L72 #############################	
		
	.stabs  "__lambda_L72:F(0,0)",36,0,0,__lambda_L72	
.globl __lambda_L72
	.type	__lambda_L72, @function
__lambda_L72:
.LFBB301:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for i at position 5
	# :nil
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$4, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2437_else
	# then: [:assign, :"#i", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L2438_endif
	# else: [:assign, :"#i", :i]
.L2437_else:
	movl	20(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L2438_endif:
	# METHOD BODY:
	.stabn  68,0,97,.LM1388	
.LM1388:
	.stabn  68,0,98,.LM1389	
.LM1389:
	# callm [:index, :__env__, 1].:call
	subl	$32, %esp
	movl	16(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	movl	(%ecx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :self.:[]
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	-8(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.[] END
	movl	%eax, 8(%esp)
	movl	-8(%ebp), %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__call(%eax)
	# Evicting self
	# Static adj: 32
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].call END
	addl	$4, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__lambda_L72, .-__lambda_L72
.Lscope301:
	.stabs  "",36,0,0,.Lscope301-.LFBB301	
		
	########################################################################	
		
		
		
		
		
		
		
	############################# __lambda_L73 #############################	
		
	.stabs  "__lambda_L73:F(0,0)",36,0,0,__lambda_L73	
.globl __lambda_L73
	.type	__lambda_L73, @function
__lambda_L73:
.LFBB302:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for i at position 5
	# :nil
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$4, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2440_else
	# then: [:assign, :"#i", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L2441_endif
	# else: [:assign, :"#i", :i]
.L2440_else:
	movl	20(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L2441_endif:
	# METHOD BODY:
	.stabn  68,0,188,.LM1390	
.LM1390:
	.stabn  68,0,189,.LM1391	
.LM1391:
	# if: [:callm, [:callm, :self, :[], [:i]], :!=, [[:callm, [:index, :__env__, 1], :[], [:i]]]]
	# callm [:callm, :self, :[], [:i]].:!=
	subl	$28, %esp
	# callm :self.:[]
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	-8(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.[] END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm [:index, :__env__, 1].:[]
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %edi
	addl	$4, %edi
	movl	(%edi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	-8(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].[] END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____X__3d(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :self, :[], [:i]].!= END
	cmpl	%eax, nil
	je	.L2442_else
	cmpl	%eax, false
	je	.L2442_else
	# then: [:do, [:preturn, :false]]
	.stabn  68,0,190,.LM1392	
.LM1392:
	# preturn
	movl	false, %eax
	pushl	%eax
	movl	16(%ebp), %eax
	movl	%eax, %ecx
	movl	(%ecx), %eax
	movl	%eax, %ebp
	movl	-4(%ebp), %ebx
	popl	%eax
	leave	
	ret	
	# else: nil
.L2442_else:
	addl	$4, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__lambda_L73, .-__lambda_L73
.Lscope302:
	.stabs  "",36,0,0,.Lscope302-.LFBB302	
		
	########################################################################	
		
		
		
		
		
		
		
	############################# __lambda_L74 #############################	
		
	.stabs  "__lambda_L74:F(0,0)",36,0,0,__lambda_L74	
.globl __lambda_L74
	.type	__lambda_L74, @function
__lambda_L74:
.LFBB303:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for e at position 5
	# :nil
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$4, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2445_else
	# then: [:assign, :"#e", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L2446_endif
	# else: [:assign, :"#e", :e]
.L2445_else:
	movl	20(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L2446_endif:
	# METHOD BODY:
	.stabn  68,0,202,.LM1393	
.LM1393:
	.stabn  68,0,203,.LM1394	
.LM1394:
	# callm [:index, :__env__, 1].:<<
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %edi
	addl	$4, %edi
	movl	(%edi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	-8(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt__lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].<< END
	addl	$4, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__lambda_L74, .-__lambda_L74
.Lscope303:
	.stabs  "",36,0,0,.Lscope303-.LFBB303	
		
	########################################################################	
		
		
		
		
		
		
		
	############################# __lambda_L75 #############################	
		
	.stabs  "__lambda_L75:F(0,0)",36,0,0,__lambda_L75	
.globl __lambda_L75
	.type	__lambda_L75, @function
__lambda_L75:
.LFBB304:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for item at position 5
	# :nil
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$4, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2448_else
	# then: [:assign, :"#item", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L2449_endif
	# else: [:assign, :"#item", :item]
.L2448_else:
	movl	20(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L2449_endif:
	# METHOD BODY:
	.stabn  68,0,327,.LM1395	
.LM1395:
	.stabn  68,0,328,.LM1396	
.LM1396:
	# if: [:callm, :item, :is_a?, [:Array]]
	# callm :item.:is_a?
	subl	$28, %esp
	movl	-8(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	Array, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__is_a__Q(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm item.is_a? END
	cmpl	%eax, nil
	je	.L2450_else
	cmpl	%eax, false
	je	.L2450_else
	# then: [:do, [:if, [:callm, [:callm, :item, :first], :==, [[:index, :__env__, 1]]], [:do, [:preturn, :item]]]]
	.stabn  68,0,329,.LM1397	
.LM1397:
	# if: [:callm, [:callm, :item, :first], :==, [[:index, :__env__, 1]]]
	# callm [:callm, :item, :first].:==
	subl	$28, %esp
	# callm :item.:first
	subl	$24, %esp
	movl	-8(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__first(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm item.first END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, %edx
	addl	$4, %edx
	movl	(%edx), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :item, :first].== END
	cmpl	%eax, nil
	je	.L2451_else
	cmpl	%eax, false
	je	.L2451_else
	# then: [:do, [:preturn, :item]]
	.stabn  68,0,330,.LM1398	
.LM1398:
	# preturn
	movl	-8(%ebp), %eax
	pushl	%eax
	movl	16(%ebp), %eax
	movl	%eax, %edi
	movl	(%edi), %eax
	movl	%eax, %ebp
	movl	-4(%ebp), %ebx
	popl	%eax
	leave	
	ret	
	# else: nil
.L2451_else:
	# else: nil
.L2450_else:
	addl	$4, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__lambda_L75, .-__lambda_L75
.Lscope304:
	.stabs  "",36,0,0,.Lscope304-.LFBB304	
		
	########################################################################	
		
		
		
		
		
		
		
	############################# __lambda_L76 #############################	
		
	.stabs  "__lambda_L76:F(0,0)",36,0,0,__lambda_L76	
.globl __lambda_L76
	.type	__lambda_L76, @function
__lambda_L76:
.LFBB305:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for item at position 5
	# :nil
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$4, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2455_else
	# then: [:assign, :"#item", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L2456_endif
	# else: [:assign, :"#item", :item]
.L2455_else:
	movl	20(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L2456_endif:
	# METHOD BODY:
	.stabn  68,0,366,.LM1399	
.LM1399:
	# callm :item.:nil?
	subl	$24, %esp
	movl	-8(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__nil__Q(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm item.nil? END
	addl	$4, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__lambda_L76, .-__lambda_L76
.Lscope305:
	.stabs  "",36,0,0,.Lscope305-.LFBB305	
		
	########################################################################	
		
		
		
		
		
		
		
	############################# __lambda_L77 #############################	
		
	.stabs  "__lambda_L77:F(0,0)",36,0,0,__lambda_L77	
.globl __lambda_L77
	.type	__lambda_L77, @function
__lambda_L77:
.LFBB306:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for item at position 5
	# :nil
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$4, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2458_else
	# then: [:assign, :"#item", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L2459_endif
	# else: [:assign, :"#item", :item]
.L2458_else:
	movl	20(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L2459_endif:
	# METHOD BODY:
	.stabn  68,0,378,.LM1400	
.LM1400:
	.stabn  68,0,379,.LM1401	
.LM1401:
	# callm [:index, :__env__, 1].:<<
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %edi
	addl	$4, %edi
	movl	(%edi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	-8(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt__lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].<< END
	addl	$4, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__lambda_L77, .-__lambda_L77
.Lscope306:
	.stabs  "",36,0,0,.Lscope306-.LFBB306	
		
	########################################################################	
		
		
		
		
		
		
		
	############################# __lambda_L78 #############################	
		
	.stabs  "__lambda_L78:F(0,0)",36,0,0,__lambda_L78	
.globl __lambda_L78
	.type	__lambda_L78, @function
__lambda_L78:
.LFBB307:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for e at position 5
	# :nil
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$4, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2461_else
	# then: [:assign, :"#e", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L2462_endif
	# else: [:assign, :"#e", :e]
.L2461_else:
	movl	20(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L2462_endif:
	# METHOD BODY:
	.stabn  68,0,446,.LM1402	
.LM1402:
	.stabn  68,0,447,.LM1403	
.LM1403:
	# callm [:index, :__env__, 1].:<<
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %edx
	addl	$4, %edx
	movl	(%edx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	-8(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt__lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].<< END
	addl	$4, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__lambda_L78, .-__lambda_L78
.Lscope307:
	.stabs  "",36,0,0,.Lscope307-.LFBB307	
		
	########################################################################	
		
		
		
		
		
		
		
	############################# __lambda_L79 #############################	
		
	.stabs  "__lambda_L79:F(0,0)",36,0,0,__lambda_L79	
.globl __lambda_L79
	.type	__lambda_L79, @function
__lambda_L79:
.LFBB308:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for v at position 5
	# :nil
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$4, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2464_else
	# then: [:assign, :"#v", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L2465_endif
	# else: [:assign, :"#v", :v]
.L2464_else:
	movl	20(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L2465_endif:
	# METHOD BODY:
	.stabn  68,0,482,.LM1404	
.LM1404:
	.stabn  68,0,483,.LM1405	
.LM1405:
	# if: [:callm, :v, :==, [[:index, :__env__, 1]]]
	# callm :v.:==
	subl	$28, %esp
	movl	-8(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	movl	(%ecx), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm v.== END
	cmpl	%eax, nil
	je	.L2466_else
	cmpl	%eax, false
	je	.L2466_else
	# then: [:preturn, :true]
	# preturn
	movl	true, %eax
	pushl	%eax
	movl	16(%ebp), %eax
	movl	%eax, %edx
	movl	(%edx), %eax
	movl	%eax, %ebp
	movl	-4(%ebp), %ebx
	popl	%eax
	leave	
	ret	
	# else: nil
.L2466_else:
	addl	$4, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__lambda_L79, .-__lambda_L79
.Lscope308:
	.stabs  "",36,0,0,.Lscope308-.LFBB308	
		
	########################################################################	
		
		
		
		
		
		
		
	############################# __lambda_L80 #############################	
		
	.stabs  "__lambda_L80:F(0,0)",36,0,0,__lambda_L80	
.globl __lambda_L80
	.type	__lambda_L80, @function
__lambda_L80:
.LFBB309:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for i at position 5
	# :nil
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$4, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2469_else
	# then: [:assign, :"#i", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L2470_endif
	# else: [:assign, :"#i", :i]
.L2469_else:
	movl	20(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L2470_endif:
	# METHOD BODY:
	.stabn  68,0,552,.LM1406	
.LM1406:
	.stabn  68,0,553,.LM1407	
.LM1407:
	# callm [:index, :__env__, 1].:<<
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	movl	(%ecx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :self.:[]
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	-8(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.[] END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt__lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].<< END
	addl	$4, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__lambda_L80, .-__lambda_L80
.Lscope309:
	.stabs  "",36,0,0,.Lscope309-.LFBB309	
		
	########################################################################	
		
		
		
		
		
		
		
	############################# __lambda_L81 #############################	
		
	.stabs  "__lambda_L81:F(0,0)",36,0,0,__lambda_L81	
.globl __lambda_L81
	.type	__lambda_L81, @function
__lambda_L81:
.LFBB310:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for e at position 5
	# :nil
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$4, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2472_else
	# then: [:assign, :"#e", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L2473_endif
	# else: [:assign, :"#e", :e]
.L2472_else:
	movl	20(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L2473_endif:
	# METHOD BODY:
	.stabn  68,0,572,.LM1408	
.LM1408:
	movl	16(%ebp), %eax
	movl	%eax, %edi
	addl	$4, %edi
	movl	(%edi), %eax
	movl	16(%ebp), %eax
	movl	%eax, %ecx
	addl	$8, %ecx
	movl	(%ecx), %eax
	.stabn  68,0,574,.LM1409	
.LM1409:
	# if: [:callm, :e, :is_a?, [:Array]]
	# callm :e.:is_a?
	subl	$28, %esp
	movl	-8(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	Array, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__is_a__Q(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm e.is_a? END
	cmpl	%eax, nil
	je	.L2474_else
	cmpl	%eax, false
	je	.L2474_else
	# then: [:do, [:if, [:index, :__env__, 1], [:do, [:if, [:callm, [:index, :__env__, 1], :>, [[:sexp, :__I1]]], [:assign, :e, [:callm, :e, :flatten, [[:callm, [:index, :__env__, 1], :-, [[:sexp, :__I1]]]]]]]], [:do, [:assign, :e, [:callm, :e, :flatten]]]], [:callm, [:index, :__env__, 2], :concat, [:e]]]
	.stabn  68,0,577,.LM1410	
.LM1410:
	# if: [:index, :__env__, 1]
	movl	16(%ebp), %eax
	movl	%eax, %edx
	addl	$4, %edx
	movl	(%edx), %eax
	cmpl	%eax, nil
	je	.L2475_else
	cmpl	%eax, false
	je	.L2475_else
	# then: [:do, [:if, [:callm, [:index, :__env__, 1], :>, [[:sexp, :__I1]]], [:assign, :e, [:callm, :e, :flatten, [[:callm, [:index, :__env__, 1], :-, [[:sexp, :__I1]]]]]]]]
	.stabn  68,0,578,.LM1411	
.LM1411:
	# if: [:callm, [:index, :__env__, 1], :>, [[:sexp, :__I1]]]
	# callm [:index, :__env__, 1].:>
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %edi
	addl	$4, %edi
	movl	(%edi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____gt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].> END
	cmpl	%eax, nil
	je	.L2476_else
	cmpl	%eax, false
	je	.L2476_else
	# then: [:assign, :e, [:callm, :e, :flatten, [[:callm, [:index, :__env__, 1], :-, [[:sexp, :__I1]]]]]]
	# callm :e.:flatten
	subl	$28, %esp
	movl	-8(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm [:index, :__env__, 1].:-
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	movl	(%ecx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____minus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].- END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__flatten(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm e.flatten END
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	# else: nil
.L2476_else:
	jmp	.L2478_endif
	# else: [:do, [:assign, :e, [:callm, :e, :flatten]]]
.L2475_else:
	.stabn  68,0,580,.LM1412	
.LM1412:
	# callm :e.:flatten
	subl	$24, %esp
	movl	-8(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__flatten(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm e.flatten END
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L2478_endif:
	.stabn  68,0,581,.LM1413	
.LM1413:
	# callm [:index, :__env__, 2].:concat
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %edx
	addl	$8, %edx
	movl	(%edx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	-8(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__concat(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 2].concat END
	jmp	.L2479_endif
	# else: [:do, [:callm, [:index, :__env__, 2], :<<, [:e]]]
.L2474_else:
	.stabn  68,0,584,.LM1414	
.LM1414:
	# callm [:index, :__env__, 2].:<<
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %edi
	addl	$8, %edi
	movl	(%edi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	-8(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt__lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 2].<< END
.L2479_endif:
	addl	$4, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__lambda_L81, .-__lambda_L81
.Lscope310:
	.stabs  "",36,0,0,.Lscope310-.LFBB310	
		
	########################################################################	
		
		
		
		
		
		
		
	############################# __lambda_L82 #############################	
		
	.stabs  "__lambda_L82:F(0,0)",36,0,0,__lambda_L82	
.globl __lambda_L82
	.type	__lambda_L82, @function
__lambda_L82:
.LFBB311:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for c at position 5
	# :nil
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$4, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2481_else
	# then: [:assign, :"#c", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L2482_endif
	# else: [:assign, :"#c", :c]
.L2481_else:
	movl	20(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L2482_endif:
	# METHOD BODY:
	.stabn  68,0,611,.LM1415	
.LM1415:
	.stabn  68,0,612,.LM1416	
.LM1416:
	# callm [:callm, [:index, :__env__, 1], :*, [[:sexp, :__I33]]].:+
	subl	$28, %esp
	# callm [:index, :__env__, 1].:*
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %edx
	addl	$4, %edx
	movl	(%edx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I33, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____mul(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].* END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :c.:hash
	subl	$24, %esp
	movl	-8(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__hash(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm c.hash END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:index, :__env__, 1], :*, [[:sexp, :__I33]]].+ END
	pushl	%eax
	movl	16(%ebp), %eax
	movl	%eax, %edi
	addl	$4, %edi
	popl	%eax
	movl	%eax, (%edi)
	addl	$4, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__lambda_L82, .-__lambda_L82
.Lscope311:
	.stabs  "",36,0,0,.Lscope311-.LFBB311	
		
	########################################################################	
		
		
		
		
		
		
		
	############################# __lambda_L83 #############################	
		
	.stabs  "__lambda_L83:F(0,0)",36,0,0,__lambda_L83	
.globl __lambda_L83
	.type	__lambda_L83, @function
__lambda_L83:
.LFBB312:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for item at position 5
	# :nil
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$4, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2484_else
	# then: [:assign, :"#item", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L2485_endif
	# else: [:assign, :"#item", :item]
.L2484_else:
	movl	20(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L2485_endif:
	# METHOD BODY:
	.stabn  68,0,649,.LM1417	
.LM1417:
	# callm :self.:<<
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	movl	-8(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	movl	(%esi), %eax
	call	*__voff____lt__lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.<< END
	addl	$4, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__lambda_L83, .-__lambda_L83
.Lscope312:
	.stabs  "",36,0,0,.Lscope312-.LFBB312	
		
	########################################################################	
		
		
		
		
		
		
		
	############################# __lambda_L84 #############################	
		
	.stabs  "__lambda_L84:F(0,0)",36,0,0,__lambda_L84	
.globl __lambda_L84
	.type	__lambda_L84, @function
__lambda_L84:
.LFBB313:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for a at position 5
	# :nil
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$4, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2487_else
	# then: [:assign, :"#a", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L2488_endif
	# else: [:assign, :"#a", :a]
.L2487_else:
	movl	20(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L2488_endif:
	# METHOD BODY:
	.stabn  68,0,686,.LM1418	
.LM1418:
	.stabn  68,0,687,.LM1419	
.LM1419:
	# if: [:callm, [:index, :__env__, 1], :!]
	# callm [:index, :__env__, 1].:!
	subl	$24, %esp
	movl	16(%ebp), %eax
	movl	%eax, %edi
	addl	$4, %edi
	movl	(%edi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____X(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].! END
	cmpl	%eax, nil
	je	.L2489_else
	cmpl	%eax, false
	je	.L2489_else
	# then: [:do, [:callm, [:index, :__env__, 2], :<<, [[:sexp, [:call, :__get_string, :".L14"]]]]]
	.stabn  68,0,688,.LM1420	
.LM1420:
	# callm [:index, :__env__, 2].:<<
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %ecx
	addl	$8, %ecx
	movl	(%ecx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	subl	$20, %esp
	movl	$.L14, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt__lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 2].<< END
	jmp	.L2490_endif
	# else: [:do, [:assign, [:index, :__env__, 1], :false]]
.L2489_else:
	.stabn  68,0,690,.LM1421	
.LM1421:
	movl	false, %eax
	pushl	%eax
	movl	16(%ebp), %eax
	movl	%eax, %edx
	addl	$4, %edx
	popl	%eax
	movl	%eax, (%edx)
.L2490_endif:
	.stabn  68,0,691,.LM1422	
.LM1422:
	# callm [:index, :__env__, 2].:<<
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %edi
	addl	$8, %edi
	movl	(%edi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :a.:inspect
	subl	$24, %esp
	movl	-8(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__inspect(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm a.inspect END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt__lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 2].<< END
	addl	$4, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__lambda_L84, .-__lambda_L84
.Lscope313:
	.stabs  "",36,0,0,.Lscope313-.LFBB313	
		
	########################################################################	
		
		
		
		
		
		
		
	############################# __lambda_L85 #############################	
		
	.stabs  "__lambda_L85:F(0,0)",36,0,0,__lambda_L85	
.globl __lambda_L85
	.type	__lambda_L85, @function
__lambda_L85:
.LFBB314:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for item at position 5
	# :nil
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$4, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2492_else
	# then: [:assign, :"#item", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L2493_endif
	# else: [:assign, :"#item", :item]
.L2492_else:
	movl	20(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L2493_endif:
	# METHOD BODY:
	.stabn  68,0,705,.LM1423	
.LM1423:
	.stabn  68,0,706,.LM1424	
.LM1424:
	# if: [:callm, [:callm, [:index, :__env__, 1], :empty?], :!]
	# callm [:callm, [:index, :__env__, 1], :empty?].:!
	subl	$24, %esp
	# callm [:index, :__env__, 1].:empty?
	subl	$24, %esp
	movl	16(%ebp), %eax
	movl	%eax, %edx
	addl	$4, %edx
	movl	(%edx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__empty__Q(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].empty? END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____X(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:index, :__env__, 1], :empty?].! END
	cmpl	%eax, nil
	je	.L2494_else
	cmpl	%eax, false
	je	.L2494_else
	# then: [:do, [:callm, [:index, :__env__, 1], :<<, [[:index, :__env__, 2]]]]
	.stabn  68,0,707,.LM1425	
.LM1425:
	# callm [:index, :__env__, 1].:<<
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %edi
	addl	$4, %edi
	movl	(%edi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, %ecx
	addl	$8, %ecx
	movl	(%ecx), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt__lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].<< END
	# else: nil
.L2494_else:
	.stabn  68,0,708,.LM1426	
.LM1426:
	# callm [:index, :__env__, 1].:<<
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %edx
	addl	$4, %edx
	movl	(%edx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :item.:to_s
	subl	$24, %esp
	movl	-8(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_s(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm item.to_s END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt__lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].<< END
	addl	$4, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__lambda_L85, .-__lambda_L85
.Lscope314:
	.stabs  "",36,0,0,.Lscope314-.LFBB314	
		
	########################################################################	
		
		
		
		
		
		
		
	############################# __lambda_L86 #############################	
		
	.stabs  "__lambda_L86:F(0,0)",36,0,0,__lambda_L86	
.globl __lambda_L86
	.type	__lambda_L86, @function
__lambda_L86:
.LFBB315:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for i at position 5
	# :nil
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$4, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2497_else
	# then: [:assign, :"#i", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L2498_endif
	# else: [:assign, :"#i", :i]
.L2497_else:
	movl	20(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L2498_endif:
	# METHOD BODY:
	.stabn  68,0,725,.LM1427	
.LM1427:
	.stabn  68,0,726,.LM1428	
.LM1428:
	# callm [:index, :__env__, 1].:<<
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	movl	(%ecx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :self.:[]
	subl	$28, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, (%esp)
	movl	$0, 4(%esp)
	# callm :i.:+
	subl	$28, %esp
	movl	-8(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, %edx
	addl	$8, %edx
	movl	(%edx), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm i.+ END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	# Reload self?
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm self.[] END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt__lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].<< END
	addl	$4, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__lambda_L86, .-__lambda_L86
.Lscope315:
	.stabs  "",36,0,0,.Lscope315-.LFBB315	
		
	########################################################################	
		
		
		
		
		
		
		
	############################# __lambda_L87 #############################	
		
	.stabs  "__lambda_L87:F(0,0)",36,0,0,__lambda_L87	
.globl __lambda_L87
	.type	__lambda_L87, @function
__lambda_L87:
.LFBB316:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for item at position 5
	# :nil
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$4, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2500_else
	# then: [:assign, :"#item", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L2501_endif
	# else: [:assign, :"#item", :item]
.L2500_else:
	movl	20(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L2501_endif:
	# METHOD BODY:
	.stabn  68,0,763,.LM1429	
.LM1429:
	# callm :item.:!=
	subl	$28, %esp
	movl	-8(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	nil, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____X__3d(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm item.!= END
	addl	$4, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__lambda_L87, .-__lambda_L87
.Lscope316:
	.stabs  "",36,0,0,.Lscope316-.LFBB316	
		
	########################################################################	
		
		
		
		
		
		
		
	############################# __lambda_L88 #############################	
		
	.stabs  "__lambda_L88:F(0,0)",36,0,0,__lambda_L88	
.globl __lambda_L88
	.type	__lambda_L88, @function
__lambda_L88:
.LFBB317:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for item at position 5
	# :nil
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$4, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2503_else
	# then: [:assign, :"#item", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L2504_endif
	# else: [:assign, :"#item", :item]
.L2503_else:
	movl	20(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L2504_endif:
	# METHOD BODY:
	.stabn  68,0,807,.LM1430	
.LM1430:
	.stabn  68,0,808,.LM1431	
.LM1431:
	# if: [:callm, :item, :is_a?, [:Array]]
	# callm :item.:is_a?
	subl	$28, %esp
	movl	-8(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	Array, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__is_a__Q(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm item.is_a? END
	cmpl	%eax, nil
	je	.L2505_else
	cmpl	%eax, false
	je	.L2505_else
	# then: [:do, [:if, [:callm, [:callm, :item, :[], [[:sexp, :__I1]]], :==, [[:index, :__env__, 1]]], [:do, [:preturn, :item]]]]
	.stabn  68,0,809,.LM1432	
.LM1432:
	# if: [:callm, [:callm, :item, :[], [[:sexp, :__I1]]], :==, [[:index, :__env__, 1]]]
	# callm [:callm, :item, :[], [[:sexp, :__I1]]].:==
	subl	$28, %esp
	# callm :item.:[]
	subl	$28, %esp
	movl	-8(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm item.[] END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, %edx
	addl	$4, %edx
	movl	(%edx), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :item, :[], [[:sexp, :__I1]]].== END
	cmpl	%eax, nil
	je	.L2506_else
	cmpl	%eax, false
	je	.L2506_else
	# then: [:do, [:preturn, :item]]
	.stabn  68,0,810,.LM1433	
.LM1433:
	# preturn
	movl	-8(%ebp), %eax
	pushl	%eax
	movl	16(%ebp), %eax
	movl	%eax, %edi
	movl	(%edi), %eax
	movl	%eax, %ebp
	movl	-4(%ebp), %ebx
	popl	%eax
	leave	
	ret	
	# else: nil
.L2506_else:
	# else: nil
.L2505_else:
	addl	$4, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__lambda_L88, .-__lambda_L88
.Lscope317:
	.stabs  "",36,0,0,.Lscope317-.LFBB317	
		
	########################################################################	
		
		
		
		
		
		
		
	############################# __lambda_L89 #############################	
		
	.stabs  "__lambda_L89:F(0,0)",36,0,0,__lambda_L89	
.globl __lambda_L89
	.type	__lambda_L89, @function
__lambda_L89:
.LFBB318:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	subl	$8, %esp
	addl	$2, %ebx
	# Default argument for item at position 5
	# :nil
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$4, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2510_else
	# then: [:assign, :"#item", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L2511_endif
	# else: [:assign, :"#item", :item]
.L2510_else:
	movl	20(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L2511_endif:
	# Default argument for idx at position 6
	# :nil
	# if: [:lt, :numargs, 5]
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$5, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2512_else
	# then: [:assign, :"#idx", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	jmp	.L2513_endif
	# else: [:assign, :"#idx", :idx]
.L2512_else:
	movl	24(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
.L2513_endif:
	# METHOD BODY:
	.stabn  68,0,859,.LM1434	
.LM1434:
	.stabn  68,0,860,.LM1435	
.LM1435:
	# if: [:callm, :item, :==, [[:index, :__env__, 1]]]
	# callm :item.:==
	subl	$28, %esp
	movl	-8(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, %edi
	addl	$4, %edi
	movl	(%edi), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm item.== END
	cmpl	%eax, nil
	je	.L2514_else
	cmpl	%eax, false
	je	.L2514_else
	# then: [:do, [:assign, [:index, :__env__, 2], :idx]]
	.stabn  68,0,861,.LM1436	
.LM1436:
	movl	-12(%ebp), %eax
	pushl	%eax
	movl	16(%ebp), %eax
	movl	%eax, %ecx
	addl	$8, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	# else: nil
.L2514_else:
	addl	$8, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__lambda_L89, .-__lambda_L89
.Lscope318:
	.stabs  "",36,0,0,.Lscope318-.LFBB318	
		
	########################################################################	
		
		
		
		
		
		
		
	############################# __lambda_L90 #############################	
		
	.stabs  "__lambda_L90:F(0,0)",36,0,0,__lambda_L90	
.globl __lambda_L90
	.type	__lambda_L90, @function
__lambda_L90:
.LFBB319:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for e at position 5
	# :nil
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$4, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2517_else
	# then: [:assign, :"#e", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L2518_endif
	# else: [:assign, :"#e", :e]
.L2517_else:
	movl	20(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L2518_endif:
	# METHOD BODY:
	.stabn  68,0,891,.LM1437	
.LM1437:
	.stabn  68,0,892,.LM1438	
.LM1438:
	# if: [:callm, [:index, :__env__, 1], :call, [:e]]
	# callm [:index, :__env__, 1].:call
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %edi
	addl	$4, %edi
	movl	(%edi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	-8(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__call(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].call END
	cmpl	%eax, nil
	je	.L2519_else
	cmpl	%eax, false
	je	.L2519_else
	# then: [:do, [:callm, [:index, :__env__, 2], :<<, [:e]]]
	.stabn  68,0,893,.LM1439	
.LM1439:
	# callm [:index, :__env__, 2].:<<
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %ecx
	addl	$8, %ecx
	movl	(%ecx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	-8(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt__lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 2].<< END
	jmp	.L2520_endif
	# else: [:do, [:callm, [:index, :__env__, 3], :<<, [:e]]]
.L2519_else:
	.stabn  68,0,895,.LM1440	
.LM1440:
	# callm [:index, :__env__, 3].:<<
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %edx
	addl	$12, %edx
	movl	(%edx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	-8(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt__lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 3].<< END
.L2520_endif:
	addl	$4, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__lambda_L90, .-__lambda_L90
.Lscope319:
	.stabs  "",36,0,0,.Lscope319-.LFBB319	
		
	########################################################################	
		
		
		
		
		
		
		
	############################# __lambda_L91 #############################	
		
	.stabs  "__lambda_L91:F(0,0)",36,0,0,__lambda_L91	
.globl __lambda_L91
	.type	__lambda_L91, @function
__lambda_L91:
.LFBB320:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for e at position 5
	# :nil
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$4, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2522_else
	# then: [:assign, :"#e", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L2523_endif
	# else: [:assign, :"#e", :e]
.L2522_else:
	movl	20(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L2523_endif:
	# METHOD BODY:
	.stabn  68,0,916,.LM1441	
.LM1441:
	# callm [:callm, [:index, :__env__, 1], :call, [:e]].:<
	subl	$28, %esp
	# callm [:index, :__env__, 1].:call
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	movl	(%ecx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	-8(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__call(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].call END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, %edx
	addl	$8, %edx
	movl	(%edx), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:index, :__env__, 1], :call, [:e]].< END
	addl	$4, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__lambda_L91, .-__lambda_L91
.Lscope320:
	.stabs  "",36,0,0,.Lscope320-.LFBB320	
		
	########################################################################	
		
		
		
		
		
		
		
	############################# __lambda_L92 #############################	
		
	.stabs  "__lambda_L92:F(0,0)",36,0,0,__lambda_L92	
.globl __lambda_L92
	.type	__lambda_L92, @function
__lambda_L92:
.LFBB321:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for e at position 5
	# :nil
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$4, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2525_else
	# then: [:assign, :"#e", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L2526_endif
	# else: [:assign, :"#e", :e]
.L2525_else:
	movl	20(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L2526_endif:
	# METHOD BODY:
	.stabn  68,0,936,.LM1442	
.LM1442:
	movl	16(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	movl	(%ecx), %eax
	.stabn  68,0,938,.LM1443	
.LM1443:
	# callm [:callm, :e, :<=>, [[:index, :__env__, 1]]].:<=
	subl	$28, %esp
	# callm :e.:<=>
	subl	$28, %esp
	movl	-8(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, %edx
	addl	$4, %edx
	movl	(%edx), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____le__gt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm e.<=> END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I0, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____le(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :e, :<=>, [[:index, :__env__, 1]]].<= END
	addl	$4, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__lambda_L92, .-__lambda_L92
.Lscope321:
	.stabs  "",36,0,0,.Lscope321-.LFBB321	
		
	########################################################################	
		
		
		
		
		
		
		
	############################# __lambda_L93 #############################	
		
	.stabs  "__lambda_L93:F(0,0)",36,0,0,__lambda_L93	
.globl __lambda_L93
	.type	__lambda_L93, @function
__lambda_L93:
.LFBB322:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for item at position 5
	# :nil
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$4, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2528_else
	# then: [:assign, :"#item", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L2529_endif
	# else: [:assign, :"#item", :item]
.L2528_else:
	movl	20(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L2529_endif:
	# METHOD BODY:
	.stabn  68,0,984,.LM1444	
.LM1444:
	.stabn  68,0,985,.LM1445	
.LM1445:
	# if: [:callm, [:callm, [:index, :__env__, 1], :include?, [:item]], :!]
	# callm [:callm, [:index, :__env__, 1], :include?, [:item]].:!
	subl	$24, %esp
	# callm [:index, :__env__, 1].:include?
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	movl	(%ecx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	-8(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__include__Q(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].include? END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____X(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:index, :__env__, 1], :include?, [:item]].! END
	cmpl	%eax, nil
	je	.L2530_else
	cmpl	%eax, false
	je	.L2530_else
	# then: [:do, [:callm, [:index, :__env__, 1], :<<, [:item]]]
	.stabn  68,0,986,.LM1446	
.LM1446:
	# callm [:index, :__env__, 1].:<<
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %edx
	addl	$4, %edx
	movl	(%edx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	-8(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt__lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].<< END
	# else: nil
.L2530_else:
	addl	$4, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__lambda_L93, .-__lambda_L93
.Lscope322:
	.stabs  "",36,0,0,.Lscope322-.LFBB322	
		
	########################################################################	
		
		
		
		
		
		
		
	############################# __lambda_L94 #############################	
		
	.stabs  "__lambda_L94:F(0,0)",36,0,0,__lambda_L94	
.globl __lambda_L94
	.type	__lambda_L94, @function
__lambda_L94:
.LFBB323:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for a at position 5
	# :nil
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$4, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2533_else
	# then: [:assign, :"#a", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L2534_endif
	# else: [:assign, :"#a", :a]
.L2533_else:
	movl	20(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L2534_endif:
	# METHOD BODY:
	.stabn  68,0,1041,.LM1447	
.LM1447:
	# callm :a.:to_enum
	subl	$24, %esp
	movl	-8(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__to_enum(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm a.to_enum END
	addl	$4, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__lambda_L94, .-__lambda_L94
.Lscope323:
	.stabs  "",36,0,0,.Lscope323-.LFBB323	
		
	########################################################################	
		
		
		
		
		
		
		
	############################# __lambda_L95 #############################	
		
	.stabs  "__lambda_L95:F(0,0)",36,0,0,__lambda_L95	
.globl __lambda_L95
	.type	__lambda_L95, @function
__lambda_L95:
.LFBB324:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for a at position 5
	# :nil
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$4, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2536_else
	# then: [:assign, :"#a", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L2537_endif
	# else: [:assign, :"#a", :a]
.L2536_else:
	movl	20(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L2537_endif:
	# METHOD BODY:
	.stabn  68,0,1043,.LM1448	
.LM1448:
	.stabn  68,0,1044,.LM1449	
.LM1449:
	# callm :Array.:[]
	subl	$28, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	-8(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm Array.[] END
	pushl	%eax
	movl	16(%ebp), %eax
	movl	%eax, %edx
	addl	$8, %edx
	popl	%eax
	movl	%eax, (%edx)
	# callm [:index, :__env__, 1].:each
	subl	$24, %esp
	movl	16(%ebp), %eax
	movl	%eax, %edi
	addl	$4, %edi
	movl	(%edi), %eax
	movl	%eax, (%esp)
	.stabn  68,0,1045,.LM1450	
.LM1450:
	# Stack frame
	pushl	%ebp
	movl	16(%ebp), %eax
	movl	%eax, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	movl	$__lambda_L96, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -20(%ebp)
	subl	$32, %esp
	movl	-20(%ebp), %eax
	movl	%eax, (%esp)
	movl	16(%ebp), %eax
	movl	%eax, 4(%esp)
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, 8(%esp)
	movl	$1, 12(%esp)
	movl	$4, %ebx
	call	__new_proc
	addl	$32, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__each(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].each END
	movl	16(%ebp), %eax
	movl	%eax, %edx
	addl	$8, %edx
	movl	(%edx), %eax
	addl	$4, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__lambda_L95, .-__lambda_L95
.Lscope324:
	.stabs  "",36,0,0,.Lscope324-.LFBB324	
		
	########################################################################	
		
		
		
		
		
		
		
	############################# __lambda_L97 #############################	
		
	.stabs  "__lambda_L97:F(0,0)",36,0,0,__lambda_L97	
.globl __lambda_L97
	.type	__lambda_L97, @function
__lambda_L97:
.LFBB325:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for b at position 5
	# :nil
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$4, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2540_else
	# then: [:assign, :"#b", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L2541_endif
	# else: [:assign, :"#b", :b]
.L2540_else:
	movl	20(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L2541_endif:
	# METHOD BODY:
	.stabn  68,0,40,.LM1451	
.LM1451:
	.stabn  68,0,41,.LM1452	
.LM1452:
	# if: [:callm, :b, :==, [[:sexp, :__I34]]]
	# callm :b.:==
	subl	$28, %esp
	movl	-8(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I34, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm b.== END
	cmpl	%eax, nil
	je	.L2542_else
	cmpl	%eax, false
	je	.L2542_else
	# then: [:do, [:callm, [:callm, [:index, :__env__, 1], :<<, [[:index, :__env__, 2]]], :<<, [[:callm, [:sexp, :__I34], :chr]]]]
	.stabn  68,0,42,.LM1453	
.LM1453:
	# callm [:callm, [:index, :__env__, 1], :<<, [[:index, :__env__, 2]]].:<<
	subl	$28, %esp
	# callm [:index, :__env__, 1].:<<
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	movl	(%ecx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, %edx
	addl	$8, %edx
	movl	(%edx), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt__lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].<< END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm [:sexp, :__I34].:chr
	subl	$24, %esp
	movl	__I34, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__chr(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:sexp, :__I34].chr END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt__lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:index, :__env__, 1], :<<, [[:index, :__env__, 2]]].<< END
	jmp	.L2543_endif
	# else: [:do, [:if, [:callm, :b, :==, [[:sexp, :__I27]]], [:do, [:callm, [:callm, [:index, :__env__, 1], :<<, [[:index, :__env__, 2]]], :<<, [[:sexp, [:call, :__get_string, :".L16"]]]]], [:do, [:if, [:callm, :b, :==, [[:sexp, :__I92]]], [:do, [:callm, [:callm, [:index, :__env__, 1], :<<, [[:index, :__env__, 2]]], :<<, [[:index, :__env__, 2]]]], [:do, [:if, [:callm, :b, :==, [[:sexp, :__I10]]], [:do, [:callm, [:callm, [:index, :__env__, 1], :<<, [[:index, :__env__, 2]]], :<<, [[:sexp, [:call, :__get_string, :".L17"]]]]], [:do, [:callm, [:index, :__env__, 1], :<<, [[:callm, :b, :chr]]]]]]]]]]
.L2542_else:
	.stabn  68,0,43,.LM1454	
.LM1454:
	# if: [:callm, :b, :==, [[:sexp, :__I27]]]
	# callm :b.:==
	subl	$28, %esp
	movl	-8(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I27, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm b.== END
	cmpl	%eax, nil
	je	.L2544_else
	cmpl	%eax, false
	je	.L2544_else
	# then: [:do, [:callm, [:callm, [:index, :__env__, 1], :<<, [[:index, :__env__, 2]]], :<<, [[:sexp, [:call, :__get_string, :".L16"]]]]]
	.stabn  68,0,44,.LM1455	
.LM1455:
	# callm [:callm, [:index, :__env__, 1], :<<, [[:index, :__env__, 2]]].:<<
	subl	$28, %esp
	# callm [:index, :__env__, 1].:<<
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %edi
	addl	$4, %edi
	movl	(%edi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, %ecx
	addl	$8, %ecx
	movl	(%ecx), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt__lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].<< END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	subl	$20, %esp
	movl	$.L16, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt__lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:index, :__env__, 1], :<<, [[:index, :__env__, 2]]].<< END
	jmp	.L2545_endif
	# else: [:do, [:if, [:callm, :b, :==, [[:sexp, :__I92]]], [:do, [:callm, [:callm, [:index, :__env__, 1], :<<, [[:index, :__env__, 2]]], :<<, [[:index, :__env__, 2]]]], [:do, [:if, [:callm, :b, :==, [[:sexp, :__I10]]], [:do, [:callm, [:callm, [:index, :__env__, 1], :<<, [[:index, :__env__, 2]]], :<<, [[:sexp, [:call, :__get_string, :".L17"]]]]], [:do, [:callm, [:index, :__env__, 1], :<<, [[:callm, :b, :chr]]]]]]]]
.L2544_else:
	.stabn  68,0,45,.LM1456	
.LM1456:
	# if: [:callm, :b, :==, [[:sexp, :__I92]]]
	# callm :b.:==
	subl	$28, %esp
	movl	-8(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I92, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm b.== END
	cmpl	%eax, nil
	je	.L2546_else
	cmpl	%eax, false
	je	.L2546_else
	# then: [:do, [:callm, [:callm, [:index, :__env__, 1], :<<, [[:index, :__env__, 2]]], :<<, [[:index, :__env__, 2]]]]
	.stabn  68,0,46,.LM1457	
.LM1457:
	# callm [:callm, [:index, :__env__, 1], :<<, [[:index, :__env__, 2]]].:<<
	subl	$28, %esp
	# callm [:index, :__env__, 1].:<<
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %edx
	addl	$4, %edx
	movl	(%edx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, %edi
	addl	$8, %edi
	movl	(%edi), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt__lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].<< END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, %ecx
	addl	$8, %ecx
	movl	(%ecx), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt__lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:index, :__env__, 1], :<<, [[:index, :__env__, 2]]].<< END
	jmp	.L2547_endif
	# else: [:do, [:if, [:callm, :b, :==, [[:sexp, :__I10]]], [:do, [:callm, [:callm, [:index, :__env__, 1], :<<, [[:index, :__env__, 2]]], :<<, [[:sexp, [:call, :__get_string, :".L17"]]]]], [:do, [:callm, [:index, :__env__, 1], :<<, [[:callm, :b, :chr]]]]]]
.L2546_else:
	.stabn  68,0,47,.LM1458	
.LM1458:
	# if: [:callm, :b, :==, [[:sexp, :__I10]]]
	# callm :b.:==
	subl	$28, %esp
	movl	-8(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I10, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm b.== END
	cmpl	%eax, nil
	je	.L2548_else
	cmpl	%eax, false
	je	.L2548_else
	# then: [:do, [:callm, [:callm, [:index, :__env__, 1], :<<, [[:index, :__env__, 2]]], :<<, [[:sexp, [:call, :__get_string, :".L17"]]]]]
	.stabn  68,0,48,.LM1459	
.LM1459:
	# callm [:callm, [:index, :__env__, 1], :<<, [[:index, :__env__, 2]]].:<<
	subl	$28, %esp
	# callm [:index, :__env__, 1].:<<
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %edx
	addl	$4, %edx
	movl	(%edx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, %edi
	addl	$8, %edi
	movl	(%edi), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt__lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].<< END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	subl	$20, %esp
	movl	$.L17, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt__lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:index, :__env__, 1], :<<, [[:index, :__env__, 2]]].<< END
	jmp	.L2549_endif
	# else: [:do, [:callm, [:index, :__env__, 1], :<<, [[:callm, :b, :chr]]]]
.L2548_else:
	.stabn  68,0,50,.LM1460	
.LM1460:
	# callm [:index, :__env__, 1].:<<
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	movl	(%ecx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :b.:chr
	subl	$24, %esp
	movl	-8(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__chr(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm b.chr END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt__lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].<< END
.L2549_endif:
.L2547_endif:
.L2545_endif:
.L2543_endif:
	addl	$4, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__lambda_L97, .-__lambda_L97
.Lscope325:
	.stabs  "",36,0,0,.Lscope325-.LFBB325	
		
	########################################################################	
		
		
		
		
		
		
		
	############################# __lambda_L98 #############################	
		
	.stabs  "__lambda_L98:F(0,0)",36,0,0,__lambda_L98	
.globl __lambda_L98
	.type	__lambda_L98, @function
__lambda_L98:
.LFBB326:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for c at position 5
	# :nil
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$4, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2551_else
	# then: [:assign, :"#c", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L2552_endif
	# else: [:assign, :"#c", :c]
.L2551_else:
	movl	20(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L2552_endif:
	# METHOD BODY:
	.stabn  68,0,60,.LM1461	
.LM1461:
	.stabn  68,0,61,.LM1462	
.LM1462:
	# callm [:callm, [:index, :__env__, 1], :*, [[:sexp, :__I33]]].:+
	subl	$28, %esp
	# callm [:index, :__env__, 1].:*
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %edi
	addl	$4, %edi
	movl	(%edi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I33, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____mul(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].* END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	-8(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, [:index, :__env__, 1], :*, [[:sexp, :__I33]]].+ END
	pushl	%eax
	movl	16(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	addl	$4, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__lambda_L98, .-__lambda_L98
.Lscope326:
	.stabs  "",36,0,0,.Lscope326-.LFBB326	
		
	########################################################################	
		
		
		
		
		
		
		
	############################# __lambda_L99 #############################	
		
	.stabs  "__lambda_L99:F(0,0)",36,0,0,__lambda_L99	
.globl __lambda_L99
	.type	__lambda_L99, @function
__lambda_L99:
.LFBB327:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for b at position 5
	# :nil
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$4, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2554_else
	# then: [:assign, :"#b", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L2555_endif
	# else: [:assign, :"#b", :b]
.L2554_else:
	movl	20(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L2555_endif:
	# METHOD BODY:
	.stabn  68,0,301,.LM1463	
.LM1463:
	.stabn  68,0,302,.LM1464	
.LM1464:
	# if: [:callm, :b, :==, [[:index, :__env__, 1]]]
	# callm :b.:==
	subl	$28, %esp
	movl	-8(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, %edi
	addl	$4, %edi
	movl	(%edi), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm b.== END
	cmpl	%eax, nil
	je	.L2556_else
	cmpl	%eax, false
	je	.L2556_else
	# then: [:do, [:assign, [:index, :__env__, 2], [:callm, [:index, :__env__, 2], :+, [[:sexp, :__I1]]]]]
	.stabn  68,0,303,.LM1465	
.LM1465:
	# callm [:index, :__env__, 2].:+
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %ecx
	addl	$8, %ecx
	movl	(%ecx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 2].+ END
	pushl	%eax
	movl	16(%ebp), %eax
	movl	%eax, %edx
	addl	$8, %edx
	popl	%eax
	movl	%eax, (%edx)
	# else: nil
.L2556_else:
	addl	$4, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__lambda_L99, .-__lambda_L99
.Lscope327:
	.stabs  "",36,0,0,.Lscope327-.LFBB327	
		
	########################################################################	
		
		
		
		
		
		
		
	############################ __lambda_L100 #############################	
		
	.stabs  "__lambda_L100:F(0,0)",36,0,0,__lambda_L100	
.globl __lambda_L100
	.type	__lambda_L100, @function
__lambda_L100:
.LFBB328:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	# METHOD BODY:
	.stabn  68,0,347,.LM1466	
.LM1466:
	.stabn  68,0,348,.LM1467	
.LM1467:
	# callm [:index, :__env__, 1].:concat
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %edi
	addl	$4, %edi
	movl	(%edi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%esi, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__concat(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].concat END
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__lambda_L100, .-__lambda_L100
.Lscope328:
	.stabs  "",36,0,0,.Lscope328-.LFBB328	
		
	########################################################################	
		
		
		
		
		
		
		
	############################ __lambda_L101 #############################	
		
	.stabs  "__lambda_L101:F(0,0)",36,0,0,__lambda_L101	
.globl __lambda_L101
	.type	__lambda_L101, @function
__lambda_L101:
.LFBB329:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for b at position 5
	# :nil
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$4, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2560_else
	# then: [:assign, :"#b", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L2561_endif
	# else: [:assign, :"#b", :b]
.L2560_else:
	movl	20(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L2561_endif:
	# METHOD BODY:
	.stabn  68,0,377,.LM1468	
.LM1468:
	.stabn  68,0,378,.LM1469	
.LM1469:
	# if: [:callm, :b, :==, [[:index, :__env__, 1]]]
	# callm :b.:==
	subl	$28, %esp
	movl	-8(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, %edx
	addl	$4, %edx
	movl	(%edx), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm b.== END
	cmpl	%eax, nil
	je	.L2562_else
	cmpl	%eax, false
	je	.L2562_else
	# then: [:do, [:callm, [:index, :__env__, 2], :<<, [[:index, :__env__, 3]]]]
	.stabn  68,0,379,.LM1470	
.LM1470:
	# callm [:index, :__env__, 2].:<<
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %edi
	addl	$8, %edi
	movl	(%edi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, %ecx
	addl	$12, %ecx
	movl	(%ecx), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt__lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 2].<< END
	jmp	.L2563_endif
	# else: [:do, [:callm, [:index, :__env__, 2], :<<, [[:callm, :b, :chr]]]]
.L2562_else:
	.stabn  68,0,381,.LM1471	
.LM1471:
	# callm [:index, :__env__, 2].:<<
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %edx
	addl	$8, %edx
	movl	(%edx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :b.:chr
	subl	$24, %esp
	movl	-8(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__chr(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm b.chr END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt__lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 2].<< END
.L2563_endif:
	addl	$4, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__lambda_L101, .-__lambda_L101
.Lscope329:
	.stabs  "",36,0,0,.Lscope329-.LFBB329	
		
	########################################################################	
		
		
		
		
		
		
		
	############################ __lambda_L102 #############################	
		
	.stabs  "__lambda_L102:F(0,0)",36,0,0,__lambda_L102	
.globl __lambda_L102
	.type	__lambda_L102, @function
__lambda_L102:
.LFBB330:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for c at position 5
	# :nil
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$4, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2565_else
	# then: [:assign, :"#c", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L2566_endif
	# else: [:assign, :"#c", :c]
.L2565_else:
	movl	20(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L2566_endif:
	# METHOD BODY:
	.stabn  68,0,393,.LM1472	
.LM1472:
	.stabn  68,0,394,.LM1473	
.LM1473:
	# if: [:callm, [:callm, :c, :chr], :==, [[:index, :__env__, 1]]]
	# callm [:callm, :c, :chr].:==
	subl	$28, %esp
	# callm :c.:chr
	subl	$24, %esp
	movl	-8(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__chr(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm c.chr END
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, %ecx
	addl	$4, %ecx
	movl	(%ecx), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:callm, :c, :chr].== END
	cmpl	%eax, nil
	je	.L2567_else
	cmpl	%eax, false
	je	.L2567_else
	# then: [:do, [:callm, [:index, :__env__, 2], :<<, [[:index, :__env__, 3]]], [:assign, [:index, :__env__, 3], [:sexp, [:call, :__get_string, :".L0"]]]]
	.stabn  68,0,395,.LM1474	
.LM1474:
	# callm [:index, :__env__, 2].:<<
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %edx
	addl	$8, %edx
	movl	(%edx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, %edi
	addl	$12, %edi
	movl	(%edi), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt__lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 2].<< END
	subl	$20, %esp
	movl	$.L0, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	movl	16(%ebp), %eax
	movl	%eax, %ecx
	addl	$12, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	jmp	.L2568_endif
	# else: [:do, [:if, [:and, [:callm, [:index, :__env__, 1], :==, [[:sexp, [:call, :__get_string, :".L22"]]]], [:or, [:callm, :c, :==, [[:sexp, :__I10]]], [:or, [:callm, :c, :==, [[:sexp, :__I13]]], [:callm, :c, :==, [[:sexp, :__I9]]]]]], [:do, [:callm, [:index, :__env__, 2], :<<, [[:index, :__env__, 3]]], [:assign, [:index, :__env__, 3], [:sexp, [:call, :__get_string, :".L0"]]]], [:do, [:callm, [:index, :__env__, 3], :<<, [[:callm, :c, :chr]]]]]]
.L2567_else:
	.stabn  68,0,397,.LM1475	
.LM1475:
	# if: [:and, [:callm, [:index, :__env__, 1], :==, [[:sexp, [:call, :__get_string, :".L22"]]]], [:or, [:callm, :c, :==, [[:sexp, :__I10]]], [:or, [:callm, :c, :==, [[:sexp, :__I13]]], [:callm, :c, :==, [[:sexp, :__I9]]]]]]
	# if: [:callm, [:index, :__env__, 1], :==, [[:sexp, [:call, :__get_string, :".L22"]]]]
	# callm [:index, :__env__, 1].:==
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %edx
	addl	$4, %edx
	movl	(%edx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	subl	$20, %esp
	movl	$.L22, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].== END
	cmpl	%eax, nil
	je	.L2569_else
	cmpl	%eax, false
	je	.L2569_else
	# then: [:or, [:callm, :c, :==, [[:sexp, :__I10]]], [:or, [:callm, :c, :==, [[:sexp, :__I13]]], [:callm, :c, :==, [[:sexp, :__I9]]]]]
	# compile_or: [:callm, :c, :==, [[:sexp, :__I10]]] || [:or, [:callm, :c, :==, [[:sexp, :__I13]]], [:callm, :c, :==, [[:sexp, :__I9]]]]
	# callm :c.:==
	subl	$28, %esp
	movl	-8(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I10, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm c.== END
	cmpl	%eax, nil
	je	.L2570_or
	cmpl	%eax, false
	je	.L2570_or
	jmp	.L2571_end_or
	# .. or:
.L2570_or:
	# compile_or: [:callm, :c, :==, [[:sexp, :__I13]]] || [:callm, :c, :==, [[:sexp, :__I9]]]
	# callm :c.:==
	subl	$28, %esp
	movl	-8(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I13, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm c.== END
	cmpl	%eax, nil
	je	.L2572_or
	cmpl	%eax, false
	je	.L2572_or
	jmp	.L2573_end_or
	# .. or:
.L2572_or:
	# callm :c.:==
	subl	$28, %esp
	movl	-8(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I9, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm c.== END
.L2573_end_or:
.L2571_end_or:
	# else: nil
.L2569_else:
	cmpl	%eax, nil
	je	.L2575_else
	cmpl	%eax, false
	je	.L2575_else
	# then: [:do, [:callm, [:index, :__env__, 2], :<<, [[:index, :__env__, 3]]], [:assign, [:index, :__env__, 3], [:sexp, [:call, :__get_string, :".L0"]]]]
	.stabn  68,0,398,.LM1476	
.LM1476:
	# callm [:index, :__env__, 2].:<<
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %edi
	addl	$8, %edi
	movl	(%edi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	16(%ebp), %eax
	movl	%eax, %ecx
	addl	$12, %ecx
	movl	(%ecx), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt__lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 2].<< END
	subl	$20, %esp
	movl	$.L0, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	pushl	%eax
	movl	16(%ebp), %eax
	movl	%eax, %edx
	addl	$12, %edx
	popl	%eax
	movl	%eax, (%edx)
	jmp	.L2576_endif
	# else: [:do, [:callm, [:index, :__env__, 3], :<<, [[:callm, :c, :chr]]]]
.L2575_else:
	.stabn  68,0,401,.LM1477	
.LM1477:
	# callm [:index, :__env__, 3].:<<
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %edi
	addl	$12, %edi
	movl	(%edi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :c.:chr
	subl	$24, %esp
	movl	-8(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__chr(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm c.chr END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt__lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 3].<< END
.L2576_endif:
.L2568_endif:
	addl	$4, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__lambda_L102, .-__lambda_L102
.Lscope330:
	.stabs  "",36,0,0,.Lscope330-.LFBB330	
		
	########################################################################	
		
		
		
		
		
		
		
	############################ __lambda_L103 #############################	
		
	.stabs  "__lambda_L103:F(0,0)",36,0,0,__lambda_L103	
.globl __lambda_L103
	.type	__lambda_L103, @function
__lambda_L103:
.LFBB331:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	subl	$8, %esp
	addl	$2, %ebx
	# Default argument for k at position 5
	# :nil
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$4, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2578_else
	# then: [:assign, :"#k", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L2579_endif
	# else: [:assign, :"#k", :k]
.L2578_else:
	movl	20(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L2579_endif:
	# Default argument for v at position 6
	# :nil
	# if: [:lt, :numargs, 5]
	movl	-4(%ebp), %eax
	movl	%eax, %edx
	movl	$5, %eax
	cmpl	%eax, %edx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2580_else
	# then: [:assign, :"#v", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	jmp	.L2581_endif
	# else: [:assign, :"#v", :v]
.L2580_else:
	movl	24(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
.L2581_endif:
	# METHOD BODY:
	.stabn  68,0,174,.LM1478	
.LM1478:
	.stabn  68,0,175,.LM1479	
.LM1479:
	# callm [:index, :__env__, 1].:<<
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %edi
	addl	$4, %edi
	movl	(%edi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :Array.:[]
	subl	$32, %esp
	movl	Array, %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	-8(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	-12(%ebp), %eax
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 32
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm Array.[] END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt__lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].<< END
	addl	$8, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__lambda_L103, .-__lambda_L103
.Lscope331:
	.stabs  "",36,0,0,.Lscope331-.LFBB331	
		
	########################################################################	
		
		
		
		
		
		
		
	############################ __lambda_L104 #############################	
		
	.stabs  "__lambda_L104:F(0,0)",36,0,0,__lambda_L104	
.globl __lambda_L104
	.type	__lambda_L104, @function
__lambda_L104:
.LFBB332:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for e at position 5
	# :nil
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$4, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2583_else
	# then: [:assign, :"#e", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L2584_endif
	# else: [:assign, :"#e", :e]
.L2583_else:
	movl	20(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L2584_endif:
	# METHOD BODY:
	.stabn  68,0,78,.LM1480	
.LM1480:
	.stabn  68,0,79,.LM1481	
.LM1481:
	# if: [:callm, :e, :==, [[:sexp, [:call, :__get_string, :".L26"]]]]
	# callm :e.:==
	subl	$28, %esp
	movl	-8(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	subl	$20, %esp
	movl	$.L26, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm e.== END
	cmpl	%eax, nil
	je	.L2585_else
	cmpl	%eax, false
	je	.L2585_else
	# then: [:do]
	movl	nil, %eax
	jmp	.L2586_endif
	# else: [:do, [:if, [:callm, :e, :==, [[:sexp, [:call, :__get_string, :".L0"]]]], [:do], [:do, [:if, [:callm, :e, :==, [[:sexp, [:call, :__get_string, :".L10"]]]], [:do, [:callm, [:index, :__env__, 1], :pop]], [:do, [:callm, [:index, :__env__, 1], :<<, [:e]]]]]]]
.L2585_else:
	.stabn  68,0,81,.LM1482	
.LM1482:
	# if: [:callm, :e, :==, [[:sexp, [:call, :__get_string, :".L0"]]]]
	# callm :e.:==
	subl	$28, %esp
	movl	-8(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	subl	$20, %esp
	movl	$.L0, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm e.== END
	cmpl	%eax, nil
	je	.L2587_else
	cmpl	%eax, false
	je	.L2587_else
	# then: [:do]
	movl	nil, %eax
	jmp	.L2588_endif
	# else: [:do, [:if, [:callm, :e, :==, [[:sexp, [:call, :__get_string, :".L10"]]]], [:do, [:callm, [:index, :__env__, 1], :pop]], [:do, [:callm, [:index, :__env__, 1], :<<, [:e]]]]]
.L2587_else:
	.stabn  68,0,83,.LM1483	
.LM1483:
	# if: [:callm, :e, :==, [[:sexp, [:call, :__get_string, :".L10"]]]]
	# callm :e.:==
	subl	$28, %esp
	movl	-8(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	subl	$20, %esp
	movl	$.L10, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____eq(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm e.== END
	cmpl	%eax, nil
	je	.L2589_else
	cmpl	%eax, false
	je	.L2589_else
	# then: [:do, [:callm, [:index, :__env__, 1], :pop]]
	.stabn  68,0,84,.LM1484	
.LM1484:
	# callm [:index, :__env__, 1].:pop
	subl	$24, %esp
	movl	16(%ebp), %eax
	movl	%eax, %edx
	addl	$4, %edx
	movl	(%edx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__pop(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].pop END
	jmp	.L2590_endif
	# else: [:do, [:callm, [:index, :__env__, 1], :<<, [:e]]]
.L2589_else:
	.stabn  68,0,86,.LM1485	
.LM1485:
	# callm [:index, :__env__, 1].:<<
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %edi
	addl	$4, %edi
	movl	(%edi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	-8(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt__lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].<< END
.L2590_endif:
.L2588_endif:
.L2586_endif:
	addl	$4, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__lambda_L104, .-__lambda_L104
.Lscope332:
	.stabs  "",36,0,0,.Lscope332-.LFBB332	
		
	########################################################################	
		
		
		
		
		
		
		
	############################ __lambda_L105 #############################	
		
	.stabs  "__lambda_L105:F(0,0)",36,0,0,__lambda_L105	
.globl __lambda_L105
	.type	__lambda_L105, @function
__lambda_L105:
.LFBB333:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for pair at position 5
	# :nil
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$4, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2592_else
	# then: [:assign, :"#pair", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L2593_endif
	# else: [:assign, :"#pair", :pair]
.L2592_else:
	movl	20(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L2593_endif:
	# METHOD BODY:
	.stabn  68,0,29,.LM1486	
.LM1486:
	# callm [:index, :__env__, 1].:call
	subl	$32, %esp
	movl	16(%ebp), %eax
	movl	%eax, %edx
	addl	$4, %edx
	movl	(%edx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :pair.:[]
	subl	$28, %esp
	movl	-8(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I0, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm pair.[] END
	movl	%eax, 8(%esp)
	# callm :pair.:[]
	subl	$28, %esp
	movl	-8(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	__I1, %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____NDX(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm pair.[] END
	movl	%eax, 12(%esp)
	movl	$4, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__call(%eax)
	# Evicting self
	# Static adj: 32
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].call END
	addl	$4, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__lambda_L105, .-__lambda_L105
.Lscope333:
	.stabs  "",36,0,0,.Lscope333-.LFBB333	
		
	########################################################################	
		
		
		
		
		
		
		
	############################ __lambda_L106 #############################	
		
	.stabs  "__lambda_L106:F(0,0)",36,0,0,__lambda_L106	
.globl __lambda_L106
	.type	__lambda_L106, @function
__lambda_L106:
.LFBB334:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	subl	$8, %esp
	addl	$2, %ebx
	# Default argument for k at position 5
	# :nil
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$4, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2595_else
	# then: [:assign, :"#k", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L2596_endif
	# else: [:assign, :"#k", :k]
.L2595_else:
	movl	20(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L2596_endif:
	# Default argument for v at position 6
	# :nil
	# if: [:lt, :numargs, 5]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$5, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2597_else
	# then: [:assign, :"#v", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	jmp	.L2598_endif
	# else: [:assign, :"#v", :v]
.L2597_else:
	movl	24(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
.L2598_endif:
	# METHOD BODY:
	.stabn  68,0,38,.LM1487	
.LM1487:
	.stabn  68,0,39,.LM1488	
.LM1488:
	# if: [:callm, [:index, :__env__, 1], :!]
	# callm [:index, :__env__, 1].:!
	subl	$24, %esp
	movl	16(%ebp), %eax
	movl	%eax, %edx
	addl	$4, %edx
	movl	(%edx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____X(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].! END
	cmpl	%eax, nil
	je	.L2599_else
	cmpl	%eax, false
	je	.L2599_else
	# then: [:do, [:assign, [:index, :__env__, 2], [:callm, [:index, :__env__, 2], :+, [[:sexp, [:call, :__get_string, :".L14"]]]]]]
	.stabn  68,0,40,.LM1489	
.LM1489:
	# callm [:index, :__env__, 2].:+
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %edi
	addl	$8, %edi
	movl	(%edi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	subl	$20, %esp
	movl	$.L14, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 2].+ END
	pushl	%eax
	movl	16(%ebp), %eax
	movl	%eax, %ecx
	addl	$8, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	jmp	.L2600_endif
	# else: [:do, [:assign, [:index, :__env__, 1], :false]]
.L2599_else:
	.stabn  68,0,42,.LM1490	
.LM1490:
	movl	false, %eax
	pushl	%eax
	movl	16(%ebp), %eax
	movl	%eax, %edx
	addl	$4, %edx
	popl	%eax
	movl	%eax, (%edx)
.L2600_endif:
	.stabn  68,0,43,.LM1491	
.LM1491:
	# callm [:index, :__env__, 2].:+
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %edi
	addl	$8, %edi
	movl	(%edi), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :k.:inspect
	subl	$24, %esp
	movl	-8(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__inspect(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm k.inspect END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 2].+ END
	pushl	%eax
	movl	16(%ebp), %eax
	movl	%eax, %ecx
	addl	$8, %ecx
	popl	%eax
	movl	%eax, (%ecx)
	.stabn  68,0,44,.LM1492	
.LM1492:
	# callm [:index, :__env__, 2].:+
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %edx
	addl	$8, %edx
	movl	(%edx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	subl	$20, %esp
	movl	$.L57, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_string
	addl	$20, %esp
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 2].+ END
	pushl	%eax
	movl	16(%ebp), %eax
	movl	%eax, %edi
	addl	$8, %edi
	popl	%eax
	movl	%eax, (%edi)
	.stabn  68,0,45,.LM1493	
.LM1493:
	# callm [:index, :__env__, 2].:+
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %ecx
	addl	$8, %ecx
	movl	(%ecx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :v.:inspect
	subl	$24, %esp
	movl	-12(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__inspect(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm v.inspect END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____plus(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 2].+ END
	pushl	%eax
	movl	16(%ebp), %eax
	movl	%eax, %edx
	addl	$8, %edx
	popl	%eax
	movl	%eax, (%edx)
	addl	$8, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__lambda_L106, .-__lambda_L106
.Lscope334:
	.stabs  "",36,0,0,.Lscope334-.LFBB334	
		
	########################################################################	
		
		
		
		
		
		
		
	############################ __lambda_L107 #############################	
		
	.stabs  "__lambda_L107:F(0,0)",36,0,0,__lambda_L107	
.globl __lambda_L107
	.type	__lambda_L107, @function
__lambda_L107:
.LFBB335:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	subl	$8, %esp
	addl	$2, %ebx
	# Default argument for k at position 5
	# :nil
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$4, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2602_else
	# then: [:assign, :"#k", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L2603_endif
	# else: [:assign, :"#k", :k]
.L2602_else:
	movl	20(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L2603_endif:
	# Default argument for v at position 6
	# :nil
	# if: [:lt, :numargs, 5]
	movl	-4(%ebp), %eax
	movl	%eax, %ecx
	movl	$5, %eax
	cmpl	%eax, %ecx
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2604_else
	# then: [:assign, :"#v", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
	jmp	.L2605_endif
	# else: [:assign, :"#v", :v]
.L2604_else:
	movl	24(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -12(%ebp)
.L2605_endif:
	# METHOD BODY:
	.stabn  68,0,55,.LM1494	
.LM1494:
	.stabn  68,0,56,.LM1495	
.LM1495:
	# callm [:index, :__env__, 1].:<<
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %edx
	addl	$4, %edx
	movl	(%edx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	-8(%ebp), %eax
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt__lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 1].<< END
	addl	$8, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__lambda_L107, .-__lambda_L107
.Lscope335:
	.stabs  "",36,0,0,.Lscope335-.LFBB335	
		
	########################################################################	
		
		
		
		
		
		
		
	############################# __lambda_L96 #############################	
		
	.stabs  "__lambda_L96:F(0,0)",36,0,0,__lambda_L96	
.globl __lambda_L96
	.type	__lambda_L96, @function
__lambda_L96:
.LFBB336:
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ebx
	subl	$4, %esp
	addl	$1, %ebx
	# Default argument for e at position 5
	# :nil
	# if: [:lt, :numargs, 4]
	movl	-4(%ebp), %eax
	movl	%eax, %edi
	movl	$4, %eax
	cmpl	%eax, %edi
	setl	%al
	movzbl	%al, %eax
	testl	%eax, %eax
	je	.L2607_else
	# then: [:assign, :"#e", :nil]
	movl	nil, %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
	jmp	.L2608_endif
	# else: [:assign, :"#e", :e]
.L2607_else:
	movl	20(%ebp), %eax
	pushl	%eax
	popl	%eax
	movl	%eax, -8(%ebp)
.L2608_endif:
	# METHOD BODY:
	.stabn  68,0,1045,.LM1496	
.LM1496:
	.stabn  68,0,1046,.LM1497	
.LM1497:
	# callm [:index, :__env__, 2].:<<
	subl	$28, %esp
	movl	16(%ebp), %eax
	movl	%eax, %ecx
	addl	$8, %ecx
	movl	(%ecx), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	# callm :e.:next
	subl	$24, %esp
	movl	-8(%ebp), %eax
	movl	%eax, (%esp)
	movl	$0, 4(%esp)
	movl	$2, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff__next(%eax)
	# Evicting self
	# Static adj: 24
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm e.next END
	movl	%eax, 8(%esp)
	movl	$3, %ebx
	movl	(%esp), %esi
	movl	(%esi), %eax
	call	*__voff____lt__lt(%eax)
	# Evicting self
	# Static adj: 28
	addl	$4, %ebx
	sall	$2, %ebx
	addl	%ebx, %esp
	# callm [:index, :__env__, 2].<< END
	addl	$4, %esp
	# Reloading self if evicted:
	# [:arg, 0, :esi]
	movl	8(%ebp), %esi
	popl	%ebx
	leave	
	ret	
	.size	__lambda_L96, .-__lambda_L96
.Lscope336:
	.stabs  "",36,0,0,.Lscope336-.LFBB336	
		
	########################################################################	
		
		
		
		
__vtable_thunks_start:
__vtable_missing_thunk_new:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2609, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk___send__:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2610, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk___get_symbol:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2295, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk___initialize:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2611, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_allocate:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2612, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk___new:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2613, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_name:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2614, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_to_s:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2615, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_inspect:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2616, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk___X__3d:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L36, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_superclass:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2617, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_define_method:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2618, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_attr_accessor:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2619, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_attr_reader:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2620, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_attr_writer:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2621, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_puts:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2622, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_initialize:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2623, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_class:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2624, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_object_id:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2625, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_hash:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2626, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_eql__Q:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2627, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk___eq__3d:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L34, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk___eq:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L32, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk___X:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2628, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_nil__Q:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2629, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_method_missing:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2630, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_respond_to__Q:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2631, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_is_a__Q:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2632, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_kind_of__Q:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2633, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_send:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2634, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_p:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2635, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_exit:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2636, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_print:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2637, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_Array:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L175, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_dup:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2638, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk___set_raw:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2639, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_arity:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2640, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_call:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2641, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk___len:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2642, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk___ptr:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2643, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk___grow:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2644, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk___set:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2645, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_to_a:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L761, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk___true__Q:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2646, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_first:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2647, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_last:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2648, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_member__Q:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2649, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_include__Q:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2650, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_each:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2651, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_to_enum:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2652, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_capacity:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2653, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk___get:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2654, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_find:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2655, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_reject:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2656, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_collect:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2657, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_detect:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2658, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_each_with_index:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2659, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk___plus:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2660, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk___lt__lt:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L47, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk___NDX:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2661, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk___offset_to_pos:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2662, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk___range_get:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2663, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk___NDX__3d:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2664, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_abbrev:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2665, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_slice:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2666, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_assoc:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2667, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_at:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2668, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_clear:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2669, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_collect__X:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2670, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_compact:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2671, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_compact__X:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2672, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_concat:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2673, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_dclone:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2674, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_delete:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2675, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_delete_at:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2676, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_delete_if:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2677, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_each_index:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2678, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_empty__Q:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2679, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_fetch:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2680, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_fill:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2681, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_flatten:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2682, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_flatten__X:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2683, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_frozen__Q:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2684, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_index:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2685, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_replace:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2686, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_insert:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2687, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_join:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2688, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_length:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2689, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_map__X:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2690, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_nitems:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2691, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_pack:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2692, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_pop:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2693, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_pretty_print:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2694, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_push:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2695, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_quote:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2696, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_rassoc:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2697, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_reject__X:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2698, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_reverse:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2699, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_reverse__X:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2700, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_reverse_each:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2701, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_rindex:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2702, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_shift:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2703, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_size:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2704, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_partition:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2705, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_sort_by:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2706, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_sort:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2707, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_sort__X:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2708, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_to_ary:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L758, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_to_yaml:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2709, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_transpose:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2710, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_uniq:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2711, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_uniq__X:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2712, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_unshift:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2713, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_values_at:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2714, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_yaml_initialize:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2715, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_zip:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2716, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk___copy_raw:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2717, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk___get_raw:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2718, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_chr:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2719, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_ord:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2720, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_each_byte:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2721, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk___le__gt:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L40, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_to_sym:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2722, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_to_i:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2723, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_slice__X:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2724, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_count:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2725, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk___mul:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2726, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_gsub:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2727, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_split:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2728, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk__alloc_data:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2729, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk__bulkinsert:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2730, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk__grow:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2731, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk__find_slot:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2732, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_capacity_too_low:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2733, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk___delete_first:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2734, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_getc:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2735, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_file__Q:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2736, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_path:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2737, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_open:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2738, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_exists__Q:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2739, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_basename:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2740, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_dirname:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2741, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_expand_path:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2742, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_pwd:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2743, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk___25:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L53, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk___minus:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L31, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk___le:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L38, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk___lt:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L45, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk___gt:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L4, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk___ge:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L42, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_div:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2744, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_mul:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2745, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk___div:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L24, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_times:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2746, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_method_to_voff:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2747, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk___send_for_obj__:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2748, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_keys:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2749, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_next:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2750, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_rewind:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2751, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_raise:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2752, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_missing_thunk_multiply:
	pushl	%ebx
	subl	$20, %esp
	movl	$.L2753, %eax
	movl	%eax, (%esp)
	movl	$1, %ebx
	call	__get_symbol
	addl	$20, %esp
	# [:global, :self, :esi]
	movl	self, %esi
	popl	%ebx
	movl	4(%esp), %esi
	movl	(%esp), %ecx
	pushl	%ecx
	movl	%esi, 4(%esp)
	movl	12(%esp), %ecx
	movl	%ecx, 8(%esp)
	movl	%eax, 12(%esp)
	addl	$1, %ebx
	movl	(%esi), %eax
	jmp	*__voff__method_missing(%eax)
__vtable_thunks_end:
__base_vtable:
	.long 0	
	.long 0	
	.long 0	
	.long 0	
	.long 0	
	.long 0	
	.long __vtable_missing_thunk_new	
	.long __vtable_missing_thunk___send__	
	.long __vtable_missing_thunk___get_symbol	
	.long __vtable_missing_thunk___initialize	
	.long __vtable_missing_thunk_allocate	
	.long __vtable_missing_thunk___new	
	.long __vtable_missing_thunk_name	
	.long __vtable_missing_thunk_to_s	
	.long __vtable_missing_thunk_inspect	
	.long __vtable_missing_thunk___X__3d	
	.long __vtable_missing_thunk_superclass	
	.long __vtable_missing_thunk_define_method	
	.long __vtable_missing_thunk_attr_accessor	
	.long __vtable_missing_thunk_attr_reader	
	.long __vtable_missing_thunk_attr_writer	
	.long __vtable_missing_thunk_puts	
	.long __vtable_missing_thunk_initialize	
	.long __vtable_missing_thunk_class	
	.long __vtable_missing_thunk_object_id	
	.long __vtable_missing_thunk_hash	
	.long __vtable_missing_thunk_eql__Q	
	.long __vtable_missing_thunk___eq__3d	
	.long __vtable_missing_thunk___eq	
	.long __vtable_missing_thunk___X	
	.long __vtable_missing_thunk_nil__Q	
	.long __vtable_missing_thunk_method_missing	
	.long __vtable_missing_thunk_respond_to__Q	
	.long __vtable_missing_thunk_is_a__Q	
	.long __vtable_missing_thunk_kind_of__Q	
	.long __vtable_missing_thunk_send	
	.long __vtable_missing_thunk_p	
	.long __vtable_missing_thunk_exit	
	.long __vtable_missing_thunk_print	
	.long __vtable_missing_thunk_Array	
	.long __vtable_missing_thunk_dup	
	.long __vtable_missing_thunk___set_raw	
	.long __vtable_missing_thunk_arity	
	.long __vtable_missing_thunk_call	
	.long __vtable_missing_thunk___len	
	.long __vtable_missing_thunk___ptr	
	.long __vtable_missing_thunk___grow	
	.long __vtable_missing_thunk___set	
	.long __vtable_missing_thunk_to_a	
	.long __vtable_missing_thunk___true__Q	
	.long __vtable_missing_thunk_first	
	.long __vtable_missing_thunk_last	
	.long __vtable_missing_thunk_member__Q	
	.long __vtable_missing_thunk_include__Q	
	.long __vtable_missing_thunk_each	
	.long __vtable_missing_thunk_to_enum	
	.long __vtable_missing_thunk_capacity	
	.long __vtable_missing_thunk___get	
	.long __vtable_missing_thunk_find	
	.long __vtable_missing_thunk_reject	
	.long __vtable_missing_thunk_collect	
	.long __vtable_missing_thunk_detect	
	.long __vtable_missing_thunk_each_with_index	
	.long __vtable_missing_thunk___plus	
	.long __vtable_missing_thunk___lt__lt	
	.long __vtable_missing_thunk___NDX	
	.long __vtable_missing_thunk___offset_to_pos	
	.long __vtable_missing_thunk___range_get	
	.long __vtable_missing_thunk___NDX__3d	
	.long __vtable_missing_thunk_abbrev	
	.long __vtable_missing_thunk_slice	
	.long __vtable_missing_thunk_assoc	
	.long __vtable_missing_thunk_at	
	.long __vtable_missing_thunk_clear	
	.long __vtable_missing_thunk_collect__X	
	.long __vtable_missing_thunk_compact	
	.long __vtable_missing_thunk_compact__X	
	.long __vtable_missing_thunk_concat	
	.long __vtable_missing_thunk_dclone	
	.long __vtable_missing_thunk_delete	
	.long __vtable_missing_thunk_delete_at	
	.long __vtable_missing_thunk_delete_if	
	.long __vtable_missing_thunk_each_index	
	.long __vtable_missing_thunk_empty__Q	
	.long __vtable_missing_thunk_fetch	
	.long __vtable_missing_thunk_fill	
	.long __vtable_missing_thunk_flatten	
	.long __vtable_missing_thunk_flatten__X	
	.long __vtable_missing_thunk_frozen__Q	
	.long __vtable_missing_thunk_index	
	.long __vtable_missing_thunk_replace	
	.long __vtable_missing_thunk_insert	
	.long __vtable_missing_thunk_join	
	.long __vtable_missing_thunk_length	
	.long __vtable_missing_thunk_map__X	
	.long __vtable_missing_thunk_nitems	
	.long __vtable_missing_thunk_pack	
	.long __vtable_missing_thunk_pop	
	.long __vtable_missing_thunk_pretty_print	
	.long __vtable_missing_thunk_push	
	.long __vtable_missing_thunk_quote	
	.long __vtable_missing_thunk_rassoc	
	.long __vtable_missing_thunk_reject__X	
	.long __vtable_missing_thunk_reverse	
	.long __vtable_missing_thunk_reverse__X	
	.long __vtable_missing_thunk_reverse_each	
	.long __vtable_missing_thunk_rindex	
	.long __vtable_missing_thunk_shift	
	.long __vtable_missing_thunk_size	
	.long __vtable_missing_thunk_partition	
	.long __vtable_missing_thunk_sort_by	
	.long __vtable_missing_thunk_sort	
	.long __vtable_missing_thunk_sort__X	
	.long __vtable_missing_thunk_to_ary	
	.long __vtable_missing_thunk_to_yaml	
	.long __vtable_missing_thunk_transpose	
	.long __vtable_missing_thunk_uniq	
	.long __vtable_missing_thunk_uniq__X	
	.long __vtable_missing_thunk_unshift	
	.long __vtable_missing_thunk_values_at	
	.long __vtable_missing_thunk_yaml_initialize	
	.long __vtable_missing_thunk_zip	
	.long __vtable_missing_thunk___copy_raw	
	.long __vtable_missing_thunk___get_raw	
	.long __vtable_missing_thunk_chr	
	.long __vtable_missing_thunk_ord	
	.long __vtable_missing_thunk_each_byte	
	.long __vtable_missing_thunk___le__gt	
	.long __vtable_missing_thunk_to_sym	
	.long __vtable_missing_thunk_to_i	
	.long __vtable_missing_thunk_slice__X	
	.long __vtable_missing_thunk_count	
	.long __vtable_missing_thunk___mul	
	.long __vtable_missing_thunk_gsub	
	.long __vtable_missing_thunk_split	
	.long __vtable_missing_thunk__alloc_data	
	.long __vtable_missing_thunk__bulkinsert	
	.long __vtable_missing_thunk__grow	
	.long __vtable_missing_thunk__find_slot	
	.long __vtable_missing_thunk_capacity_too_low	
	.long __vtable_missing_thunk___delete_first	
	.long __vtable_missing_thunk_getc	
	.long __vtable_missing_thunk_file__Q	
	.long __vtable_missing_thunk_path	
	.long __vtable_missing_thunk_open	
	.long __vtable_missing_thunk_exists__Q	
	.long __vtable_missing_thunk_basename	
	.long __vtable_missing_thunk_dirname	
	.long __vtable_missing_thunk_expand_path	
	.long __vtable_missing_thunk_pwd	
	.long __vtable_missing_thunk___25	
	.long __vtable_missing_thunk___minus	
	.long __vtable_missing_thunk___le	
	.long __vtable_missing_thunk___lt	
	.long __vtable_missing_thunk___gt	
	.long __vtable_missing_thunk___ge	
	.long __vtable_missing_thunk_div	
	.long __vtable_missing_thunk_mul	
	.long __vtable_missing_thunk___div	
	.long __vtable_missing_thunk_times	
	.long __vtable_missing_thunk_method_to_voff	
	.long __vtable_missing_thunk___send_for_obj__	
	.long __vtable_missing_thunk_keys	
	.long __vtable_missing_thunk_next	
	.long __vtable_missing_thunk_rewind	
	.long __vtable_missing_thunk_raise	
	.long __vtable_missing_thunk_multiply	
	.equ	__vtable_size, 167
__vtable_names:
	.long 0	
	.long 0	
	.long 0	
	.long 0	
	.long 0	
	.long 0	
	.long	.L2609
	.long	.L2610
	.long	.L2295
	.long	.L2611
	.long	.L2612
	.long	.L2613
	.long	.L2614
	.long	.L2615
	.long	.L2616
	.long	.L36
	.long	.L2617
	.long	.L2618
	.long	.L2619
	.long	.L2620
	.long	.L2621
	.long	.L2622
	.long	.L2623
	.long	.L2624
	.long	.L2625
	.long	.L2626
	.long	.L2627
	.long	.L34
	.long	.L32
	.long	.L2628
	.long	.L2629
	.long	.L2630
	.long	.L2631
	.long	.L2632
	.long	.L2633
	.long	.L2634
	.long	.L2635
	.long	.L2636
	.long	.L2637
	.long	.L175
	.long	.L2638
	.long	.L2639
	.long	.L2640
	.long	.L2641
	.long	.L2642
	.long	.L2643
	.long	.L2644
	.long	.L2645
	.long	.L761
	.long	.L2646
	.long	.L2647
	.long	.L2648
	.long	.L2649
	.long	.L2650
	.long	.L2651
	.long	.L2652
	.long	.L2653
	.long	.L2654
	.long	.L2655
	.long	.L2656
	.long	.L2657
	.long	.L2658
	.long	.L2659
	.long	.L2660
	.long	.L47
	.long	.L2661
	.long	.L2662
	.long	.L2663
	.long	.L2664
	.long	.L2665
	.long	.L2666
	.long	.L2667
	.long	.L2668
	.long	.L2669
	.long	.L2670
	.long	.L2671
	.long	.L2672
	.long	.L2673
	.long	.L2674
	.long	.L2675
	.long	.L2676
	.long	.L2677
	.long	.L2678
	.long	.L2679
	.long	.L2680
	.long	.L2681
	.long	.L2682
	.long	.L2683
	.long	.L2684
	.long	.L2685
	.long	.L2686
	.long	.L2687
	.long	.L2688
	.long	.L2689
	.long	.L2690
	.long	.L2691
	.long	.L2692
	.long	.L2693
	.long	.L2694
	.long	.L2695
	.long	.L2696
	.long	.L2697
	.long	.L2698
	.long	.L2699
	.long	.L2700
	.long	.L2701
	.long	.L2702
	.long	.L2703
	.long	.L2704
	.long	.L2705
	.long	.L2706
	.long	.L2707
	.long	.L2708
	.long	.L758
	.long	.L2709
	.long	.L2710
	.long	.L2711
	.long	.L2712
	.long	.L2713
	.long	.L2714
	.long	.L2715
	.long	.L2716
	.long	.L2717
	.long	.L2718
	.long	.L2719
	.long	.L2720
	.long	.L2721
	.long	.L40
	.long	.L2722
	.long	.L2723
	.long	.L2724
	.long	.L2725
	.long	.L2726
	.long	.L2727
	.long	.L2728
	.long	.L2729
	.long	.L2730
	.long	.L2731
	.long	.L2732
	.long	.L2733
	.long	.L2734
	.long	.L2735
	.long	.L2736
	.long	.L2737
	.long	.L2738
	.long	.L2739
	.long	.L2740
	.long	.L2741
	.long	.L2742
	.long	.L2743
	.long	.L53
	.long	.L31
	.long	.L38
	.long	.L45
	.long	.L4
	.long	.L42
	.long	.L2744
	.long	.L2745
	.long	.L24
	.long	.L2746
	.long	.L2747
	.long	.L2748
	.long	.L2749
	.long	.L2750
	.long	.L2751
	.long	.L2752
	.long	.L2753
	# 
	.section	.rodata
.L0:
	.asciz	""
.L1:
	.asciz	"="
.L2:
	.asciz	"#<"
.L3:
	.asciz	":"
.L4:
	.asciz	">"
.L5:
	.asciz	"Method missing "
.L6:
	.asciz	"#"
.L7:
	.asciz	"true"
.L8:
	.asciz	"false"
.L9:
	.asciz	"nil"
.L10:
	.asciz	".."
.L11:
	.asciz	"IndexError: index "
.L12:
	.asciz	" too small for array; minimum "
.L13:
	.asciz	"["
.L14:
	.asciz	", "
.L15:
	.asciz	"]"
.L16:
	.asciz	"e"
.L17:
	.asciz	"n"
.L18:
	.asciz	"ERROR: String#[]= NOT IMPLEMENTED YET; Called with ("
.L19:
	.asciz	",'"
.L20:
	.asciz	"')"
.L21:
	.asciz	"WARNING: String#gsub with strings longer than one character not supported"
.L22:
	.asciz	" "
.L23:
	.asciz	"ERROR: @capacity <= @length *after* _grow"
.L24:
	.asciz	"/"
.L25:
	.asciz	"r"
.L26:
	.asciz	"."
.L27:
	.asciz	"ERROR: Invalid radix "
.L28:
	.asciz	" - must be between 2 and 36"
.L29:
	.asciz	"0123456789abcdefghijklmnopqrstuvwxyz"
.L30:
	.asciz	"0"
.L31:
	.asciz	"-"
.L32:
	.asciz	"=="
.L33:
	.asciz	":=="
.L34:
	.asciz	"==="
.L35:
	.asciz	":==="
.L36:
	.asciz	"!="
.L37:
	.asciz	":!="
.L38:
	.asciz	"<="
.L39:
	.asciz	":<="
.L40:
	.asciz	"<=>"
.L41:
	.asciz	":<=>"
.L42:
	.asciz	">="
.L43:
	.asciz	":>="
.L44:
	.asciz	":>"
.L45:
	.asciz	"<"
.L46:
	.asciz	":<"
.L47:
	.asciz	"<<"
.L48:
	.asciz	":<<"
.L49:
	.asciz	">>"
.L50:
	.asciz	":>>"
.L51:
	.asciz	":-"
.L52:
	.asciz	":/"
.L53:
	.asciz	"%"
.L54:
	.asciz	":%"
.L55:
	.asciz	"ERROR: odd number of arguments for Hash"
.L56:
	.asciz	"{"
.L57:
	.asciz	"=>"
.L58:
	.asciz	"}"
.L59:
	.asciz	"lib/core/stubs.rb"
.L60:
	.asciz	"ERROR: Exception support not yet implemented"
.L61:
	.asciz	"ERROR: Arguments to raise were:"
.L62:
	.asciz	"ERROR ============="
.L63:
	.asciz	"vidarh/compiler"
.L120:
	.asciz	"Class"
.L136:
	.asciz	"Kernel"
.L140:
	.asciz	"Object"
.L167:
	.asciz	"Proc"
.L175:
	.asciz	"Array"
.L185:
	.asciz	"TrueClass"
.L192:
	.asciz	"FalseClass"
.L199:
	.asciz	"NilClass"
.L211:
	.asciz	"Range"
.L237:
	.asciz	"<Array eigenclass>"
.L308:
	.asciz	"String"
.L346:
	.asciz	"Hash"
.L349:
	.asciz	"Hash__Deleted"
.L350:
	.asciz	"<Deleted eigenclass>"
.L353:
	.asciz	"<Hash eigenclass>"
.L374:
	.asciz	"IO"
.L381:
	.asciz	"File"
.L382:
	.asciz	"<File eigenclass>"
.L393:
	.asciz	"Dir"
.L394:
	.asciz	"<Dir eigenclass>"
.L398:
	.asciz	"Numeric"
.L401:
	.asciz	"Integer"
.L404:
	.asciz	"Fixnum"
.L406:
	.asciz	"<Fixnum eigenclass>"
.L436:
	.asciz	"Symbol"
.L445:
	.asciz	"<Symbol eigenclass>"
.L450:
	.asciz	"<Class eigenclass>"
.L467:
	.asciz	"Float"
.L470:
	.asciz	"Struct"
.L474:
	.asciz	"Exception"
.L477:
	.asciz	"PP"
.L480:
	.asciz	"Regexp"
.L484:
	.asciz	"Enumerator"
.L487:
	.asciz	"ArrayEnumerator"
.L492:
	.asciz	"RangeEnumerator"
.L500:
	.asciz	"/home/vagrant/hokstad/lib/core/debug.rb"
.L508:
	.asciz	"__method_missing"
.L509:
	.asciz	"Method missing: %s#%s\12"
.L510:
	.asciz	"__alloc"
.L513:
	.asciz	"__alloc_mem"
.L514:
	.asciz	"__alloc_leaf"
.L515:
	.asciz	"__realloc"
.L516:
	.asciz	"__array"
.L517:
	.asciz	"__array_leaf"
.L518:
	.asciz	"__docnt"
.L519:
	.asciz	"__cnt: %ld\12"
.L520:
	.asciz	"__new_class_object"
.L529:
	.asciz	"__set_vtable"
.L534:
	.asciz	"__method_Class___initialize"
.L536:
	.asciz	"ArgumentError: In %s - expected a minimum of %d arguments, got %d\12"
.L539:
	.asciz	"ArgumentError: In %s - expected a maximum of %d arguments, got %d\12"
.L541:
	.asciz	"__method_Class_allocate"
.L547:
	.asciz	"FATAL: Failed to allocate object of size %ld, class %s\12"
.L549:
	.asciz	"__method_Class___new"
.L554:
	.asciz	"__method_Class_new"
.L560:
	.asciz	"__method_Class_name"
.L565:
	.asciz	"__method_Class_to_s"
.L570:
	.asciz	"__method_Class_inspect"
.L575:
	.asciz	"__method_Class___X__3d"
.L580:
	.asciz	"__method_Class_superclass"
.L587:
	.asciz	"__method_Class_define_method"
.L592:
	.asciz	"define_method %s\12"
.L593:
	.asciz	"__method_Class_attr_accessor"
.L598:
	.asciz	"__method_Class_attr_reader"
.L603:
	.asciz	"attr_reader %s\12"
.L605:
	.asciz	"__method_Class_attr_writer"
.L610:
	.asciz	"attr_writer %s\12"
.L612:
	.asciz	"__method_Kernel_puts"
.L617:
	.asciz	"__method_Object_initialize"
.L622:
	.asciz	"__method_Object_class"
.L627:
	.asciz	"__method_Object_object_id"
.L632:
	.asciz	"__method_Object_hash"
.L637:
	.asciz	"__method_Object_eql__Q"
.L642:
	.asciz	"__method_Object___eq__3d"
.L647:
	.asciz	"__method_Object_inspect"
.L652:
	.asciz	"%p"
.L653:
	.asciz	"__method_Object_to_s"
.L658:
	.asciz	"__method_Object___eq"
.L663:
	.asciz	"__method_Object___X"
.L668:
	.asciz	"__method_Object___X__3d"
.L673:
	.asciz	"__method_Object_nil__Q"
.L678:
	.asciz	"__method_Object_method_missing"
.L681:
	.asciz	"__method_Object_respond_to__Q"
.L692:
	.asciz	"__method_Object_is_a__Q"
.L703:
	.asciz	"__method_Object_kind_of__Q"
.L708:
	.asciz	"__method_Object_send"
.L714:
	.asciz	"__method_Object___send__"
.L720:
	.asciz	"__method_Object_p"
.L725:
	.asciz	"__method_Object_exit"
.L730:
	.asciz	"__method_Object_puts"
.L739:
	.asciz	"%s"
.L744:
	.asciz	"__method_Object_print"
.L753:
	.asciz	"__method_Object_Array"
.L758:
	.asciz	"to_ary"
.L761:
	.asciz	"to_a"
.L764:
	.asciz	"__method_Object_dup"
.L769:
	.asciz	"__method_Proc_initialize"
.L774:
	.asciz	"__method_Proc___set_raw"
.L779:
	.asciz	"__method_Proc_arity"
.L784:
	.asciz	"__method_Proc_call"
.L790:
	.asciz	"__new_proc"
.L791:
	.asciz	"__method_Array___initialize"
.L796:
	.asciz	"__method_Array___len"
.L801:
	.asciz	"__method_Array___ptr"
.L806:
	.asciz	"__method_Array___grow"
.L813:
	.asciz	"__method_Array___set"
.L820:
	.asciz	"__method_Array_to_a"
.L825:
	.asciz	"__splat_to_Array"
.L828:
	.asciz	"__method_TrueClass___X"
.L833:
	.asciz	"__method_TrueClass_to_s"
.L838:
	.asciz	"__method_TrueClass_inspect"
.L843:
	.asciz	"__method_TrueClass___eq"
.L850:
	.asciz	"__method_FalseClass___true__Q"
.L855:
	.asciz	"__method_FalseClass_to_s"
.L860:
	.asciz	"__method_FalseClass_inspect"
.L865:
	.asciz	"__method_FalseClass___X"
.L870:
	.asciz	"__method_NilClass___true__Q"
.L875:
	.asciz	"__method_NilClass___eq"
.L880:
	.asciz	"__method_NilClass_nil__Q"
.L885:
	.asciz	"__method_NilClass___X"
.L890:
	.asciz	"__method_NilClass_to_s"
.L895:
	.asciz	"__method_NilClass_inspect"
.L900:
	.asciz	"__method_Class_allocate__1"
.L907:
	.asciz	"__method_Range_initialize"
.L912:
	.asciz	"__method_Range_to_s"
.L917:
	.asciz	"__method_Range_inspect"
.L922:
	.asciz	"__method_Range_first"
.L927:
	.asciz	"__method_Range_last"
.L932:
	.asciz	"__method_Range_member__Q"
.L941:
	.asciz	"__method_Range_include__Q"
.L946:
	.asciz	"__method_Range___eq__3d"
.L951:
	.asciz	"__method_Range_each"
.L958:
	.asciz	"__method_Range_to_a"
.L964:
	.asciz	"__method_Range_to_enum"
.L969:
	.asciz	"__method_Array_initialize"
.L974:
	.asciz	"__method_Array_capacity"
.L979:
	.asciz	"__method_Array___get"
.L984:
	.asciz	"__method_Array_find"
.L990:
	.asciz	"__method_Array_include__Q"
.L996:
	.asciz	"__method_Array_reject"
.L1002:
	.asciz	"__method_Array_collect"
.L1012:
	.asciz	"__method_Array_detect"
.L1022:
	.asciz	"__method_Array_each_with_index"
.L1028:
	.asciz	"__method_Array___plus"
.L1033:
	.asciz	"__method_Array___lt__lt"
.L1040:
	.asciz	"__method_Array___eq"
.L1050:
	.asciz	"__method____NDX"
.L1054:
	.asciz	"__method_Array___offset_to_pos"
.L1065:
	.asciz	"__method_Array___range_get"
.L1076:
	.asciz	"__method_Array___NDX"
.L1091:
	.asciz	"__method_Array___NDX__3d"
.L1100:
	.asciz	"__method_Array_abbrev"
.L1107:
	.asciz	"Array#abbrev not implemented"
.L1108:
	.asciz	"__method_Array_slice"
.L1113:
	.asciz	"__method_Array_assoc"
.L1119:
	.asciz	"__method_Array_at"
.L1124:
	.asciz	"__method_Array_clear"
.L1129:
	.asciz	"__method_Array_collect__X"
.L1134:
	.asciz	"__method_Array_compact"
.L1140:
	.asciz	"__method_Array_compact__X"
.L1145:
	.asciz	"Array#compact! not implemented"
.L1146:
	.asciz	"__method_Array_concat"
.L1152:
	.asciz	"__method_Array_dclone"
.L1157:
	.asciz	"Array#dclone not implemented"
.L1158:
	.asciz	"__method_Array_delete"
.L1169:
	.asciz	"__method_Array_delete_at"
.L1180:
	.asciz	"__method_Array_delete_if"
.L1185:
	.asciz	"Array#delete_if not implemented"
.L1186:
	.asciz	"__method_Array_dup"
.L1192:
	.asciz	"__method_Array_each"
.L1208:
	.asciz	"__method_Array_member__Q"
.L1214:
	.asciz	"__method_Array_each_index"
.L1221:
	.asciz	"__method_Array_empty__Q"
.L1226:
	.asciz	"__method_Array_eql__Q"
.L1241:
	.asciz	"__method_Array_fetch"
.L1248:
	.asciz	"Array#fetch not implemented"
.L1249:
	.asciz	"__method_Array_fill"
.L1254:
	.asciz	"Array#fill not implemented"
.L1255:
	.asciz	"__method_Array_first"
.L1271:
	.asciz	"__method_Array_flatten"
.L1279:
	.asciz	"__method_Array_flatten__X"
.L1284:
	.asciz	"Array#flatten! not implemented"
.L1285:
	.asciz	"__method_Array_frozen__Q"
.L1290:
	.asciz	"Array#frozen? not implemented"
.L1291:
	.asciz	"__method_Array_hash"
.L1297:
	.asciz	"__method_Array_index"
.L1306:
	.asciz	"__method_Array_replace"
.L1312:
	.asciz	"__method_Array_insert"
.L1323:
	.asciz	"__method_Array_inspect"
.L1329:
	.asciz	"__method_Array_join"
.L1335:
	.asciz	"__method_Array_last"
.L1349:
	.asciz	"__method_Array_length"
.L1354:
	.asciz	"__method_Array_collect__X__1"
.L1359:
	.asciz	"Array#collect! not implemented"
.L1360:
	.asciz	"__method_Array_map__X"
.L1365:
	.asciz	"Array#map! not implemented"
.L1366:
	.asciz	"__method_Array_nitems"
.L1372:
	.asciz	"select"
.L1373:
	.asciz	"__method_Array_pack"
.L1378:
	.asciz	"Array#pack not implemented"
.L1379:
	.asciz	"__method_Array_pop"
.L1386:
	.asciz	"__method_Array_pretty_print"
.L1391:
	.asciz	"Array#pretty_print not implemented"
.L1392:
	.asciz	"__method_Array_push"
.L1397:
	.asciz	"__method_Array_quote"
.L1402:
	.asciz	"Array#quote not implemented"
.L1403:
	.asciz	"__method_Array_rassoc"
.L1409:
	.asciz	"__method_Array_reject__X"
.L1414:
	.asciz	"Array#reject! not implemented"
.L1415:
	.asciz	"__method_Array_reverse"
.L1420:
	.asciz	"__method_Array_reverse__X"
.L1427:
	.asciz	"__method_Array_reverse_each"
.L1432:
	.asciz	"__method_Array_rindex"
.L1438:
	.asciz	"__method_Array_shift"
.L1445:
	.asciz	"__method_Array_size"
.L1450:
	.asciz	"__method_Array_partition"
.L1456:
	.asciz	"__method_Array_sort_by"
.L1464:
	.asciz	"__method_Array_sort"
.L1472:
	.asciz	"__method_Array_sort__X"
.L1477:
	.asciz	"Array#sort! not implemented"
.L1478:
	.asciz	"__method_Array_to_a__1"
.L1483:
	.asciz	"__method_Array_to_ary"
.L1488:
	.asciz	"__method_Array_to_yaml"
.L1493:
	.asciz	"Array#to_yaml not implemented"
.L1494:
	.asciz	"__method_Array_transpose"
.L1499:
	.asciz	"Array#transpose not implemented"
.L1500:
	.asciz	"__method_Array_uniq"
.L1506:
	.asciz	"__method_Array_uniq__X"
.L1513:
	.asciz	"__method_Array_unshift"
.L1516:
	.asciz	"Array#unshift not implemented"
.L1517:
	.asciz	"__method_Array_values_at"
.L1522:
	.asciz	"Array#values_at not implemented"
.L1523:
	.asciz	"__method_Array_yaml_initialize"
.L1528:
	.asciz	"Array#yaml_initialize not implemented"
.L1529:
	.asciz	"__method_Array_zip"
.L1534:
	.asciz	"__method_String_initialize"
.L1539:
	.asciz	"__method_String_inspect"
.L1545:
	.asciz	"__method_String_hash"
.L1551:
	.asciz	"__method_String___X"
.L1556:
	.asciz	"__method_String_nil__Q"
.L1561:
	.asciz	"__method_String___NDX"
.L1584:
	.asciz	"__method_String___NDX__3d"
.L1589:
	.asciz	"__method_String___eq"
.L1598:
	.asciz	"__method_String_eql__Q"
.L1603:
	.asciz	"__method_String___copy_raw"
.L1608:
	.asciz	"__method_String___set_raw"
.L1613:
	.asciz	"__method_String___get_raw"
.L1618:
	.asciz	"__method_String_empty__Q"
.L1623:
	.asciz	"__method_String_chr"
.L1628:
	.asciz	"__method_String_ord"
.L1633:
	.asciz	"__method_String_each_byte"
.L1640:
	.asciz	"__method_String___le__gt"
.L1659:
	.asciz	"__method_String_uniq"
.L1664:
	.asciz	"__method_String_to_s"
.L1669:
	.asciz	"__method_String_to_sym"
.L1674:
	.asciz	"__method_String_to_i"
.L1687:
	.asciz	"__method_String_slice__X"
.L1698:
	.asciz	"__method_String_reverse"
.L1707:
	.asciz	"__method_String_length"
.L1712:
	.asciz	"__method_String_size"
.L1717:
	.asciz	"__method_String_count"
.L1727:
	.asciz	"__method_String_concat"
.L1734:
	.asciz	"__method_String___lt__lt"
.L1739:
	.asciz	"__method_String_dup"
.L1744:
	.asciz	"__method_String___plus"
.L1749:
	.asciz	"__method_String___mul"
.L1755:
	.asciz	"__method_String_rindex"
.L1764:
	.asciz	"__method_String_gsub"
.L1772:
	.asciz	"__method_String_split"
.L1782:
	.asciz	"__get_string"
.L1783:
	.asciz	"__method__eql__Q"
.L1788:
	.asciz	"__method_Hash_initialize"
.L1795:
	.asciz	"__method____NDX__1"
.L1800:
	.asciz	"__method_Hash__alloc_data"
.L1805:
	.asciz	"__method_Hash__bulkinsert"
.L1814:
	.asciz	"__method_Hash__grow"
.L1819:
	.asciz	"__method_Hash__find_slot"
.L1828:
	.asciz	"__method_Hash_member__Q"
.L1835:
	.asciz	"__method_Hash_include__Q"
.L1840:
	.asciz	"__method_Hash_empty__Q"
.L1845:
	.asciz	"__method_Hash___NDX"
.L1852:
	.asciz	"__method_Hash_capacity_too_low"
.L1857:
	.asciz	"__method_Hash___NDX__3d"
.L1874:
	.asciz	"__method_Hash___delete_first"
.L1883:
	.asciz	"__method_Hash_shift"
.L1890:
	.asciz	"__method_Hash_length"
.L1895:
	.asciz	"__method_Hash_size"
.L1900:
	.asciz	"__method_Hash_to_a"
.L1906:
	.asciz	"__method_Hash_each"
.L1917:
	.asciz	"__method_Hash_delete"
.L1924:
	.asciz	"__method_IO_initialize"
.L1929:
	.asciz	"__method_IO_to_i"
.L1934:
	.asciz	"__method_IO_getc"
.L1941:
	.asciz	"__method_IO_file__Q"
.L1946:
	.asciz	"__method__file__Q"
.L1951:
	.asciz	"__method_File_path"
.L1956:
	.asciz	"__method_File_initialize"
.L1964:
	.asciz	"Failed to open '%s' got %ld\12"
.L1966:
	.asciz	"__method__open"
.L1973:
	.asciz	"__method__exists__Q"
.L1980:
	.asciz	"__method__basename"
.L1991:
	.asciz	"__method__dirname"
.L2004:
	.asciz	"__method__expand_path"
.L2014:
	.asciz	"__method__pwd"
.L2019:
	.asciz	"__method_Fixnum_initialize"
.L2024:
	.asciz	"__method__allocate"
.L2029:
	.asciz	"__method_Fixnum___25"
.L2036:
	.asciz	"__method_Fixnum___set_raw"
.L2041:
	.asciz	"__method_Fixnum___get_raw"
.L2046:
	.asciz	"__method_Fixnum_to_i"
.L2051:
	.asciz	"__method_Fixnum___NDX"
.L2056:
	.asciz	"__method_Fixnum_to_s"
.L2077:
	.asciz	"__method_Fixnum_hash"
.L2082:
	.asciz	"__method_Fixnum_inspect"
.L2087:
	.asciz	"__method_Fixnum_chr"
.L2092:
	.asciz	"%c"
.L2093:
	.asciz	"__method_Fixnum___plus"
.L2098:
	.asciz	"__method_Fixnum___minus"
.L2103:
	.asciz	"__method_Fixnum___le"
.L2110:
	.asciz	"__method_Fixnum___eq"
.L2121:
	.asciz	"__method_Fixnum___X"
.L2124:
	.asciz	"__method_Fixnum___X__3d"
.L2133:
	.asciz	"__method_Fixnum___lt"
.L2140:
	.asciz	"__method_Fixnum___gt"
.L2147:
	.asciz	"__method_Fixnum___ge"
.L2154:
	.asciz	"__method_Fixnum___le__gt"
.L2165:
	.asciz	"__method_Fixnum_div"
.L2170:
	.asciz	"__method_Fixnum_mul"
.L2175:
	.asciz	"__method_Fixnum___mul"
.L2180:
	.asciz	"__method_Fixnum___div"
.L2185:
	.asciz	"__method_Fixnum_ord"
.L2190:
	.asciz	"__method_Fixnum_times"
.L2197:
	.asciz	"__int"
.L2204:
	.asciz	"__method_Symbol_initialize"
.L2209:
	.asciz	"__method_Symbol_eql__Q"
.L2214:
	.asciz	"__method_Symbol___le__gt"
.L2221:
	.asciz	"__method_Symbol_to_s"
.L2226:
	.asciz	"__method_Symbol_to_sym"
.L2231:
	.asciz	"__method_Symbol_inspect"
.L2278:
	.asciz	"__method_Symbol_hash"
.L2283:
	.asciz	"__method_Symbol___NDX"
.L2288:
	.asciz	"__method____get_symbol"
.L2295:
	.asciz	"__get_symbol"
.L2296:
	.asciz	"__method__method_to_voff"
.L2301:
	.asciz	"__method_Class_method_missing"
.L2305:
	.asciz	"WARNING:    Method: '%s'\12"
.L2307:
	.asciz	"WARNING:    symbol address = %p\12"
.L2308:
	.asciz	"WARNING:    class '%s'\12"
.L2309:
	.asciz	"__method_Class___send_for_obj__"
.L2320:
	.asciz	"__method____NDX__2"
.L2327:
	.asciz	"__method_Hash_sort_by"
.L2333:
	.asciz	"__method_Hash_collect"
.L2338:
	.asciz	"__method_Hash_inspect"
.L2344:
	.asciz	"__method_Hash_keys"
.L2350:
	.asciz	"__method_Struct_initialize"
.L2353:
	.asciz	"__method_Regexp_initialize"
.L2358:
	.asciz	"__method_ArrayEnumerator_initialize"
.L2363:
	.asciz	"__method_ArrayEnumerator_next"
.L2370:
	.asciz	"__method_RangeEnumerator_initialize"
.L2375:
	.asciz	"__method_RangeEnumerator_rewind"
.L2380:
	.asciz	"__method_RangeEnumerator_next"
.L2387:
	.asciz	"__method_Object_raise"
.L2390:
	.asciz	"range"
.L2391:
	.asciz	"Compiler range construct is not implemented yet"
.L2392:
	.asciz	"printregs"
.L2393:
	.asciz	"eax: %08x, ebx: %08x, ecx: %08x, edx: %08x, esi: %08x, edi: %08x, ebp: %08x, esp: %08x\12"
.L2394:
	.asciz	"(ebp): %08x, %08x, %08x, %08x, %08x, %08x, %08x, %08x, %08x, %08x\12"
.L2395:
	.asciz	"(esp): %08x, %08x, %08x, %08x, %08x, %08x, %08x, %08x\12"
.L2396:
	.asciz	"__method_Integer___mul"
.L2401:
	.asciz	"__method_Object_multiply"
.L2406:
	.asciz	"__lambda_L64"
.L2407:
	.asciz	"__lambda_L65"
.L2410:
	.asciz	"__lambda_L66"
.L2413:
	.asciz	"__lambda_L67"
.L2418:
	.asciz	"__lambda_L68"
.L2423:
	.asciz	"__lambda_L69"
.L2428:
	.asciz	"__lambda_L70"
.L2431:
	.asciz	"__lambda_L71"
.L2436:
	.asciz	"__lambda_L72"
.L2439:
	.asciz	"__lambda_L73"
.L2444:
	.asciz	"__lambda_L74"
.L2447:
	.asciz	"__lambda_L75"
.L2454:
	.asciz	"__lambda_L76"
.L2457:
	.asciz	"__lambda_L77"
.L2460:
	.asciz	"__lambda_L78"
.L2463:
	.asciz	"__lambda_L79"
.L2468:
	.asciz	"__lambda_L80"
.L2471:
	.asciz	"__lambda_L81"
.L2480:
	.asciz	"__lambda_L82"
.L2483:
	.asciz	"__lambda_L83"
.L2486:
	.asciz	"__lambda_L84"
.L2491:
	.asciz	"__lambda_L85"
.L2496:
	.asciz	"__lambda_L86"
.L2499:
	.asciz	"__lambda_L87"
.L2502:
	.asciz	"__lambda_L88"
.L2509:
	.asciz	"__lambda_L89"
.L2516:
	.asciz	"__lambda_L90"
.L2521:
	.asciz	"__lambda_L91"
.L2524:
	.asciz	"__lambda_L92"
.L2527:
	.asciz	"__lambda_L93"
.L2532:
	.asciz	"__lambda_L94"
.L2535:
	.asciz	"__lambda_L95"
.L2539:
	.asciz	"__lambda_L97"
.L2550:
	.asciz	"__lambda_L98"
.L2553:
	.asciz	"__lambda_L99"
.L2558:
	.asciz	"__lambda_L100"
.L2559:
	.asciz	"__lambda_L101"
.L2564:
	.asciz	"__lambda_L102"
.L2577:
	.asciz	"__lambda_L103"
.L2582:
	.asciz	"__lambda_L104"
.L2591:
	.asciz	"__lambda_L105"
.L2594:
	.asciz	"__lambda_L106"
.L2601:
	.asciz	"__lambda_L107"
.L2606:
	.asciz	"__lambda_L96"
.L2609:
	.asciz	"new"
.L2610:
	.asciz	"__send__"
.L2611:
	.asciz	"__initialize"
.L2612:
	.asciz	"allocate"
.L2613:
	.asciz	"__new"
.L2614:
	.asciz	"name"
.L2615:
	.asciz	"to_s"
.L2616:
	.asciz	"inspect"
.L2617:
	.asciz	"superclass"
.L2618:
	.asciz	"define_method"
.L2619:
	.asciz	"attr_accessor"
.L2620:
	.asciz	"attr_reader"
.L2621:
	.asciz	"attr_writer"
.L2622:
	.asciz	"puts"
.L2623:
	.asciz	"initialize"
.L2624:
	.asciz	"class"
.L2625:
	.asciz	"object_id"
.L2626:
	.asciz	"hash"
.L2627:
	.asciz	"eql?"
.L2628:
	.asciz	"!"
.L2629:
	.asciz	"nil?"
.L2630:
	.asciz	"method_missing"
.L2631:
	.asciz	"respond_to?"
.L2632:
	.asciz	"is_a?"
.L2633:
	.asciz	"kind_of?"
.L2634:
	.asciz	"send"
.L2635:
	.asciz	"p"
.L2636:
	.asciz	"exit"
.L2637:
	.asciz	"print"
.L2638:
	.asciz	"dup"
.L2639:
	.asciz	"__set_raw"
.L2640:
	.asciz	"arity"
.L2641:
	.asciz	"call"
.L2642:
	.asciz	"__len"
.L2643:
	.asciz	"__ptr"
.L2644:
	.asciz	"__grow"
.L2645:
	.asciz	"__set"
.L2646:
	.asciz	"__true?"
.L2647:
	.asciz	"first"
.L2648:
	.asciz	"last"
.L2649:
	.asciz	"member?"
.L2650:
	.asciz	"include?"
.L2651:
	.asciz	"each"
.L2652:
	.asciz	"to_enum"
.L2653:
	.asciz	"capacity"
.L2654:
	.asciz	"__get"
.L2655:
	.asciz	"find"
.L2656:
	.asciz	"reject"
.L2657:
	.asciz	"collect"
.L2658:
	.asciz	"detect"
.L2659:
	.asciz	"each_with_index"
.L2660:
	.asciz	"+"
.L2661:
	.asciz	"[]"
.L2662:
	.asciz	"__offset_to_pos"
.L2663:
	.asciz	"__range_get"
.L2664:
	.asciz	"[]="
.L2665:
	.asciz	"abbrev"
.L2666:
	.asciz	"slice"
.L2667:
	.asciz	"assoc"
.L2668:
	.asciz	"at"
.L2669:
	.asciz	"clear"
.L2670:
	.asciz	"collect!"
.L2671:
	.asciz	"compact"
.L2672:
	.asciz	"compact!"
.L2673:
	.asciz	"concat"
.L2674:
	.asciz	"dclone"
.L2675:
	.asciz	"delete"
.L2676:
	.asciz	"delete_at"
.L2677:
	.asciz	"delete_if"
.L2678:
	.asciz	"each_index"
.L2679:
	.asciz	"empty?"
.L2680:
	.asciz	"fetch"
.L2681:
	.asciz	"fill"
.L2682:
	.asciz	"flatten"
.L2683:
	.asciz	"flatten!"
.L2684:
	.asciz	"frozen?"
.L2685:
	.asciz	"index"
.L2686:
	.asciz	"replace"
.L2687:
	.asciz	"insert"
.L2688:
	.asciz	"join"
.L2689:
	.asciz	"length"
.L2690:
	.asciz	"map!"
.L2691:
	.asciz	"nitems"
.L2692:
	.asciz	"pack"
.L2693:
	.asciz	"pop"
.L2694:
	.asciz	"pretty_print"
.L2695:
	.asciz	"push"
.L2696:
	.asciz	"quote"
.L2697:
	.asciz	"rassoc"
.L2698:
	.asciz	"reject!"
.L2699:
	.asciz	"reverse"
.L2700:
	.asciz	"reverse!"
.L2701:
	.asciz	"reverse_each"
.L2702:
	.asciz	"rindex"
.L2703:
	.asciz	"shift"
.L2704:
	.asciz	"size"
.L2705:
	.asciz	"partition"
.L2706:
	.asciz	"sort_by"
.L2707:
	.asciz	"sort"
.L2708:
	.asciz	"sort!"
.L2709:
	.asciz	"to_yaml"
.L2710:
	.asciz	"transpose"
.L2711:
	.asciz	"uniq"
.L2712:
	.asciz	"uniq!"
.L2713:
	.asciz	"unshift"
.L2714:
	.asciz	"values_at"
.L2715:
	.asciz	"yaml_initialize"
.L2716:
	.asciz	"zip"
.L2717:
	.asciz	"__copy_raw"
.L2718:
	.asciz	"__get_raw"
.L2719:
	.asciz	"chr"
.L2720:
	.asciz	"ord"
.L2721:
	.asciz	"each_byte"
.L2722:
	.asciz	"to_sym"
.L2723:
	.asciz	"to_i"
.L2724:
	.asciz	"slice!"
.L2725:
	.asciz	"count"
.L2726:
	.asciz	"*"
.L2727:
	.asciz	"gsub"
.L2728:
	.asciz	"split"
.L2729:
	.asciz	"_alloc_data"
.L2730:
	.asciz	"_bulkinsert"
.L2731:
	.asciz	"_grow"
.L2732:
	.asciz	"_find_slot"
.L2733:
	.asciz	"capacity_too_low"
.L2734:
	.asciz	"__delete_first"
.L2735:
	.asciz	"getc"
.L2736:
	.asciz	"file?"
.L2737:
	.asciz	"path"
.L2738:
	.asciz	"open"
.L2739:
	.asciz	"exists?"
.L2740:
	.asciz	"basename"
.L2741:
	.asciz	"dirname"
.L2742:
	.asciz	"expand_path"
.L2743:
	.asciz	"pwd"
.L2744:
	.asciz	"div"
.L2745:
	.asciz	"mul"
.L2746:
	.asciz	"times"
.L2747:
	.asciz	"method_to_voff"
.L2748:
	.asciz	"__send_for_obj__"
.L2749:
	.asciz	"keys"
.L2750:
	.asciz	"next"
.L2751:
	.asciz	"rewind"
.L2752:
	.asciz	"raise"
.L2753:
	.asciz	"multiply"
	.section	.bss
	.align	4
__roots_start:
ARGV:
	.long 0	
Array:
	.long 0	
ArrayEnumerator:
	.long 0	
Class:
	.long 0	
Dir:
	.long 0	
E:
	.long 0	
Enumerator:
	.long 0	
Exception:
	.long 0	
FalseClass:
	.long 0	
File:
	.long 0	
File__ALT_SEPARATOR:
	.long 0	
File__SEPARATOR:
	.long 0	
FixNum_cache:
	.long 0	
FixNum_cache_size:
	.long 0	
Fixnum:
	.long 0	
Float:
	.long 0	
Hash:
	.long 0	
Hash__Deleted:
	.long 0	
IO:
	.long 0	
Integer:
	.long 0	
Kernel:
	.long 0	
LOAD_PATH:
	.long 0	
NilClass:
	.long 0	
Numeric:
	.long 0	
Object:
	.long 0	
PP:
	.long 0	
Proc:
	.long 0	
RUBY_ENGINE:
	.long 0	
Range:
	.long 0	
RangeEnumerator:
	.long 0	
Regexp:
	.long 0	
STDERR:
	.long 0	
STDIN:
	.long 0	
STDOUT:
	.long 0	
String:
	.long 0	
Struct:
	.long 0	
Symbol:
	.long 0	
TrueClass:
	.long 0	
__D_0:
	.long 0	
__FILE__:
	.long 0	
__I0:
	.long 0	
__I1:
	.long 0	
__I10:
	.long 0	
__I122:
	.long 0	
__I13:
	.long 0	
__I14:
	.long 0	
__I2:
	.long 0	
__I27:
	.long 0	
__I3:
	.long 0	
__I33:
	.long 0	
__I34:
	.long 0	
__I36:
	.long 0	
__I4:
	.long 0	
__I42:
	.long 0	
__I43:
	.long 0	
__I45:
	.long 0	
__I47:
	.long 0	
__I48:
	.long 0	
__I5381:
	.long 0	
__I57:
	.long 0	
__I64:
	.long 0	
__I9:
	.long 0	
__I91:
	.long 0	
__I92:
	.long 0	
__I95:
	.long 0	
__I97:
	.long 0	
__Ineg1:
	.long 0	
__classvar__Symbol__symbols:
	.long 0	
__cnt:
	.long 0	
__stack_top:
	.long 0	
false:
	.long 0	
h:
	.long 0	
nil:
	.long 0	
self:
	.long 0	
sp:
	.long 0	
true:
	.long 0	
__roots_end:
