---
title: JRuby
layout: page
---

JRuby is an implementation of Ruby written in Java and running on the JVM. It's a complete re-implementation of the language, core library, some of the standard library and wider ecosystem, and started as an interpreter somewhat directly translated from the MRI C code. JRuby's JIT emits JVM classes and bytecode in-memory using the ASM library, which may then be compiled to native machine code by the JVM's existing powerful JIT compilers for Java. Translation from Ruby to JVM bytecode is via an intermediate representation with a CFG of basic blocks of linear register-transfer instructions in SSA form, upon which high-level optimisations using knowledge of Ruby semantics are performed. This IR is also used for interpretation, with the first tier of interpretation running on IR without optimisations, and a second tier of interpretaion running after optimisations have been applied. As well as the IR being optimised there are two distinct implementations of the actual IR interpreter. Profiling is conducted both by JRuby on the IR and other runtime structures, and also then by the JVM on the generated bytecode.

As both the compiled Ruby code and runtime code and extension libraries are available as JVM bytecode, the JVM is able to then inline between these levels. However restricting to languages that can conventionally compile to bytecode means that JRuby does not support C extensions.

JRuby is significant within the JVM ecosystem, as the `invokedynamic` instruction and associated framework was added to the JVM specifically to improve the performance of JRuby. JRuby was the only significant user of `invokedynamic` until the Nashorn JavaScript implementation and then use in Java itself for implementing lambdas. However the use of `invokedynamic` for Ruby method calls is still not enabled by default in JRuby today.

JRuby is likely the only Ruby JIT that has ever had significant use in production.

## Orientation

The JRuby source code is available at [our archive](https://github.com/ruby-compiler-survey/jruby) or the [original repository](https://github.com/jruby/jruby).

We're discussing JRuby 9.2.9.0, `458ad3ed9cdb18b3e69fb96b947b978a193afeb6`, 30 October 2019, which is the latest release as at 3 February 2020. JRuby by default will compile the entire entry-point script on load. This makes it hard to understand the compilation of individual methods, the effect of profiling, and things like compilation threshold. This feature cannot be disabled with an option, so we turn it off by patching the source code.

JRuby is usable on many different implementations of the JVM. In order for us to be able to talk in concrete terms, we're going to explain JRuby in the context of running on OpenJDK 8 (HotSpot). This JVM is the default in this version of JRuby's CI system and in practice is probably the platform that most people will be running JRuby on. We're also going to enable JRuby's invoke dynamic support, even though this is not the default, in order to show JRuby's compiler in its most sophisticated configuration.

*Pipeline diagram*

JRuby parses Ruby code to an AST, and then to an intermediate representation of linear instructions which we will call the *simple IR* which is interpreted. When a threshold is reached, the intermediate representation is transformed to create additional structure and to optimise it. JRuby also switches to an alternative intepreter for this *full IR*. When the next threshold is reached JRuby translates the IR to JVM bytecode in-memory, and then switches to executing methods which are effectively runtime synthesised Java code.

The compilation pipeline continues inside the JVM as it would for any other JVM bytecode such as a Java or Scala program. Initially the bytecode runs in an interpreter, but on meeting another threshold it is compiled to native machine code by the C1 compiler, also known as the *client* compiler, which performs simple optimisations and is designed to produce reasonable machine code reasonably quickly. When a final threshold is reached it is compiled again by the C2 compiler, also known as the *server* or *opto* compiler, which performs more powerful optimisations and is tuned to produce the best quality machine code.

C2 can be replaced with Graal, which is another JVM compiler used by TruffleRuby, and so discussed in more depth there. We'll also talk about how JRuby has been experimenting with Graal in the history section below.

The JVM can deoptimise from code produced by C1 and C2, back to the JVM bytecode, and in some sense back to the JRuby IR. We'll discuss this when talking about `invokedynamic`.

JRuby is unusual in that it involves at least five distinct execution tiers. There is the startup IR interpreter, the full IR interpreter, generated JVM bytecode running in the JVM interpreter, bytecode compiled by the C1 compiler, and bytecode compiled by the C2/Graal compiler. We could also talk about the two IR interpreters themselves running in those last three tiers, adding additional tiers to the system.

## Building and running

JRuby is easy to build using standard Java ecosystem tools. We don't need to do much more than install a JDK and run `./mvn package`. This will give you a `bin/ruby` command.

We'll use these flags to help us understand what the JRuby JIT is doing:

* `-Xir.print` to print full IR when it is JIT compiled to JVM bytecode
* `-Xir.print.all` to print all IR, including simple IR for the first tier of interpretation
* `-Xir.print.opt` to print all IR as it is optimized
* `-Xjit.logging` to show when the JRuby (Ruby to JVM bytecode) JIT is running
* `-Xcompile.dump` to show the bytecode output from the JIT
* `-J-XX:+PrintCompilation` to show when the JVM (JVM bytecode to machine code) JIT is running
* `-J-XX:CompileCommand=print,*::*foo*` to print the disassembly of `foo`

## Frontend

## Compilation thresholds

## Translation to IR

## Simple interpretation

## Optimisation at the IR level

## Full interpretation

## Translation to JVM bytecode

## Profiling

## Compilation by the JVM JITs

## `invokedynamic` and deoptimisation

JRuby's support for `invokedynamic` is still not enabled by default.

## Compilation tiers

We talked in the orientation about the number of execution tiers (they're compilation tiers, and then we count the interpreters to talk more generally about execution tiers) that JRuby involves. We can show three of the more important tiers by watching the log.

```
% ruby -Xjit.logging -J-XX:+PrintCompilation fib.rb
...
2020-02-05T01:33:41.174Z [Ruby-0-JIT-1] INFO JITCompiler : method done jitting: Object fib at /var/examples/fib.rb:0
...
   2818 2384       3       var.examples.fib::RUBY$method$fib$0 (93 bytes)
...
   2828 2387       4       var.examples.fib::RUBY$method$fib$0 (93 bytes)
...
```

The first line is JRuby telling us it has compiled to JVM bytecode, which will now run in the JVM bytecode interpreter. The second line has `3` in the third column, which is the JVM itself telling us that it has been compiled by the C1 compiler. The third line has `4`, which means it will be running in the C2/Graal compiler. There's no log entries for the first tier (compiling to IR to run in the interpreter) as all methods go through this tier.

We can also expose the hidden tiers we talked about where the two JRuby IR interpreters are themselves promoted up through the JVM compilation tiers - we can see them passing here through tiers `3` and `4`. I'm showing `InterpreterEngine::processCall`, which is a helper method, rather than `InterpreterEngine::interpret`, as we never observed the latter running in tier `4`. The exclamation point `!` indicates that the method has an exception handler.

```
...
   2277 1999   !   3       org.jruby.ir.interpreter.StartupInterpreterEngine::interpret (671 bytes)
...
   2614 2247   !   4       org.jruby.ir.interpreter.StartupInterpreterEngine::interpret (671 bytes)
...
   2643 2281       3       org.jruby.ir.interpreter.InterpreterEngine::processCall (663 bytes)
...
   2797 2297       4       org.jruby.ir.interpreter.InterpreterEngine::processCall (663 bytes)
...
```

With all this taken into account, an activation of a Ruby method running in JRuby could be in any of at least nine distinct execution tiers at a given moment, and other methods may be in their own different tier of execution.

* Simple IR interpreter (itself running in the JVM bytecode interpreter)
* Simple IR interpreter (itself compiled by C1)
* Simple IR interpreter (itself compiled by C2)
* Full IR interpreter (itself running in the JVM bytecode interpreter)
* Full IR interpreter (itself compiled by C1)
* Full IR interpreter (itself compiled by C2)
* Generated bytecode running in the JVM bytecode interpreter
* Generated bytecode compiled by C1
* Generated bytecode compiled by C2

## Evaluation

## History

## Corporate support

Sun Microsystems [hired][jruby-sun] the two current co-leads of JRuby, Charles Nutter and Tom Enebo, in 2006, followed later by Nick Sieger. In 2009 when Oracle acquired Sun the team [moved][jruby-engine-yard] to Engine Yard. Nutter and Enebo have been employed by RedHat [since 2012][jruby-redhat]. Ola Bini was [employed at ThoughtWorks][jruby-engine-yard] while working on JRuby.

[jruby-sun]: http://blog.headius.com/2006/09/jruby-steps-into-sun.html
[jruby-engine-yard]: https://www.pcworld.com/article/169145/article.html
[jruby-redhat]: https://www.theregister.co.uk/2012/05/23/red_hat_hires_j_ruby_brains/

## Building and running

See the [appendix on building and running JRuby](building).
